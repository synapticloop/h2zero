package com.synapticloop.sample.h2zero.mariadb.inserter;

// - - - - thoughtfully generated by synapticloop h2zero - - - - 
//    with the use of synapticloop templar templating language
//            (java/java-create-inserter.templar)

import java.io.InputStream;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.math.BigDecimal;
import java.sql.Date;
import java.sql.Blob;
import java.sql.Timestamp;
import java.sql.Time;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.synapticloop.h2zero.base.manager.mariadb.ConnectionManager;
import com.synapticloop.sample.h2zero.mariadb.model.util.Constants;

/**
 * This class contains the methods to insert new rows into the: 
 *   <code>sample.all_types</code>
 * table.  The fields that are available are as follows:
 * 
 * <ul>
 *  <li><code>id_all_types</code> (bigint)  <strong>NOT</strong> nullable  (PRIMARY)</li>
 *  <li><code>test_bigint</code> (bigint)  nullable </li>
 *  <li><code>test_blob</code> (blob)  nullable </li>
 *  <li><code>test_bool</code> (bool)  nullable </li>
 *  <li><code>test_char</code> (char)  nullable </li>
 *  <li><code>test_boolean</code> (boolean)  nullable </li>
 *  <li><code>test_binary</code> (binary)  nullable </li>
 *  <li><code>test_varbinary</code> (varbinary)  nullable </li>
 *  <li><code>test_date</code> (date)  nullable </li>
 *  <li><code>test_datetime</code> (datetime)  nullable </li>
 *  <li><code>test_dec</code> (dec)  nullable </li>
 *  <li><code>test_decimal</code> (decimal)  nullable </li>
 *  <li><code>test_double</code> (double)  nullable </li>
 *  <li><code>test_float</code> (float)  nullable </li>
 *  <li><code>test_int</code> (int)  nullable </li>
 *  <li><code>test_integer</code> (integer)  nullable </li>
 *  <li><code>test_longtext</code> (longtext)  nullable </li>
 *  <li><code>test_mediumblob</code> (mediumblob)  nullable </li>
 *  <li><code>test_mediumint</code> (mediumint)  nullable </li>
 *  <li><code>test_mediumtext</code> (mediumtext)  nullable </li>
 *  <li><code>test_numeric</code> (numeric)  nullable </li>
 *  <li><code>test_smallint</code> (smallint)  nullable </li>
 *  <li><code>test_time</code> (time)  nullable </li>
 *  <li><code>test_text</code> (text)  nullable </li>
 *  <li><code>test_timestamp</code> (timestamp)  nullable </li>
 *  <li><code>test_tinyint</code> (tinyint)  nullable </li>
 *  <li><code>test_tinytext</code> (tinytext)  nullable </li>
 *  <li><code>test_varchar</code> (varchar)  nullable </li>
 *  <li><code>test_year</code> (year)  nullable </li>
 * </ul>
 * 
 * @author synapticloop h2zero
 */

public class AllTypesInserter {
	// the binder is unused in code, but will generate compile problems if this 
	// class is no longer referenced in the h2zero file. Just a nicety for
	// removing dead code
	@SuppressWarnings("unused")
	private static final String BINDER = Constants.ALL_TYPES_BINDER;

		private static final Logger LOGGER = LoggerFactory.getLogger(AllTypesInserter.class);

	// static fields generated by synapticloop h2zero
	private static final String SQL_BUILTIN_INSERT_ALL = "insert into all_types(id_all_types, test_bigint, test_blob, test_bool, test_char, test_boolean, test_binary, test_varbinary, test_date, test_datetime, test_dec, test_decimal, test_double, test_float, test_int, test_integer, test_longtext, test_mediumblob, test_mediumint, test_mediumtext, test_numeric, test_smallint, test_time, test_text, test_timestamp, test_tinyint, test_tinytext, test_varchar, test_year)";
	private static final String SQL_BUILTIN_INSERT_VALUES = SQL_BUILTIN_INSERT_ALL + " values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
	// static inserter SQL generated from the user input

	private AllTypesInserter() {}

	/**
	 * Insert a new AllTypes into the database utilising the passed in connection.
	 * 
	 * @param connection the connection to use for the database, this __MUST__ be 
	 *   closed by the calling function.
	 * @param idAllTypes  maps to id_all_types
	 * @param testBigint  maps to test_bigint
	 * @param testBlob  maps to test_blob
	 * @param testBool  maps to test_bool
	 * @param testChar  maps to test_char
	 * @param testBoolean  maps to test_boolean
	 * @param testBinary  maps to test_binary
	 * @param testVarbinary  maps to test_varbinary
	 * @param testDate  maps to test_date
	 * @param testDatetime  maps to test_datetime
	 * @param testDec  maps to test_dec
	 * @param testDecimal  maps to test_decimal
	 * @param testDouble  maps to test_double
	 * @param testFloat  maps to test_float
	 * @param testInt  maps to test_int
	 * @param testInteger  maps to test_integer
	 * @param testLongtext  maps to test_longtext
	 * @param testMediumblob  maps to test_mediumblob
	 * @param testMediumint  maps to test_mediumint
	 * @param testMediumtext  maps to test_mediumtext
	 * @param testNumeric  maps to test_numeric
	 * @param testSmallint  maps to test_smallint
	 * @param testTime  maps to test_time
	 * @param testText  maps to test_text
	 * @param testTimestamp  maps to test_timestamp
	 * @param testTinyint  maps to test_tinyint
	 * @param testTinytext  maps to test_tinytext
	 * @param testVarchar  maps to test_varchar
	 * @param testYear  maps to test_year
	 * 
	 * @return the number of rows that were inserted, or -1 if an error occurred
	 * 
	 * @throws SQLException if there was an error in the SQL insert statement
	 */
	public static int insert(Connection connection, Long idAllTypes, Long testBigint, Blob testBlob, Boolean testBool, String testChar, Boolean testBoolean, String testBinary, String testVarbinary, Date testDate, Timestamp testDatetime, BigDecimal testDec, BigDecimal testDecimal, Double testDouble, Float testFloat, Integer testInt, Integer testInteger, String testLongtext, Blob testMediumblob, Integer testMediumint, String testMediumtext, BigDecimal testNumeric, Short testSmallint, Time testTime, String testText, Timestamp testTimestamp, Boolean testTinyint, String testTinytext, String testVarchar, Integer testYear) throws SQLException {
		try (PreparedStatement preparedStatement = connection.prepareStatement(SQL_BUILTIN_INSERT_VALUES)) {
			ConnectionManager.setBigint(preparedStatement, 1, idAllTypes);
			ConnectionManager.setBigint(preparedStatement, 2, testBigint);
			ConnectionManager.setBlob(preparedStatement, 3, testBlob);
			ConnectionManager.setBool(preparedStatement, 4, testBool);
			ConnectionManager.setChar(preparedStatement, 5, testChar);
			ConnectionManager.setBoolean(preparedStatement, 6, testBoolean);
			ConnectionManager.setBinary(preparedStatement, 7, testBinary);
			ConnectionManager.setVarbinary(preparedStatement, 8, testVarbinary);
			ConnectionManager.setDate(preparedStatement, 9, testDate);
			ConnectionManager.setDatetime(preparedStatement, 10, testDatetime);
			ConnectionManager.setDec(preparedStatement, 11, testDec);
			ConnectionManager.setDecimal(preparedStatement, 12, testDecimal);
			ConnectionManager.setDouble(preparedStatement, 13, testDouble);
			ConnectionManager.setFloat(preparedStatement, 14, testFloat);
			ConnectionManager.setInt(preparedStatement, 15, testInt);
			ConnectionManager.setInteger(preparedStatement, 16, testInteger);
			ConnectionManager.setLongtext(preparedStatement, 17, testLongtext);
			ConnectionManager.setMediumblob(preparedStatement, 18, testMediumblob);
			ConnectionManager.setMediumint(preparedStatement, 19, testMediumint);
			ConnectionManager.setMediumtext(preparedStatement, 20, testMediumtext);
			ConnectionManager.setNumeric(preparedStatement, 21, testNumeric);
			ConnectionManager.setSmallint(preparedStatement, 22, testSmallint);
			ConnectionManager.setTime(preparedStatement, 23, testTime);
			ConnectionManager.setText(preparedStatement, 24, testText);
			ConnectionManager.setTimestamp(preparedStatement, 25, testTimestamp);
			ConnectionManager.setTinyint(preparedStatement, 26, testTinyint);
			ConnectionManager.setTinytext(preparedStatement, 27, testTinytext);
			ConnectionManager.setVarchar(preparedStatement, 28, testVarchar);
			ConnectionManager.setYear(preparedStatement, 29, testYear);
			return(preparedStatement.executeUpdate());
		}
	}

	/**
	 * Insert a new AllTypes into the database utilising the passed in connection 
	 * with only the fields that are allowed to be not null.
	 * 
	 * @param connection the connection to use for the database, this __MUST__ be 
	 *   closed by the calling function.
	 * @param idAllTypes  maps to id_all_types
	 * 
	 * @return the number of rows that were inserted, or -1 if an error occurred
	 * 
	 * @throws SQLException if there was an error in the SQL insert statement
	 */
	public static int insert(Connection connection, Long idAllTypes) throws SQLException {
		try (PreparedStatement preparedStatement = connection.prepareStatement(SQL_BUILTIN_INSERT_VALUES)) {
			ConnectionManager.setBigint(preparedStatement, 1, idAllTypes);
			ConnectionManager.setBigint(preparedStatement, 2, null);
			Blob testBlobBlob = null;
			ConnectionManager.setBlob(preparedStatement, 3, testBlobBlob);
			ConnectionManager.setBool(preparedStatement, 4, null);
			ConnectionManager.setChar(preparedStatement, 5, null);
			ConnectionManager.setBoolean(preparedStatement, 6, null);
			String testBinaryString = null;
			ConnectionManager.setBinary(preparedStatement, 7, testBinaryString);
			String testVarbinaryString = null;
			ConnectionManager.setVarbinary(preparedStatement, 8, testVarbinaryString);
			ConnectionManager.setDate(preparedStatement, 9, null);
			ConnectionManager.setDatetime(preparedStatement, 10, null);
			ConnectionManager.setDec(preparedStatement, 11, null);
			ConnectionManager.setDecimal(preparedStatement, 12, null);
			ConnectionManager.setDouble(preparedStatement, 13, null);
			ConnectionManager.setFloat(preparedStatement, 14, null);
			ConnectionManager.setInt(preparedStatement, 15, null);
			ConnectionManager.setInteger(preparedStatement, 16, null);
			String testLongtextString = null;
			ConnectionManager.setLongtext(preparedStatement, 17, testLongtextString);
			Blob testMediumblobBlob = null;
			ConnectionManager.setMediumblob(preparedStatement, 18, testMediumblobBlob);
			ConnectionManager.setMediumint(preparedStatement, 19, null);
			String testMediumtextString = null;
			ConnectionManager.setMediumtext(preparedStatement, 20, testMediumtextString);
			ConnectionManager.setNumeric(preparedStatement, 21, null);
			ConnectionManager.setSmallint(preparedStatement, 22, null);
			ConnectionManager.setTime(preparedStatement, 23, null);
			String testTextString = null;
			ConnectionManager.setText(preparedStatement, 24, testTextString);
			ConnectionManager.setTimestamp(preparedStatement, 25, null);
			ConnectionManager.setTinyint(preparedStatement, 26, null);
			String testTinytextString = null;
			ConnectionManager.setTinytext(preparedStatement, 27, testTinytextString);
			ConnectionManager.setVarchar(preparedStatement, 28, null);
			ConnectionManager.setYear(preparedStatement, 29, null);
			return(preparedStatement.executeUpdate());
		}
	}

	/**
	 * Insert a new AllTypes into the database a new connection will be retrieved 
	 * from the pool, used and then closed.
	 * 
	 * @param idAllTypes  maps to id_all_types
	 * @param testBigint  maps to test_bigint
	 * @param testBlob  maps to test_blob
	 * @param testBool  maps to test_bool
	 * @param testChar  maps to test_char
	 * @param testBoolean  maps to test_boolean
	 * @param testBinary  maps to test_binary
	 * @param testVarbinary  maps to test_varbinary
	 * @param testDate  maps to test_date
	 * @param testDatetime  maps to test_datetime
	 * @param testDec  maps to test_dec
	 * @param testDecimal  maps to test_decimal
	 * @param testDouble  maps to test_double
	 * @param testFloat  maps to test_float
	 * @param testInt  maps to test_int
	 * @param testInteger  maps to test_integer
	 * @param testLongtext  maps to test_longtext
	 * @param testMediumblob  maps to test_mediumblob
	 * @param testMediumint  maps to test_mediumint
	 * @param testMediumtext  maps to test_mediumtext
	 * @param testNumeric  maps to test_numeric
	 * @param testSmallint  maps to test_smallint
	 * @param testTime  maps to test_time
	 * @param testText  maps to test_text
	 * @param testTimestamp  maps to test_timestamp
	 * @param testTinyint  maps to test_tinyint
	 * @param testTinytext  maps to test_tinytext
	 * @param testVarchar  maps to test_varchar
	 * @param testYear  maps to test_year
	 * 
	 * @return the number of rows that were inserted, or -1 if an error occurred
	 * 
	 * @throws SQLException if there was an error in the SQL insert statement
	 */
	public static int insert(Long idAllTypes, Long testBigint, Blob testBlob, Boolean testBool, String testChar, Boolean testBoolean, String testBinary, String testVarbinary, Date testDate, Timestamp testDatetime, BigDecimal testDec, BigDecimal testDecimal, Double testDouble, Float testFloat, Integer testInt, Integer testInteger, String testLongtext, Blob testMediumblob, Integer testMediumint, String testMediumtext, BigDecimal testNumeric, Short testSmallint, Time testTime, String testText, Timestamp testTimestamp, Boolean testTinyint, String testTinytext, String testVarchar, Integer testYear) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(insert(connection, idAllTypes, testBigint, testBlob, testBool, testChar, testBoolean, testBinary, testVarbinary, testDate, testDatetime, testDec, testDecimal, testDouble, testFloat, testInt, testInteger, testLongtext, testMediumblob, testMediumint, testMediumtext, testNumeric, testSmallint, testTime, testText, testTimestamp, testTinyint, testTinytext, testVarchar, testYear));
		}
	}

	/**
	 * Insert a new AllTypes into the database a new connection will be retrieved 
	 * from the pool, used and then closed. This is for fields which have a nullable allowed default
	 * 
	 * @param idAllTypes  maps to id_all_types
	 * 
	 * @return the number of rows that were inserted, or -1 if an error occurred
	 * 
	 * @throws SQLException if there was an error in the SQL insert statement
	 */
	public static int insert(Long idAllTypes) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(insert(connection, idAllTypes));
		}
	}

	/**
	 * Silently (i.e. swallow any exceptions) Insert a new AllTypes into the 
	 * database utilising the passed in connection. If an exception is thrown by the
	 * method, the exception message will be logged as an 'error', if 'trace' logging
	 * is enabled, the stack trace will be printed to the output stream.
	 * 
	 * @param connection the connection to use for the database, this __MUST__ be 
	 *   closed by the calling function.
	 * @param idAllTypes  maps to id_all_types
	 * @param testBigint  maps to test_bigint
	 * @param testBlob  maps to test_blob
	 * @param testBool  maps to test_bool
	 * @param testChar  maps to test_char
	 * @param testBoolean  maps to test_boolean
	 * @param testBinary  maps to test_binary
	 * @param testVarbinary  maps to test_varbinary
	 * @param testDate  maps to test_date
	 * @param testDatetime  maps to test_datetime
	 * @param testDec  maps to test_dec
	 * @param testDecimal  maps to test_decimal
	 * @param testDouble  maps to test_double
	 * @param testFloat  maps to test_float
	 * @param testInt  maps to test_int
	 * @param testInteger  maps to test_integer
	 * @param testLongtext  maps to test_longtext
	 * @param testMediumblob  maps to test_mediumblob
	 * @param testMediumint  maps to test_mediumint
	 * @param testMediumtext  maps to test_mediumtext
	 * @param testNumeric  maps to test_numeric
	 * @param testSmallint  maps to test_smallint
	 * @param testTime  maps to test_time
	 * @param testText  maps to test_text
	 * @param testTimestamp  maps to test_timestamp
	 * @param testTinyint  maps to test_tinyint
	 * @param testTinytext  maps to test_tinytext
	 * @param testVarchar  maps to test_varchar
	 * @param testYear  maps to test_year
	 * 
	 * @return the number of rows that were inserted, or -1 if an error occurred
	 */
	public static int insertSilent(Connection connection, Long idAllTypes, Long testBigint, Blob testBlob, Boolean testBool, String testChar, Boolean testBoolean, String testBinary, String testVarbinary, Date testDate, Timestamp testDatetime, BigDecimal testDec, BigDecimal testDecimal, Double testDouble, Float testFloat, Integer testInt, Integer testInteger, String testLongtext, Blob testMediumblob, Integer testMediumint, String testMediumtext, BigDecimal testNumeric, Short testSmallint, Time testTime, String testText, Timestamp testTimestamp, Boolean testTinyint, String testTinytext, String testVarchar, Integer testYear) {
		try {
			return(insert(connection, idAllTypes, testBigint, testBlob, testBool, testChar, testBoolean, testBinary, testVarbinary, testDate, testDatetime, testDec, testDecimal, testDouble, testFloat, testInt, testInteger, testLongtext, testMediumblob, testMediumint, testMediumtext, testNumeric, testSmallint, testTime, testText, testTimestamp, testTinyint, testTinytext, testVarchar, testYear));
		} catch (SQLException sqlex) {
			LOGGER.error("SQLException caught, message was: {}", sqlex.getMessage());
			if(LOGGER.isTraceEnabled()){
				sqlex.printStackTrace();
			}
			return(-1);
		}
	}

	/**
	 * Silently (i.e. swallow any exceptions) Insert a new AllTypes into the 
	 * database utilising the passed in connection. If an exception is thrown by the
	 * method, the exception message will be logged as an 'error', if 'trace' logging
	 * is enabled, the stack trace will be printed to the output stream.
	 * 
	 * This is only for Non-Nullable fields
	 * 
	 * @param connection the connection to use for the database, this __MUST__ be 
	 *   closed by the calling function.
	 * @param idAllTypes  maps to id_all_types
	 * 
	 * @return the number of rows that were inserted, or -1 if an error occurred
	 */
	public static int insertSilent(Connection connection, Long idAllTypes) {
		try {
			return(insert(connection, idAllTypes));
		} catch (SQLException sqlex) {
			LOGGER.error("SQLException caught, message was: {}", sqlex.getMessage());
			if(LOGGER.isTraceEnabled()){
				sqlex.printStackTrace();
			}
			return(-1);
		}
	}

	/**
	 * Silently (i.e. swallow any exceptions) Insert a new AllTypes into the 
	 * database, creating and closing a connection in the process. If an exception is thrown 
	 * by the method, the exception message will be logged as an 'error', if 'trace' logging
	 * is enabled, the stack trace will be printed to the output stream.
	 * 
	 * @param idAllTypes  maps to id_all_types
	 * @param testBigint  maps to test_bigint
	 * @param testBlob  maps to test_blob
	 * @param testBool  maps to test_bool
	 * @param testChar  maps to test_char
	 * @param testBoolean  maps to test_boolean
	 * @param testBinary  maps to test_binary
	 * @param testVarbinary  maps to test_varbinary
	 * @param testDate  maps to test_date
	 * @param testDatetime  maps to test_datetime
	 * @param testDec  maps to test_dec
	 * @param testDecimal  maps to test_decimal
	 * @param testDouble  maps to test_double
	 * @param testFloat  maps to test_float
	 * @param testInt  maps to test_int
	 * @param testInteger  maps to test_integer
	 * @param testLongtext  maps to test_longtext
	 * @param testMediumblob  maps to test_mediumblob
	 * @param testMediumint  maps to test_mediumint
	 * @param testMediumtext  maps to test_mediumtext
	 * @param testNumeric  maps to test_numeric
	 * @param testSmallint  maps to test_smallint
	 * @param testTime  maps to test_time
	 * @param testText  maps to test_text
	 * @param testTimestamp  maps to test_timestamp
	 * @param testTinyint  maps to test_tinyint
	 * @param testTinytext  maps to test_tinytext
	 * @param testVarchar  maps to test_varchar
	 * @param testYear  maps to test_year
	 * 
	 * @return the number of rows that were inserted, or -1 if an error occurred
	 */
	public static int insertSilent(Long idAllTypes, Long testBigint, Blob testBlob, Boolean testBool, String testChar, Boolean testBoolean, String testBinary, String testVarbinary, Date testDate, Timestamp testDatetime, BigDecimal testDec, BigDecimal testDecimal, Double testDouble, Float testFloat, Integer testInt, Integer testInteger, String testLongtext, Blob testMediumblob, Integer testMediumint, String testMediumtext, BigDecimal testNumeric, Short testSmallint, Time testTime, String testText, Timestamp testTimestamp, Boolean testTinyint, String testTinytext, String testVarchar, Integer testYear) {
		try (Connection connection = ConnectionManager.getConnection()){
			return(insert(connection, idAllTypes, testBigint, testBlob, testBool, testChar, testBoolean, testBinary, testVarbinary, testDate, testDatetime, testDec, testDecimal, testDouble, testFloat, testInt, testInteger, testLongtext, testMediumblob, testMediumint, testMediumtext, testNumeric, testSmallint, testTime, testText, testTimestamp, testTinyint, testTinytext, testVarchar, testYear));
		} catch (SQLException sqlex) {
			LOGGER.error("SQLException caught, message was: {}", sqlex.getMessage());
			if(LOGGER.isTraceEnabled()){
				sqlex.printStackTrace();
			}
			return(-1);
		}
	}

	/**
	 * Silently (i.e. swallow any exceptions) Insert a new AllTypes into the 
	 * database, creating and closing a connection in the process. If an exception is thrown 
	 * by the method, the exception message will be logged as an 'error', if 'trace' logging
	 * is enabled, the stack trace will be printed to the output stream.
	 * 
	 * This is for non-nullable fields only
	 * 
	 * @param idAllTypes  maps to id_all_types
	 * 
	 * @return the number of rows that were inserted, or -1 if an error occurred
	 */
	public static int insertSilent(Long idAllTypes) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(insert(connection, idAllTypes));
		} catch (SQLException sqlex) {
			LOGGER.error("SQLException caught, message was: {}", sqlex.getMessage());
			if(LOGGER.isTraceEnabled()){
				sqlex.printStackTrace();
			}
			return(-1);
		}
	}

	public static int insert(Connection connection, Long idAllTypes, Long testBigint, InputStream testBlob, Boolean testBool, String testChar, Boolean testBoolean, InputStream testBinary, InputStream testVarbinary, Date testDate, Timestamp testDatetime, BigDecimal testDec, BigDecimal testDecimal, Double testDouble, Float testFloat, Integer testInt, Integer testInteger, InputStream testLongtext, InputStream testMediumblob, Integer testMediumint, InputStream testMediumtext, BigDecimal testNumeric, Short testSmallint, Time testTime, InputStream testText, Timestamp testTimestamp, Boolean testTinyint, InputStream testTinytext, String testVarchar, Integer testYear) throws SQLException {
		int numResults = -1;
		PreparedStatement preparedStatement = null;
		try {
			preparedStatement = connection.prepareStatement(SQL_BUILTIN_INSERT_VALUES);
			ConnectionManager.setBigint(preparedStatement, 1, idAllTypes);
			ConnectionManager.setBigint(preparedStatement, 2, testBigint);
			ConnectionManager.setBlobInputStream(preparedStatement, 3, testBlob);
			ConnectionManager.setBool(preparedStatement, 4, testBool);
			ConnectionManager.setChar(preparedStatement, 5, testChar);
			ConnectionManager.setBoolean(preparedStatement, 6, testBoolean);
			ConnectionManager.setBinaryInputStream(preparedStatement, 7, testBinary);
			ConnectionManager.setVarbinaryInputStream(preparedStatement, 8, testVarbinary);
			ConnectionManager.setDate(preparedStatement, 9, testDate);
			ConnectionManager.setDatetime(preparedStatement, 10, testDatetime);
			ConnectionManager.setDec(preparedStatement, 11, testDec);
			ConnectionManager.setDecimal(preparedStatement, 12, testDecimal);
			ConnectionManager.setDouble(preparedStatement, 13, testDouble);
			ConnectionManager.setFloat(preparedStatement, 14, testFloat);
			ConnectionManager.setInt(preparedStatement, 15, testInt);
			ConnectionManager.setInteger(preparedStatement, 16, testInteger);
			ConnectionManager.setLongtextInputStream(preparedStatement, 17, testLongtext);
			ConnectionManager.setMediumblobInputStream(preparedStatement, 18, testMediumblob);
			ConnectionManager.setMediumint(preparedStatement, 19, testMediumint);
			ConnectionManager.setMediumtextInputStream(preparedStatement, 20, testMediumtext);
			ConnectionManager.setNumeric(preparedStatement, 21, testNumeric);
			ConnectionManager.setSmallint(preparedStatement, 22, testSmallint);
			ConnectionManager.setTime(preparedStatement, 23, testTime);
			ConnectionManager.setTextInputStream(preparedStatement, 24, testText);
			ConnectionManager.setTimestamp(preparedStatement, 25, testTimestamp);
			ConnectionManager.setTinyint(preparedStatement, 26, testTinyint);
			ConnectionManager.setTinytextInputStream(preparedStatement, 27, testTinytext);
			ConnectionManager.setVarchar(preparedStatement, 28, testVarchar);
			ConnectionManager.setYear(preparedStatement, 29, testYear);
			numResults = preparedStatement.executeUpdate();
		} catch (SQLException sqlex) {
			throw sqlex;
		} finally {
			ConnectionManager.closeAll(preparedStatement);
		}
		return(numResults);
	}

	public static int insert(Long idAllTypes, Long testBigint, InputStream testBlob, Boolean testBool, String testChar, Boolean testBoolean, InputStream testBinary, InputStream testVarbinary, Date testDate, Timestamp testDatetime, BigDecimal testDec, BigDecimal testDecimal, Double testDouble, Float testFloat, Integer testInt, Integer testInteger, InputStream testLongtext, InputStream testMediumblob, Integer testMediumint, InputStream testMediumtext, BigDecimal testNumeric, Short testSmallint, Time testTime, InputStream testText, Timestamp testTimestamp, Boolean testTinyint, InputStream testTinytext, String testVarchar, Integer testYear) throws SQLException {
		int numResults = -1;
		Connection connection = null;
		try {
			connection = ConnectionManager.getConnection();
			numResults = insert(connection, idAllTypes, testBigint, testBlob, testBool, testChar, testBoolean, testBinary, testVarbinary, testDate, testDatetime, testDec, testDecimal, testDouble, testFloat, testInt, testInteger, testLongtext, testMediumblob, testMediumint, testMediumtext, testNumeric, testSmallint, testTime, testText, testTimestamp, testTinyint, testTinytext, testVarchar, testYear);
		} catch (SQLException sqlex) {
			throw sqlex;
		} finally {
			ConnectionManager.closeAll(connection);
		}
		return(numResults);
	}

	public static int insertSilent(Connection connection, Long idAllTypes, Long testBigint, InputStream testBlob, Boolean testBool, String testChar, Boolean testBoolean, InputStream testBinary, InputStream testVarbinary, Date testDate, Timestamp testDatetime, BigDecimal testDec, BigDecimal testDecimal, Double testDouble, Float testFloat, Integer testInt, Integer testInteger, InputStream testLongtext, InputStream testMediumblob, Integer testMediumint, InputStream testMediumtext, BigDecimal testNumeric, Short testSmallint, Time testTime, InputStream testText, Timestamp testTimestamp, Boolean testTinyint, InputStream testTinytext, String testVarchar, Integer testYear) {
		int numResults = -1;
		try {
			numResults = insert(connection, idAllTypes, testBigint, testBlob, testBool, testChar, testBoolean, testBinary, testVarbinary, testDate, testDatetime, testDec, testDecimal, testDouble, testFloat, testInt, testInteger, testLongtext, testMediumblob, testMediumint, testMediumtext, testNumeric, testSmallint, testTime, testText, testTimestamp, testTinyint, testTinytext, testVarchar, testYear);
		} catch (SQLException sqlex) {
			LOGGER.error("SQLException caught, message was: {}", sqlex.getMessage());
			if(LOGGER.isTraceEnabled()){
				sqlex.printStackTrace();
			}
		}
		return(numResults);
	}

	public static int insertSilent(Long idAllTypes, Long testBigint, InputStream testBlob, Boolean testBool, String testChar, Boolean testBoolean, InputStream testBinary, InputStream testVarbinary, Date testDate, Timestamp testDatetime, BigDecimal testDec, BigDecimal testDecimal, Double testDouble, Float testFloat, Integer testInt, Integer testInteger, InputStream testLongtext, InputStream testMediumblob, Integer testMediumint, InputStream testMediumtext, BigDecimal testNumeric, Short testSmallint, Time testTime, InputStream testText, Timestamp testTimestamp, Boolean testTinyint, InputStream testTinytext, String testVarchar, Integer testYear) {
		int numResults = 0;
		Connection connection = null;
		try {
			connection = ConnectionManager.getConnection();
			numResults = insert(connection, idAllTypes, testBigint, testBlob, testBool, testChar, testBoolean, testBinary, testVarbinary, testDate, testDatetime, testDec, testDecimal, testDouble, testFloat, testInt, testInteger, testLongtext, testMediumblob, testMediumint, testMediumtext, testNumeric, testSmallint, testTime, testText, testTimestamp, testTinyint, testTinytext, testVarchar, testYear);
		} catch (SQLException sqlex) {
			LOGGER.error("SQLException caught, message was: {}", sqlex.getMessage());
			if(LOGGER.isTraceEnabled()){
				sqlex.printStackTrace();
			}
		} finally {
			ConnectionManager.closeAll(connection);
		}
		return(numResults);
	}

}