package com.synapticloop.sample.h2zero.sqlite3.impex;

// - - - - thoughtfully generated by synapticloop h2zero - - - - 
//    with the use of synapticloop templar templating language
//                 (/impex/impex-importer.templar)

import com.synapticloop.h2zero.exception.H2ZeroParseException;
import com.synapticloop.h2zero.base.manager.sqlite3.ConnectionManager;
import com.synapticloop.sample.h2zero.sqlite3.model.Author;
import com.synapticloop.sample.h2zero.sqlite3.finder.AuthorStatusFinder;
import com.synapticloop.sample.h2zero.sqlite3.model.AuthorStatus;

import java.math.*;
import java.sql.*;
import java.util.HashMap;
import java.util.Map;

public class AuthorImporter {
	// The primary key cache is keyed on the id from the imported line -> value 
	// is the actual inserted value - which may be the same 
	public static final Map<Long, Long> PRIMARY_KEY_CACHE = new HashMap<>();

	// unique field txtIdAuthor
	private static final String SQL_SELECT_START_txtIdAuthor ="select id_author, id_author_status, txt_id_author, nm_author, nm_username, txt_bio, txt_url_cache_image, num_following, num_followers, dtm_started_following, fl_is_updating, fl_author_is_following_user, fl_author_is_followed_by_user from author where txt_id_author = ?";

	private static final String SQL_SELECT_UNIQUE = "";
	public static void importLine(String line) throws H2ZeroParseException {
		String[] splits = line.split("\t");
		if(splits.length != 13) {
			// we don't have enough tokens to import - we always import every field
			throw new H2ZeroParseException(String.format("Insufficient fields, found '%d', required '%d'",13 , splits.length));
		}

		// we are good to go
		// for each field - we parse the value
		Long idAuthor = ImpexConverter.convertLong(splits[0], false);
		Long idAuthorStatus = ImpexConverter.convertLong(splits[1], true);
		String txtIdAuthor = ImpexConverter.convertString(splits[2], false);
		String nmAuthor = ImpexConverter.convertString(splits[3], false);
		String nmUsername = ImpexConverter.convertString(splits[4], false);
		String txtBio = ImpexConverter.convertString(splits[5], false);
		String txtUrlCacheImage = ImpexConverter.convertString(splits[6], false);
		Long numFollowing = ImpexConverter.convertLong(splits[7], true);
		Long numFollowers = ImpexConverter.convertLong(splits[8], true);
		Timestamp dtmStartedFollowing = ImpexConverter.convertTimestamp(splits[9], true);
		Boolean flIsUpdating = ImpexConverter.convertBoolean(splits[10], true);
		Boolean flAuthorIsFollowingUser = ImpexConverter.convertBoolean(splits[11], true);
		Boolean flAuthorIsFollowedByUser = ImpexConverter.convertBoolean(splits[12], true);

		if(confirmExisting(idAuthor, idAuthorStatus, txtIdAuthor, nmAuthor, nmUsername, txtBio, txtUrlCacheImage, numFollowing, numFollowers, dtmStartedFollowing, flIsUpdating, flAuthorIsFollowingUser, flAuthorIsFollowedByUser)) {
			return;
		}
// txt_id_author
	}


	// IMPORT 'find-existing.templar' START

	/**
	 * Confirm whether there is an existing table with all of the fields matching 
	 * (apart from the primary key)
	 * 
	 * @param idAuthor The id_author which is used as the lookup
	 * @param idAuthorStatus The id_author_status which is used as the lookup
	 * @param txtIdAuthor The txt_id_author which is used as the lookup
	 * @param nmAuthor The nm_author which is used as the lookup
	 * @param nmUsername The nm_username which is used as the lookup
	 * @param txtBio The txt_bio which is used as the lookup
	 * @param txtUrlCacheImage The txt_url_cache_image which is used as the lookup
	 * @param numFollowing The num_following which is used as the lookup
	 * @param numFollowers The num_followers which is used as the lookup
	 * @param dtmStartedFollowing The dtm_started_following which is used as the lookup
	 * @param flIsUpdating The fl_is_updating which is used as the lookup
	 * @param flAuthorIsFollowingUser The fl_author_is_following_user which is used as the lookup
	 * @param flAuthorIsFollowedByUser The fl_author_is_followed_by_user which is used as the lookup
	 * 
	 * @return whether we were able to find the exact duplicat of this table row
	 * 
	 * @throws H2ZeroParseException - if there was a SQLException, or this is a 
	 * constant table and we couldn't look up the constant value
	 */
	private static boolean confirmExisting(Long idAuthor, Long idAuthorStatus, String txtIdAuthor, String nmAuthor, String nmUsername, String txtBio, String txtUrlCacheImage, Long numFollowing, Long numFollowers, Timestamp dtmStartedFollowing, Boolean flIsUpdating, Boolean flAuthorIsFollowingUser, Boolean flAuthorIsFollowedByUser) throws H2ZeroParseException {
		StringBuilder SQL_FIND_EXACT = new StringBuilder("select * from author where ");
		if (null == idAuthorStatus) {
			SQL_FIND_EXACT.append(" id_author_status is null");
		} else {
			SQL_FIND_EXACT.append(" id_author_status = ?");
		}
		SQL_FIND_EXACT.append(" and ");
		if (null == txtIdAuthor) {
			SQL_FIND_EXACT.append(" txt_id_author is null");
		} else {
			SQL_FIND_EXACT.append(" txt_id_author = ?");
		}
		SQL_FIND_EXACT.append(" and ");
		if (null == nmAuthor) {
			SQL_FIND_EXACT.append(" nm_author is null");
		} else {
			SQL_FIND_EXACT.append(" nm_author = ?");
		}
		SQL_FIND_EXACT.append(" and ");
		if (null == nmUsername) {
			SQL_FIND_EXACT.append(" nm_username is null");
		} else {
			SQL_FIND_EXACT.append(" nm_username = ?");
		}
		SQL_FIND_EXACT.append(" and ");
		if (null == txtBio) {
			SQL_FIND_EXACT.append(" txt_bio is null");
		} else {
			SQL_FIND_EXACT.append(" txt_bio = ?");
		}
		SQL_FIND_EXACT.append(" and ");
		if (null == txtUrlCacheImage) {
			SQL_FIND_EXACT.append(" txt_url_cache_image is null");
		} else {
			SQL_FIND_EXACT.append(" txt_url_cache_image = ?");
		}
		SQL_FIND_EXACT.append(" and ");
		if (null == numFollowing) {
			SQL_FIND_EXACT.append(" num_following is null");
		} else {
			SQL_FIND_EXACT.append(" num_following = ?");
		}
		SQL_FIND_EXACT.append(" and ");
		if (null == numFollowers) {
			SQL_FIND_EXACT.append(" num_followers is null");
		} else {
			SQL_FIND_EXACT.append(" num_followers = ?");
		}
		SQL_FIND_EXACT.append(" and ");
		if (null == dtmStartedFollowing) {
			SQL_FIND_EXACT.append(" dtm_started_following is null");
		} else {
			SQL_FIND_EXACT.append(" dtm_started_following = ?");
		}
		SQL_FIND_EXACT.append(" and ");
		if (null == flIsUpdating) {
			SQL_FIND_EXACT.append(" fl_is_updating is null");
		} else {
			SQL_FIND_EXACT.append(" fl_is_updating = ?");
		}
		SQL_FIND_EXACT.append(" and ");
		if (null == flAuthorIsFollowingUser) {
			SQL_FIND_EXACT.append(" fl_author_is_following_user is null");
		} else {
			SQL_FIND_EXACT.append(" fl_author_is_following_user = ?");
		}
		SQL_FIND_EXACT.append(" and ");
		if (null == flAuthorIsFollowedByUser) {
			SQL_FIND_EXACT.append(" fl_author_is_followed_by_user is null");
		} else {
			SQL_FIND_EXACT.append(" fl_author_is_followed_by_user = ?");
		}
		ResultSet resultSetExact = null;
		// now set all of the parameters
		try (Connection connection = ConnectionManager.getConnection();
				 PreparedStatement preparedStatement = connection.prepareStatement(SQL_FIND_EXACT.toString())) {
			resultSetExact = preparedStatement.getResultSet();
			if(resultSetExact.next()) {
				// we have found one, this means that we do not need to import it
				// just update the primary key cache
				PRIMARY_KEY_CACHE.put(idAuthorStatus, resultSetExact.getLong(1));
				return(true);
			} else {
				// fall through and see if we can find it by some other means...
			}
		} catch (SQLException e) {
			throw new H2ZeroParseException(String.format("Could not execute the SQL statement.  Exception, message was: '%s'", e.getMessage()), e);
		} finally {
			if(null != resultSetExact) {
				try { resultSetExact.close(); } catch (SQLException e) { /* do nothing */ }
			}
		}

		return(false);
	}
	// IMPORT 'find-existing.templar' END





		// IMPORT 'find-unique.templar' START

	public static void findUniqueTxtIdAuthor(Long idAuthor, Long idAuthorStatus, String txtIdAuthor, String nmAuthor, String nmUsername, String txtBio, String txtUrlCacheImage, Long numFollowing, Long numFollowers, Timestamp dtmStartedFollowing, Boolean flIsUpdating, Boolean flAuthorIsFollowingUser, Boolean flAuthorIsFollowedByUser) throws H2ZeroParseException {
		 // unique field flAuthorIsFollowedByUser
		Author author;
		ResultSet resultSet;
		try (Connection connection = ConnectionManager.getConnection();
				 PreparedStatement preparedStatement = connection.prepareStatement(SQL_SELECT_START_txtIdAuthor)) {
			ConnectionManager.setVarchar(preparedStatement, 1, txtIdAuthor);
			resultSet = preparedStatement.getResultSet();
			if(resultSet.next()) {
				// we have found one, load it up
				author = new Author(
					ConnectionManager.getNullableResultLong(resultSet, 1), 
					ConnectionManager.getNullableResultLong(resultSet, 2), 
					ConnectionManager.getNullableResultString(resultSet, 3), 
					ConnectionManager.getNullableResultString(resultSet, 4), 
					ConnectionManager.getNullableResultString(resultSet, 5), 
					ConnectionManager.getNullableResultString(resultSet, 6), 
					ConnectionManager.getNullableResultString(resultSet, 7), 
					ConnectionManager.getNullableResultLong(resultSet, 8), 
					ConnectionManager.getNullableResultLong(resultSet, 9), 
					ConnectionManager.getNullableResultTimestamp(resultSet, 10), 
					ConnectionManager.getNullableResultBoolean(resultSet, 11), 
					ConnectionManager.getNullableResultBoolean(resultSet, 12), 
					ConnectionManager.getNullableResultBoolean(resultSet, 13)
				);
				// now set all of the fields that we have
				PRIMARY_KEY_CACHE.put(idAuthor, author.getPrimaryKey());
			} else {
				author = new Author(null, idAuthorStatus, txtIdAuthor, nmAuthor, nmUsername, txtBio, txtUrlCacheImage, numFollowing, numFollowers, dtmStartedFollowing, flIsUpdating, flAuthorIsFollowingUser, flAuthorIsFollowedByUser);
				// id_author_status is a foreign key - look it up to make sure that it exists
				if(null != idAuthorStatus) {
					Long idAuthorStatusLookup = AuthorStatusImporter.PRIMARY_KEY_CACHE.get(idAuthorStatus);
					if(null == idAuthorStatusLookup) {
						// we don't have a lookup - which is OK
						idAuthorStatusLookup = idAuthorStatus;
					}
					AuthorStatus authorStatus = AuthorStatusFinder.findByPrimaryKeySilent(idAuthorStatusLookup);

					if(null == authorStatus) {
						throw new H2ZeroParseException(String.format("Could not find the foreignKey for author_status.id_author_status of '%d'", idAuthorStatusLookup));
					}

					author.setIdAuthorStatus(authorStatus.getPrimaryKey());
				}
				author.insertSilent();
			}
		} catch (SQLException e) {
			throw new RuntimeException(e);
		}
	}
// we have a unique field 

		// IMPORT 'find-unique.templar' END





	/**
	 * Clear the primary key cache, ready for data importing 
	 */
	public static void clearPrimaryKeyCache() {
		PRIMARY_KEY_CACHE.clear();
	}
}