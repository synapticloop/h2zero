package com.synapticloop.sample.h2zero.sqlite3.deleter;

// - - - - thoughtfully generated by synapticloop h2zero - - - - 
//    with the use of synapticloop templar templating language
//                (java-create-deleter.templar)

import java.sql.Connection;
import java.sql.Timestamp;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.*;
import java.math.BigDecimal;
import java.util.List;
import java.util.ArrayList;
import com.synapticloop.h2zero.util.LruCache;

import com.synapticloop.h2zero.base.manager.sqlite3.ConnectionManager;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


import com.synapticloop.sample.h2zero.sqlite3.model.util.Constants;

public class AllTypesDeleter {
	// the binder is unused in code, but will generate compile problems if this 
	// class is no longer referenced in the h2zero file. Just a nicety for
	// removing dead code
	@SuppressWarnings("unused")
	private static final String BINDER = Constants.ALL_TYPES_BINDER;

	private static final Logger LOGGER = LoggerFactory.getLogger(AllTypesDeleter.class);

	// static fields generated by synapticloop h2zero
	private static final String SQL_BUILTIN_DELETE_ALL = "delete from all_types";
	private static final String SQL_DELETE_START = "delete from all_types ";
	private static final String SQL_BUILTIN_DELETE_BY_PRIMARY_KEY = SQL_DELETE_START + "where id_all_types = ?";

	// static fields generated from the user input
	private static final String SQL_DELETE_BY_ID_ALL_TYPES = SQL_DELETE_START + " where id_all_types = ?";
	private static final String SQL_DELETE_BY_TEST_BIGINT = SQL_DELETE_START + " where test_bigint = ?";
	private static final String SQL_DELETE_BY_TEST_BOOLEAN = SQL_DELETE_START + " where test_boolean = ?";
	private static final String SQL_DELETE_BY_TEST_DATE = SQL_DELETE_START + " where test_date = ?";
	private static final String SQL_DELETE_BY_TEST_DATETIME = SQL_DELETE_START + " where test_datetime = ?";
	private static final String SQL_DELETE_BY_TEST_DOUBLE = SQL_DELETE_START + " where test_double = ?";
	private static final String SQL_DELETE_BY_TEST_FLOAT = SQL_DELETE_START + " where test_float = ?";
	private static final String SQL_DELETE_BY_TEST_INT = SQL_DELETE_START + " where test_int = ?";
	private static final String SQL_DELETE_BY_TEST_INTEGER = SQL_DELETE_START + " where test_integer = ?";
	private static final String SQL_DELETE_BY_TEST_MEDIUMINT = SQL_DELETE_START + " where test_mediumint = ?";
	private static final String SQL_DELETE_BY_TEST_NUMERIC = SQL_DELETE_START + " where test_numeric = ?";
	private static final String SQL_DELETE_BY_TEST_SMALLINT = SQL_DELETE_START + " where test_smallint = ?";
	private static final String SQL_DELETE_BY_TEST_TEXT = SQL_DELETE_START + " where test_text = ?";
	private static final String SQL_DELETE_BY_TEST_TINYINT = SQL_DELETE_START + " where test_tinyint = ?";
	private static final String SQL_DELETE_BY_TEST_VARCHAR = SQL_DELETE_START + " where test_varchar = ?";
	// now for the statement limit cache(s)
	private static final LruCache<String, String> deleteAll_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByIdAllTypes_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByTestBigint_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByTestBoolean_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByTestDate_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByTestDatetime_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByTestDouble_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByTestFloat_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByTestInt_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByTestInteger_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByTestMediumint_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByTestNumeric_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByTestSmallint_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByTestText_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByTestTinyint_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByTestVarchar_limit_statement_cache = new LruCache<>(1024);

	// We don't allow instantiation
	private AllTypesDeleter() {}

 	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 	 * 
 	 * The following deleters are built in by h2zero and are always generated 
 	 * 
 	 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

	/**
	 * Delete a row in the ALL_TYPES table by its primary key
	 * 
	 * @param connection The connection to use - the caller must close this connection
	 * @param idAllTypes the primary key to delete
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the delete
	 */
	public static int deleteByPrimaryKey(Connection connection, Long idAllTypes) throws SQLException {
		try (PreparedStatement preparedStatement = connection.prepareStatement(SQL_BUILTIN_DELETE_BY_PRIMARY_KEY)) {
			preparedStatement.setLong(1, idAllTypes);
			return(preparedStatement.executeUpdate());
		}
	}

	/**
	 * Delete a row in the ALL_TYPES table by its primary key
	 * 
	 * @param idAllTypes the primary key to delete
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the delete
	 */
	public static int deleteByPrimaryKey(Long idAllTypes) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByPrimaryKey(connection, idAllTypes));
		}
	}

	/**
	 * Delete a row in the ALL_TYPES table by its primary key silently
	 * (i.e. don't throw an exception if it couldn't be deleted).
	 * 
	 * @param connection - the connection to use - the caller must close this connection
	 * @param idAllTypes the primary key to delete
	 * 
	 * @return the number of rows deleted
	 */
	public static int deleteByPrimaryKeySilent(Connection connection, Long idAllTypes) {
		try {
			return(deleteByPrimaryKey(connection, idAllTypes));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByPrimaryKey, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	/**
	 * Delete a row in the ALL_TYPES table by its primary key silently
	 * (i.e. don't throw an exception if it coudn't be deleted).
	 * 
	 * @param idAllTypes the primary key to delete
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByPrimaryKeySilent(Long idAllTypes) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByPrimaryKeySilent(connection, idAllTypes));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByPrimaryKey, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	/**
	 * Delete all of the rows in the table 'all_types'.
	 * 
	 * This database does not have the 'truncate' keyword hence the 'DELETE FROM' SQL
	 * statement is used
	 * 
	 * @param connection - the connection to use - the caller must close this connection
	 * 
	 * @return The number of rows affected by this statement
	 */
	public static int deleteAll(Connection connection) throws SQLException {
		try (PreparedStatement preparedStatement = connection.prepareStatement(SQL_BUILTIN_DELETE_ALL)) {
			return(preparedStatement.executeUpdate());
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteAll, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	/**
	 * Delete all the rows in the ALL_TYPES table
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the delete
	 */
	public static int deleteAll() throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteAll(connection));
		}
	}

	/**
	 * Delete all the rows in the ALL_TYPES table silently - i.e
	 * swallow any SQL exceptions
	 * 
	 * @param connection - the connection to use - the caller must close this connection
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteAllSilent(Connection connection) {
		try {
			return(deleteAll(connection));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteAll, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	/**
	 * Delete all the rows in the ALL_TYPES table silently - i.e
	 * swallow any SQL exceptions
	 * 
	 * @return the number of rows deleted, or -1 if there was an error
	 */
	public static int deleteAllSilent() {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteAll(connection));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteAll, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * 
	 *     USER DEFINED DELETERS FOR THE TABLE: all_types
	 * 
	 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * 
	 * This is the start of the user defined Deleters which are generated
	 * through either the "deleters" JSON key, or the "fieldDeleters" JSON
	 * key.
	 * 
	 * There are 15 defined Deleters on the all_types table:
	 * 
	 * - deleteByIdAllTypes - 'fieldDeleters' JSON key 
	 * - deleteByTestBigint - 'fieldDeleters' JSON key 
	 * - deleteByTestBoolean - 'fieldDeleters' JSON key 
	 * - deleteByTestDate - 'fieldDeleters' JSON key 
	 * - deleteByTestDatetime - 'fieldDeleters' JSON key 
	 * - deleteByTestDouble - 'fieldDeleters' JSON key 
	 * - deleteByTestFloat - 'fieldDeleters' JSON key 
	 * - deleteByTestInt - 'fieldDeleters' JSON key 
	 * - deleteByTestInteger - 'fieldDeleters' JSON key 
	 * - deleteByTestMediumint - 'fieldDeleters' JSON key 
	 * - deleteByTestNumeric - 'fieldDeleters' JSON key 
	 * - deleteByTestSmallint - 'fieldDeleters' JSON key 
	 * - deleteByTestText - 'fieldDeleters' JSON key 
	 * - deleteByTestTinyint - 'fieldDeleters' JSON key 
	 * - deleteByTestVarchar - 'fieldDeleters' JSON key 
	 * 
	 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

	// USER DEFINED DELETER CONNECTION, PARAMS - NO LIMIT - SQLITE3 STATEMENT
	/**
	 * deleteByIdAllTypes - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param idAllTypes - maps to the id_all_types field (from the where clause)
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByIdAllTypes(Connection connection, Long idAllTypes) throws SQLException {
		String cacheKey = "cacheKey"  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByIdAllTypes_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_ID_ALL_TYPES);

			statement = stringBuilder.toString();
			deleteByIdAllTypes_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByIdAllTypes_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setBigint(preparedStatement, 1, idAllTypes);

			return(preparedStatement.executeUpdate());
		}
	}

  	// USER DEFINED DELETER CONNECTION, PARAMS SILENT
  	/**
  	 * deleteByIdAllTypes - from 'fieldDeleters' JSON key
  	 *
  	 * This is the main method for all other deleter methods with the same prefix,
  	 * including the (silent method signatures).  All methods chain to this one.
  	 * 
            	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param idAllTypes - maps to the id_all_types field (from the where clause)
  	 * 
  	 * @return the number of rows deleted
  	 */
  	public static int deleteByIdAllTypesSilent(Connection connection, Long idAllTypes) {
  		try {
  			return(deleteByIdAllTypes(connection,   idAllTypes    ));
  		} catch (SQLException ex) {
  			LOGGER.error("Could not deleteByIdAllTypes, a SQL Exception occurred.", ex);
  			return(-1);
  		}
  	}
  
	// USER DEFINED DELETER - NULL, PARAMS, NULL LOUD
	/**
	 * deleteByIdAllTypes - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param idAllTypes - maps to the id_all_types field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByIdAllTypes(Long idAllTypes) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByIdAllTypes(connection, idAllTypes));
		}
	}

	// USER DEFINED DELETER - NULL, PARAMS, NULL SILENT
	/**
	 * deleteByIdAllTypes - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param idAllTypes - maps to the id_all_types field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByIdAllTypesSilent(Long idAllTypes) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByIdAllTypes(connection, idAllTypes));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByIdAllTypes, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	// USER DEFINED DELETER CONNECTION, PARAMS - NO LIMIT - SQLITE3 STATEMENT
	/**
	 * deleteByTestBigint - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testBigint - maps to the test_bigint field (from the where clause)
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestBigint(Connection connection, Long testBigint) throws SQLException {
		String cacheKey = "cacheKey"  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByTestBigint_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_TEST_BIGINT);

			statement = stringBuilder.toString();
			deleteByTestBigint_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByTestBigint_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setBigint(preparedStatement, 1, testBigint);

			return(preparedStatement.executeUpdate());
		}
	}

  	// USER DEFINED DELETER CONNECTION, PARAMS SILENT
  	/**
  	 * deleteByTestBigint - from 'fieldDeleters' JSON key
  	 *
  	 * This is the main method for all other deleter methods with the same prefix,
  	 * including the (silent method signatures).  All methods chain to this one.
  	 * 
            	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testBigint - maps to the test_bigint field (from the where clause)
  	 * 
  	 * @return the number of rows deleted
  	 */
  	public static int deleteByTestBigintSilent(Connection connection, Long testBigint) {
  		try {
  			return(deleteByTestBigint(connection,   testBigint    ));
  		} catch (SQLException ex) {
  			LOGGER.error("Could not deleteByTestBigint, a SQL Exception occurred.", ex);
  			return(-1);
  		}
  	}
  
	// USER DEFINED DELETER - NULL, PARAMS, NULL LOUD
	/**
	 * deleteByTestBigint - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testBigint - maps to the test_bigint field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByTestBigint(Long testBigint) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestBigint(connection, testBigint));
		}
	}

	// USER DEFINED DELETER - NULL, PARAMS, NULL SILENT
	/**
	 * deleteByTestBigint - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testBigint - maps to the test_bigint field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByTestBigintSilent(Long testBigint) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestBigint(connection, testBigint));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestBigint, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	// USER DEFINED DELETER CONNECTION, PARAMS - NO LIMIT - SQLITE3 STATEMENT
	/**
	 * deleteByTestBoolean - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testBoolean - maps to the test_boolean field (from the where clause)
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestBoolean(Connection connection, Boolean testBoolean) throws SQLException {
		String cacheKey = "cacheKey"  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByTestBoolean_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_TEST_BOOLEAN);

			statement = stringBuilder.toString();
			deleteByTestBoolean_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByTestBoolean_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setBoolean(preparedStatement, 1, testBoolean);

			return(preparedStatement.executeUpdate());
		}
	}

  	// USER DEFINED DELETER CONNECTION, PARAMS SILENT
  	/**
  	 * deleteByTestBoolean - from 'fieldDeleters' JSON key
  	 *
  	 * This is the main method for all other deleter methods with the same prefix,
  	 * including the (silent method signatures).  All methods chain to this one.
  	 * 
            	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testBoolean - maps to the test_boolean field (from the where clause)
  	 * 
  	 * @return the number of rows deleted
  	 */
  	public static int deleteByTestBooleanSilent(Connection connection, Boolean testBoolean) {
  		try {
  			return(deleteByTestBoolean(connection,   testBoolean    ));
  		} catch (SQLException ex) {
  			LOGGER.error("Could not deleteByTestBoolean, a SQL Exception occurred.", ex);
  			return(-1);
  		}
  	}
  
	// USER DEFINED DELETER - NULL, PARAMS, NULL LOUD
	/**
	 * deleteByTestBoolean - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testBoolean - maps to the test_boolean field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByTestBoolean(Boolean testBoolean) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestBoolean(connection, testBoolean));
		}
	}

	// USER DEFINED DELETER - NULL, PARAMS, NULL SILENT
	/**
	 * deleteByTestBoolean - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testBoolean - maps to the test_boolean field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByTestBooleanSilent(Boolean testBoolean) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestBoolean(connection, testBoolean));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestBoolean, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	// USER DEFINED DELETER CONNECTION, PARAMS - NO LIMIT - SQLITE3 STATEMENT
	/**
	 * deleteByTestDate - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testDate - maps to the test_date field (from the where clause)
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestDate(Connection connection, Date testDate) throws SQLException {
		String cacheKey = "cacheKey"  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByTestDate_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_TEST_DATE);

			statement = stringBuilder.toString();
			deleteByTestDate_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByTestDate_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setDate(preparedStatement, 1, testDate);

			return(preparedStatement.executeUpdate());
		}
	}

  	// USER DEFINED DELETER CONNECTION, PARAMS SILENT
  	/**
  	 * deleteByTestDate - from 'fieldDeleters' JSON key
  	 *
  	 * This is the main method for all other deleter methods with the same prefix,
  	 * including the (silent method signatures).  All methods chain to this one.
  	 * 
            	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testDate - maps to the test_date field (from the where clause)
  	 * 
  	 * @return the number of rows deleted
  	 */
  	public static int deleteByTestDateSilent(Connection connection, Date testDate) {
  		try {
  			return(deleteByTestDate(connection,   testDate    ));
  		} catch (SQLException ex) {
  			LOGGER.error("Could not deleteByTestDate, a SQL Exception occurred.", ex);
  			return(-1);
  		}
  	}
  
	// USER DEFINED DELETER - NULL, PARAMS, NULL LOUD
	/**
	 * deleteByTestDate - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testDate - maps to the test_date field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByTestDate(Date testDate) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestDate(connection, testDate));
		}
	}

	// USER DEFINED DELETER - NULL, PARAMS, NULL SILENT
	/**
	 * deleteByTestDate - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testDate - maps to the test_date field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByTestDateSilent(Date testDate) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestDate(connection, testDate));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestDate, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	// USER DEFINED DELETER CONNECTION, PARAMS - NO LIMIT - SQLITE3 STATEMENT
	/**
	 * deleteByTestDatetime - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testDatetime - maps to the test_datetime field (from the where clause)
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestDatetime(Connection connection, Timestamp testDatetime) throws SQLException {
		String cacheKey = "cacheKey"  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByTestDatetime_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_TEST_DATETIME);

			statement = stringBuilder.toString();
			deleteByTestDatetime_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByTestDatetime_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setDatetime(preparedStatement, 1, testDatetime);

			return(preparedStatement.executeUpdate());
		}
	}

  	// USER DEFINED DELETER CONNECTION, PARAMS SILENT
  	/**
  	 * deleteByTestDatetime - from 'fieldDeleters' JSON key
  	 *
  	 * This is the main method for all other deleter methods with the same prefix,
  	 * including the (silent method signatures).  All methods chain to this one.
  	 * 
            	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testDatetime - maps to the test_datetime field (from the where clause)
  	 * 
  	 * @return the number of rows deleted
  	 */
  	public static int deleteByTestDatetimeSilent(Connection connection, Timestamp testDatetime) {
  		try {
  			return(deleteByTestDatetime(connection,   testDatetime    ));
  		} catch (SQLException ex) {
  			LOGGER.error("Could not deleteByTestDatetime, a SQL Exception occurred.", ex);
  			return(-1);
  		}
  	}
  
	// USER DEFINED DELETER - NULL, PARAMS, NULL LOUD
	/**
	 * deleteByTestDatetime - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testDatetime - maps to the test_datetime field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByTestDatetime(Timestamp testDatetime) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestDatetime(connection, testDatetime));
		}
	}

	// USER DEFINED DELETER - NULL, PARAMS, NULL SILENT
	/**
	 * deleteByTestDatetime - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testDatetime - maps to the test_datetime field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByTestDatetimeSilent(Timestamp testDatetime) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestDatetime(connection, testDatetime));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestDatetime, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	// USER DEFINED DELETER CONNECTION, PARAMS - NO LIMIT - SQLITE3 STATEMENT
	/**
	 * deleteByTestDouble - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testDouble - maps to the test_double field (from the where clause)
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestDouble(Connection connection, Double testDouble) throws SQLException {
		String cacheKey = "cacheKey"  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByTestDouble_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_TEST_DOUBLE);

			statement = stringBuilder.toString();
			deleteByTestDouble_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByTestDouble_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setDouble(preparedStatement, 1, testDouble);

			return(preparedStatement.executeUpdate());
		}
	}

  	// USER DEFINED DELETER CONNECTION, PARAMS SILENT
  	/**
  	 * deleteByTestDouble - from 'fieldDeleters' JSON key
  	 *
  	 * This is the main method for all other deleter methods with the same prefix,
  	 * including the (silent method signatures).  All methods chain to this one.
  	 * 
            	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testDouble - maps to the test_double field (from the where clause)
  	 * 
  	 * @return the number of rows deleted
  	 */
  	public static int deleteByTestDoubleSilent(Connection connection, Double testDouble) {
  		try {
  			return(deleteByTestDouble(connection,   testDouble    ));
  		} catch (SQLException ex) {
  			LOGGER.error("Could not deleteByTestDouble, a SQL Exception occurred.", ex);
  			return(-1);
  		}
  	}
  
	// USER DEFINED DELETER - NULL, PARAMS, NULL LOUD
	/**
	 * deleteByTestDouble - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testDouble - maps to the test_double field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByTestDouble(Double testDouble) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestDouble(connection, testDouble));
		}
	}

	// USER DEFINED DELETER - NULL, PARAMS, NULL SILENT
	/**
	 * deleteByTestDouble - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testDouble - maps to the test_double field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByTestDoubleSilent(Double testDouble) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestDouble(connection, testDouble));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestDouble, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	// USER DEFINED DELETER CONNECTION, PARAMS - NO LIMIT - SQLITE3 STATEMENT
	/**
	 * deleteByTestFloat - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testFloat - maps to the test_float field (from the where clause)
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestFloat(Connection connection, Float testFloat) throws SQLException {
		String cacheKey = "cacheKey"  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByTestFloat_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_TEST_FLOAT);

			statement = stringBuilder.toString();
			deleteByTestFloat_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByTestFloat_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setFloat(preparedStatement, 1, testFloat);

			return(preparedStatement.executeUpdate());
		}
	}

  	// USER DEFINED DELETER CONNECTION, PARAMS SILENT
  	/**
  	 * deleteByTestFloat - from 'fieldDeleters' JSON key
  	 *
  	 * This is the main method for all other deleter methods with the same prefix,
  	 * including the (silent method signatures).  All methods chain to this one.
  	 * 
            	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testFloat - maps to the test_float field (from the where clause)
  	 * 
  	 * @return the number of rows deleted
  	 */
  	public static int deleteByTestFloatSilent(Connection connection, Float testFloat) {
  		try {
  			return(deleteByTestFloat(connection,   testFloat    ));
  		} catch (SQLException ex) {
  			LOGGER.error("Could not deleteByTestFloat, a SQL Exception occurred.", ex);
  			return(-1);
  		}
  	}
  
	// USER DEFINED DELETER - NULL, PARAMS, NULL LOUD
	/**
	 * deleteByTestFloat - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testFloat - maps to the test_float field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByTestFloat(Float testFloat) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestFloat(connection, testFloat));
		}
	}

	// USER DEFINED DELETER - NULL, PARAMS, NULL SILENT
	/**
	 * deleteByTestFloat - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testFloat - maps to the test_float field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByTestFloatSilent(Float testFloat) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestFloat(connection, testFloat));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestFloat, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	// USER DEFINED DELETER CONNECTION, PARAMS - NO LIMIT - SQLITE3 STATEMENT
	/**
	 * deleteByTestInt - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testInt - maps to the test_int field (from the where clause)
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestInt(Connection connection, Integer testInt) throws SQLException {
		String cacheKey = "cacheKey"  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByTestInt_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_TEST_INT);

			statement = stringBuilder.toString();
			deleteByTestInt_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByTestInt_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setInt(preparedStatement, 1, testInt);

			return(preparedStatement.executeUpdate());
		}
	}

  	// USER DEFINED DELETER CONNECTION, PARAMS SILENT
  	/**
  	 * deleteByTestInt - from 'fieldDeleters' JSON key
  	 *
  	 * This is the main method for all other deleter methods with the same prefix,
  	 * including the (silent method signatures).  All methods chain to this one.
  	 * 
            	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testInt - maps to the test_int field (from the where clause)
  	 * 
  	 * @return the number of rows deleted
  	 */
  	public static int deleteByTestIntSilent(Connection connection, Integer testInt) {
  		try {
  			return(deleteByTestInt(connection,   testInt    ));
  		} catch (SQLException ex) {
  			LOGGER.error("Could not deleteByTestInt, a SQL Exception occurred.", ex);
  			return(-1);
  		}
  	}
  
	// USER DEFINED DELETER - NULL, PARAMS, NULL LOUD
	/**
	 * deleteByTestInt - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testInt - maps to the test_int field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByTestInt(Integer testInt) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestInt(connection, testInt));
		}
	}

	// USER DEFINED DELETER - NULL, PARAMS, NULL SILENT
	/**
	 * deleteByTestInt - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testInt - maps to the test_int field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByTestIntSilent(Integer testInt) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestInt(connection, testInt));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestInt, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	// USER DEFINED DELETER CONNECTION, PARAMS - NO LIMIT - SQLITE3 STATEMENT
	/**
	 * deleteByTestInteger - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testInteger - maps to the test_integer field (from the where clause)
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestInteger(Connection connection, Integer testInteger) throws SQLException {
		String cacheKey = "cacheKey"  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByTestInteger_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_TEST_INTEGER);

			statement = stringBuilder.toString();
			deleteByTestInteger_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByTestInteger_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setInteger(preparedStatement, 1, testInteger);

			return(preparedStatement.executeUpdate());
		}
	}

  	// USER DEFINED DELETER CONNECTION, PARAMS SILENT
  	/**
  	 * deleteByTestInteger - from 'fieldDeleters' JSON key
  	 *
  	 * This is the main method for all other deleter methods with the same prefix,
  	 * including the (silent method signatures).  All methods chain to this one.
  	 * 
            	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testInteger - maps to the test_integer field (from the where clause)
  	 * 
  	 * @return the number of rows deleted
  	 */
  	public static int deleteByTestIntegerSilent(Connection connection, Integer testInteger) {
  		try {
  			return(deleteByTestInteger(connection,   testInteger    ));
  		} catch (SQLException ex) {
  			LOGGER.error("Could not deleteByTestInteger, a SQL Exception occurred.", ex);
  			return(-1);
  		}
  	}
  
	// USER DEFINED DELETER - NULL, PARAMS, NULL LOUD
	/**
	 * deleteByTestInteger - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testInteger - maps to the test_integer field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByTestInteger(Integer testInteger) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestInteger(connection, testInteger));
		}
	}

	// USER DEFINED DELETER - NULL, PARAMS, NULL SILENT
	/**
	 * deleteByTestInteger - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testInteger - maps to the test_integer field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByTestIntegerSilent(Integer testInteger) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestInteger(connection, testInteger));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestInteger, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	// USER DEFINED DELETER CONNECTION, PARAMS - NO LIMIT - SQLITE3 STATEMENT
	/**
	 * deleteByTestMediumint - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testMediumint - maps to the test_mediumint field (from the where clause)
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestMediumint(Connection connection, Integer testMediumint) throws SQLException {
		String cacheKey = "cacheKey"  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByTestMediumint_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_TEST_MEDIUMINT);

			statement = stringBuilder.toString();
			deleteByTestMediumint_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByTestMediumint_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setMediumint(preparedStatement, 1, testMediumint);

			return(preparedStatement.executeUpdate());
		}
	}

  	// USER DEFINED DELETER CONNECTION, PARAMS SILENT
  	/**
  	 * deleteByTestMediumint - from 'fieldDeleters' JSON key
  	 *
  	 * This is the main method for all other deleter methods with the same prefix,
  	 * including the (silent method signatures).  All methods chain to this one.
  	 * 
            	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testMediumint - maps to the test_mediumint field (from the where clause)
  	 * 
  	 * @return the number of rows deleted
  	 */
  	public static int deleteByTestMediumintSilent(Connection connection, Integer testMediumint) {
  		try {
  			return(deleteByTestMediumint(connection,   testMediumint    ));
  		} catch (SQLException ex) {
  			LOGGER.error("Could not deleteByTestMediumint, a SQL Exception occurred.", ex);
  			return(-1);
  		}
  	}
  
	// USER DEFINED DELETER - NULL, PARAMS, NULL LOUD
	/**
	 * deleteByTestMediumint - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testMediumint - maps to the test_mediumint field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByTestMediumint(Integer testMediumint) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestMediumint(connection, testMediumint));
		}
	}

	// USER DEFINED DELETER - NULL, PARAMS, NULL SILENT
	/**
	 * deleteByTestMediumint - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testMediumint - maps to the test_mediumint field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByTestMediumintSilent(Integer testMediumint) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestMediumint(connection, testMediumint));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestMediumint, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	// USER DEFINED DELETER CONNECTION, PARAMS - NO LIMIT - SQLITE3 STATEMENT
	/**
	 * deleteByTestNumeric - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testNumeric - maps to the test_numeric field (from the where clause)
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestNumeric(Connection connection, BigDecimal testNumeric) throws SQLException {
		String cacheKey = "cacheKey"  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByTestNumeric_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_TEST_NUMERIC);

			statement = stringBuilder.toString();
			deleteByTestNumeric_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByTestNumeric_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setNumeric(preparedStatement, 1, testNumeric);

			return(preparedStatement.executeUpdate());
		}
	}

  	// USER DEFINED DELETER CONNECTION, PARAMS SILENT
  	/**
  	 * deleteByTestNumeric - from 'fieldDeleters' JSON key
  	 *
  	 * This is the main method for all other deleter methods with the same prefix,
  	 * including the (silent method signatures).  All methods chain to this one.
  	 * 
            	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testNumeric - maps to the test_numeric field (from the where clause)
  	 * 
  	 * @return the number of rows deleted
  	 */
  	public static int deleteByTestNumericSilent(Connection connection, BigDecimal testNumeric) {
  		try {
  			return(deleteByTestNumeric(connection,   testNumeric    ));
  		} catch (SQLException ex) {
  			LOGGER.error("Could not deleteByTestNumeric, a SQL Exception occurred.", ex);
  			return(-1);
  		}
  	}
  
	// USER DEFINED DELETER - NULL, PARAMS, NULL LOUD
	/**
	 * deleteByTestNumeric - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testNumeric - maps to the test_numeric field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByTestNumeric(BigDecimal testNumeric) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestNumeric(connection, testNumeric));
		}
	}

	// USER DEFINED DELETER - NULL, PARAMS, NULL SILENT
	/**
	 * deleteByTestNumeric - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testNumeric - maps to the test_numeric field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByTestNumericSilent(BigDecimal testNumeric) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestNumeric(connection, testNumeric));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestNumeric, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	// USER DEFINED DELETER CONNECTION, PARAMS - NO LIMIT - SQLITE3 STATEMENT
	/**
	 * deleteByTestSmallint - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testSmallint - maps to the test_smallint field (from the where clause)
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestSmallint(Connection connection, Short testSmallint) throws SQLException {
		String cacheKey = "cacheKey"  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByTestSmallint_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_TEST_SMALLINT);

			statement = stringBuilder.toString();
			deleteByTestSmallint_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByTestSmallint_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setSmallint(preparedStatement, 1, testSmallint);

			return(preparedStatement.executeUpdate());
		}
	}

  	// USER DEFINED DELETER CONNECTION, PARAMS SILENT
  	/**
  	 * deleteByTestSmallint - from 'fieldDeleters' JSON key
  	 *
  	 * This is the main method for all other deleter methods with the same prefix,
  	 * including the (silent method signatures).  All methods chain to this one.
  	 * 
            	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testSmallint - maps to the test_smallint field (from the where clause)
  	 * 
  	 * @return the number of rows deleted
  	 */
  	public static int deleteByTestSmallintSilent(Connection connection, Short testSmallint) {
  		try {
  			return(deleteByTestSmallint(connection,   testSmallint    ));
  		} catch (SQLException ex) {
  			LOGGER.error("Could not deleteByTestSmallint, a SQL Exception occurred.", ex);
  			return(-1);
  		}
  	}
  
	// USER DEFINED DELETER - NULL, PARAMS, NULL LOUD
	/**
	 * deleteByTestSmallint - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testSmallint - maps to the test_smallint field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByTestSmallint(Short testSmallint) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestSmallint(connection, testSmallint));
		}
	}

	// USER DEFINED DELETER - NULL, PARAMS, NULL SILENT
	/**
	 * deleteByTestSmallint - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testSmallint - maps to the test_smallint field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByTestSmallintSilent(Short testSmallint) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestSmallint(connection, testSmallint));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestSmallint, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	// USER DEFINED DELETER CONNECTION, PARAMS - NO LIMIT - SQLITE3 STATEMENT
	/**
	 * deleteByTestText - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testText - maps to the test_text field (from the where clause)
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestText(Connection connection, String testText) throws SQLException {
		String cacheKey = "cacheKey"  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByTestText_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_TEST_TEXT);

			statement = stringBuilder.toString();
			deleteByTestText_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByTestText_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setText(preparedStatement, 1, testText);

			return(preparedStatement.executeUpdate());
		}
	}

  	// USER DEFINED DELETER CONNECTION, PARAMS SILENT
  	/**
  	 * deleteByTestText - from 'fieldDeleters' JSON key
  	 *
  	 * This is the main method for all other deleter methods with the same prefix,
  	 * including the (silent method signatures).  All methods chain to this one.
  	 * 
            	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testText - maps to the test_text field (from the where clause)
  	 * 
  	 * @return the number of rows deleted
  	 */
  	public static int deleteByTestTextSilent(Connection connection, String testText) {
  		try {
  			return(deleteByTestText(connection,   testText    ));
  		} catch (SQLException ex) {
  			LOGGER.error("Could not deleteByTestText, a SQL Exception occurred.", ex);
  			return(-1);
  		}
  	}
  
	// USER DEFINED DELETER - NULL, PARAMS, NULL LOUD
	/**
	 * deleteByTestText - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testText - maps to the test_text field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByTestText(String testText) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestText(connection, testText));
		}
	}

	// USER DEFINED DELETER - NULL, PARAMS, NULL SILENT
	/**
	 * deleteByTestText - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testText - maps to the test_text field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByTestTextSilent(String testText) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestText(connection, testText));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestText, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	// USER DEFINED DELETER CONNECTION, PARAMS - NO LIMIT - SQLITE3 STATEMENT
	/**
	 * deleteByTestTinyint - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testTinyint - maps to the test_tinyint field (from the where clause)
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestTinyint(Connection connection, Boolean testTinyint) throws SQLException {
		String cacheKey = "cacheKey"  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByTestTinyint_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_TEST_TINYINT);

			statement = stringBuilder.toString();
			deleteByTestTinyint_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByTestTinyint_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setTinyint(preparedStatement, 1, testTinyint);

			return(preparedStatement.executeUpdate());
		}
	}

  	// USER DEFINED DELETER CONNECTION, PARAMS SILENT
  	/**
  	 * deleteByTestTinyint - from 'fieldDeleters' JSON key
  	 *
  	 * This is the main method for all other deleter methods with the same prefix,
  	 * including the (silent method signatures).  All methods chain to this one.
  	 * 
            	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testTinyint - maps to the test_tinyint field (from the where clause)
  	 * 
  	 * @return the number of rows deleted
  	 */
  	public static int deleteByTestTinyintSilent(Connection connection, Boolean testTinyint) {
  		try {
  			return(deleteByTestTinyint(connection,   testTinyint    ));
  		} catch (SQLException ex) {
  			LOGGER.error("Could not deleteByTestTinyint, a SQL Exception occurred.", ex);
  			return(-1);
  		}
  	}
  
	// USER DEFINED DELETER - NULL, PARAMS, NULL LOUD
	/**
	 * deleteByTestTinyint - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testTinyint - maps to the test_tinyint field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByTestTinyint(Boolean testTinyint) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestTinyint(connection, testTinyint));
		}
	}

	// USER DEFINED DELETER - NULL, PARAMS, NULL SILENT
	/**
	 * deleteByTestTinyint - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testTinyint - maps to the test_tinyint field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByTestTinyintSilent(Boolean testTinyint) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestTinyint(connection, testTinyint));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestTinyint, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	// USER DEFINED DELETER CONNECTION, PARAMS - NO LIMIT - SQLITE3 STATEMENT
	/**
	 * deleteByTestVarchar - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testVarchar - maps to the test_varchar field (from the where clause)
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestVarchar(Connection connection, String testVarchar) throws SQLException {
		String cacheKey = "cacheKey"  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByTestVarchar_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_TEST_VARCHAR);

			statement = stringBuilder.toString();
			deleteByTestVarchar_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByTestVarchar_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setVarchar(preparedStatement, 1, testVarchar);

			return(preparedStatement.executeUpdate());
		}
	}

  	// USER DEFINED DELETER CONNECTION, PARAMS SILENT
  	/**
  	 * deleteByTestVarchar - from 'fieldDeleters' JSON key
  	 *
  	 * This is the main method for all other deleter methods with the same prefix,
  	 * including the (silent method signatures).  All methods chain to this one.
  	 * 
            	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testVarchar - maps to the test_varchar field (from the where clause)
  	 * 
  	 * @return the number of rows deleted
  	 */
  	public static int deleteByTestVarcharSilent(Connection connection, String testVarchar) {
  		try {
  			return(deleteByTestVarchar(connection,   testVarchar    ));
  		} catch (SQLException ex) {
  			LOGGER.error("Could not deleteByTestVarchar, a SQL Exception occurred.", ex);
  			return(-1);
  		}
  	}
  
	// USER DEFINED DELETER - NULL, PARAMS, NULL LOUD
	/**
	 * deleteByTestVarchar - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testVarchar - maps to the test_varchar field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByTestVarchar(String testVarchar) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestVarchar(connection, testVarchar));
		}
	}

	// USER DEFINED DELETER - NULL, PARAMS, NULL SILENT
	/**
	 * deleteByTestVarchar - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testVarchar - maps to the test_varchar field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
  
	public static int deleteByTestVarcharSilent(String testVarchar) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestVarchar(connection, testVarchar));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestVarchar, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

}