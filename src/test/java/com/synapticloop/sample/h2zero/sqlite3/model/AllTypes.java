package com.synapticloop.sample.h2zero.sqlite3.model;

// - - - - thoughtfully generated by synapticloop h2zero - - - - 
//    with the use of synapticloop templar templating language
//                  (java-create-model.templar)

import com.synapticloop.h2zero.base.sql.sqlite3.ConnectionManager;
import com.synapticloop.h2zero.base.validator.bean.ValidationBean;
import com.synapticloop.h2zero.base.validator.*;
import com.synapticloop.h2zero.base.model.sqlite3.ModelBase;
import com.synapticloop.h2zero.base.exception.H2ZeroPrimaryKeyException;
import com.synapticloop.h2zero.base.exception.H2ZeroFinderException;

import java.sql.Connection;
import java.sql.Date;
import java.math.BigDecimal;
import java.sql.Timestamp;
import java.sql.ResultSet;
import java.sql.Statement;
import java.sql.PreparedStatement;
import java.sql.SQLException;

import org.json.JSONObject;
import com.synapticloop.h2zero.util.XmlHelper;

import com.synapticloop.h2zero.base.model.ModelBaseHelper;
import com.synapticloop.sample.h2zero.sqlite3.model.util.Constants;

import com.synapticloop.sample.h2zero.sqlite3.finder.AllTypesFinder;


/**
 * <p>This is the model for the <code>AllTypes</code> which maps to the <code>all_types</code> database table.</p>
 * <p>This class contains all CRUD (Create, Read, Update, and Delete) methods.</p>
  * 
 * @author synapticloop h2zero
 * 
 * <p>@see <a href="https://github.com/synapticloop/h2zero">Synapticloop h2zero GitHub repository</a></p>
 */
public class AllTypes extends ModelBase {
	// the binder is unused in code, but will generate compile problems if this 
	// class is no longer referenced in the h2zero file. Just a nicety for
	// removing dead code
	@SuppressWarnings("unused")
	private static final String BINDER = Constants.ALL_TYPES_BINDER;


	public static final String PRIMARY_KEY_FIELD = "id_all_types";  // the primary key - a convenience field

	private static final String SQL_INSERT = 
		"""
			insert into
			all_types (
				test_bigint,
				test_boolean,
				test_date,
				test_datetime,
				test_double,
				test_float,
				test_int,
				test_integer,
				test_mediumint,
				test_numeric,
				test_smallint,
				test_text,
				test_tinyint,
				test_varchar
			) values (
				?,
				?,
				?,
				?,
				?,
				?,
				?,
				?,
				?,
				?,
				?,
				?,
				?,
				?
			)
		""";
	private static final String SQL_UPDATE = 
		"""
			update
				all_types
			set
				test_bigint = ?,
				test_boolean = ?,
				test_date = ?,
				test_datetime = ?,
				test_double = ?,
				test_float = ?,
				test_int = ?,
				test_integer = ?,
				test_mediumint = ?,
				test_numeric = ?,
				test_smallint = ?,
				test_text = ?,
				test_tinyint = ?,
				test_varchar = ?
			where
		"""
			+ PRIMARY_KEY_FIELD + 
		"""
			= ?
		""";
	private static final String SQL_DELETE = "delete from all_types where " + PRIMARY_KEY_FIELD + " = ?";
	private static final String SQL_ENSURE = "select " + PRIMARY_KEY_FIELD + " from all_types where test_bigint = ? and test_boolean = ? and test_date = ? and test_datetime = ? and test_double = ? and test_float = ? and test_int = ? and test_integer = ? and test_mediumint = ? and test_numeric = ? and test_smallint = ? and test_text = ? and test_tinyint = ? and test_varchar = ?";


	// Static lookups for fields in the hit counter.
	// Whilst these aren't used internally (the offset to the array is 
	// automatically computer, external classes can use these static fields 
	// to look up the hit counts in the array 
	public static final int HIT_TOTAL = 0;
	public static final int HIT_ID_ALL_TYPES = 1;
	public static final int HIT_TEST_BIGINT = 2;
	public static final int HIT_TEST_BOOLEAN = 3;
	public static final int HIT_TEST_DATE = 4;
	public static final int HIT_TEST_DATETIME = 5;
	public static final int HIT_TEST_DOUBLE = 6;
	public static final int HIT_TEST_FLOAT = 7;
	public static final int HIT_TEST_INT = 8;
	public static final int HIT_TEST_INTEGER = 9;
	public static final int HIT_TEST_MEDIUMINT = 10;
	public static final int HIT_TEST_NUMERIC = 11;
	public static final int HIT_TEST_SMALLINT = 12;
	public static final int HIT_TEST_TEXT = 13;
	public static final int HIT_TEST_TINYINT = 14;
	public static final int HIT_TEST_VARCHAR = 15;


	// the list of fields for the hit - starting with 'TOTAL'
	private static final String[] HIT_FIELDS = { "TOTAL", "id_all_types", "test_bigint", "test_boolean", "test_date", "test_datetime", "test_double", "test_float", "test_int", "test_integer", "test_mediumint", "test_numeric", "test_smallint", "test_text", "test_tinyint", "test_varchar" };
	// the number of read-hits for a particular field
	private static final int[] HIT_COUNTS = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };


	private Long idAllTypes = null; // maps to the id_all_types field
	private Long testBigint = null; // maps to the test_bigint field
	private Boolean testBoolean = null; // maps to the test_boolean field
	private Date testDate = null; // maps to the test_date field
	private Timestamp testDatetime = null; // maps to the test_datetime field
	private Double testDouble = null; // maps to the test_double field
	private Float testFloat = null; // maps to the test_float field
	private Integer testInt = null; // maps to the test_int field
	private Integer testInteger = null; // maps to the test_integer field
	private Integer testMediumint = null; // maps to the test_mediumint field
	private BigDecimal testNumeric = null; // maps to the test_numeric field
	private Short testSmallint = null; // maps to the test_smallint field
	private String testText = null; // maps to the test_text field
	private Boolean testTinyint = null; // maps to the test_tinyint field
	private String testVarchar = null; // maps to the test_varchar field

	public AllTypes(Long idAllTypes, Long testBigint, Boolean testBoolean, Date testDate, Timestamp testDatetime, Double testDouble, Float testFloat, Integer testInt, Integer testInteger, Integer testMediumint, BigDecimal testNumeric, Short testSmallint, String testText, Boolean testTinyint, String testVarchar) {
		this.idAllTypes = idAllTypes;
		this.testBigint = testBigint;
		this.testBoolean = testBoolean;
		this.testDate = testDate;
		this.testDatetime = testDatetime;
		this.testDouble = testDouble;
		this.testFloat = testFloat;
		this.testInt = testInt;
		this.testInteger = testInteger;
		this.testMediumint = testMediumint;
		this.testNumeric = testNumeric;
		this.testSmallint = testSmallint;
		this.testText = testText;
		this.testTinyint = testTinyint;
		this.testVarchar = testVarchar;
	}

	public AllTypes(Long idAllTypes) {
		this.idAllTypes = idAllTypes;
		this.testBigint = null;
		this.testBoolean = null;
		this.testDate = null;
		this.testDatetime = null;
		this.testDouble = null;
		this.testFloat = null;
		this.testInt = null;
		this.testInteger = null;
		this.testMediumint = null;
		this.testNumeric = null;
		this.testSmallint = null;
		this.testText = null;
		this.testTinyint = null;
		this.testVarchar = null;
	}

	/**
	 * <p>Get a new AllTypes model, or set the fields on an existing
	 * AllTypes model.</p>
	 * 
	 * <p>If the passed in allTypes is null, then a new AllTypes
	 * will be created.  If not null, the fields will be updated on the passed in model.</p>
	 * 
	 * <p><strong>NOTE:</strong> You will still need to persist this to the database
	 * with an <code>upsert()</code> call - this will insert the model if it .
	 * doesn't exist, or update the existing model.</p>
	 * 
	 * @param allTypes the model to check
	 * @param testBigint - maps to the <code>test_bigint</code> field.
	 * @param testBoolean - maps to the <code>test_boolean</code> field.
	 * @param testDate - maps to the <code>test_date</code> field.
	 * @param testDatetime - maps to the <code>test_datetime</code> field.
	 * @param testDouble - maps to the <code>test_double</code> field.
	 * @param testFloat - maps to the <code>test_float</code> field.
	 * @param testInt - maps to the <code>test_int</code> field.
	 * @param testInteger - maps to the <code>test_integer</code> field.
	 * @param testMediumint - maps to the <code>test_mediumint</code> field.
	 * @param testNumeric - maps to the <code>test_numeric</code> field.
	 * @param testSmallint - maps to the <code>test_smallint</code> field.
	 * @param testText - maps to the <code>test_text</code> field.
	 * @param testTinyint - maps to the <code>test_tinyint</code> field.
	 * @param testVarchar - maps to the <code>test_varchar</code> field.
	 * 
	 * @return Either the existing allTypes with updated field values,
	 *   or a new AllTypes with the field values set.
	 */
	public static AllTypes getOrSet(AllTypes allTypes,Long testBigint, Boolean testBoolean, Date testDate, Timestamp testDatetime, Double testDouble, Float testFloat, Integer testInt, Integer testInteger, Integer testMediumint, BigDecimal testNumeric, Short testSmallint, String testText, Boolean testTinyint, String testVarchar) {
		if(null == allTypes) {
			return (new AllTypes(null, testBigint, testBoolean, testDate, testDatetime, testDouble, testFloat, testInt, testInteger, testMediumint, testNumeric, testSmallint, testText, testTinyint, testVarchar));
		} else {
			allTypes.setTestBigint(testBigint);
			allTypes.setTestBoolean(testBoolean);
			allTypes.setTestDate(testDate);
			allTypes.setTestDatetime(testDatetime);
			allTypes.setTestDouble(testDouble);
			allTypes.setTestFloat(testFloat);
			allTypes.setTestInt(testInt);
			allTypes.setTestInteger(testInteger);
			allTypes.setTestMediumint(testMediumint);
			allTypes.setTestNumeric(testNumeric);
			allTypes.setTestSmallint(testSmallint);
			allTypes.setTestText(testText);
			allTypes.setTestTinyint(testTinyint);
			allTypes.setTestVarchar(testVarchar);

			return(allTypes);
		}
	}

	/**
	 * Get a new AllTypes model, or set the fields on an existing
	 * AllTypes model.
	 * <p>
	 * If the passed in allTypes is null, then a new AllTypes
	 * will be created.  If not null, the fields will be updated on the existing model.
	 * <p>
	 * <strong>NOTE:</strong> You will still need to persist this to the database
	 * with an <code>upsert()</code> call.
	 * 
	 * @param allTypes the model to check
	 * 
	 * @return Either the existing allTypes with updated field values,
	 *   or a new AllTypes with the field values set.
	 */
	public static AllTypes getOrSet(AllTypes allTypes) {
		if(null == allTypes) {
			return (new AllTypes(null ));
		} else {

			return(allTypes);
		}
	}

	@Override
	public boolean primaryKeySet() {
		return(null != idAllTypes);
	}


	@Override
	public void insert(Connection connection) throws SQLException, H2ZeroPrimaryKeyException {
		if(primaryKeySet()) {
			throw new H2ZeroPrimaryKeyException("Cannot insert all_types model when primary key is not null.");
		}

		PreparedStatement preparedStatement = null;
		ResultSet resultSet = null;
		try {
			// create this bean 
			preparedStatement = connection.prepareStatement(SQL_INSERT, Statement.RETURN_GENERATED_KEYS);
			ConnectionManager.setBigint(preparedStatement, 1, testBigint);
			ConnectionManager.setBoolean(preparedStatement, 2, testBoolean);
			ConnectionManager.setDate(preparedStatement, 3, testDate);
			ConnectionManager.setDatetime(preparedStatement, 4, testDatetime);
			ConnectionManager.setDouble(preparedStatement, 5, testDouble);
			ConnectionManager.setFloat(preparedStatement, 6, testFloat);
			ConnectionManager.setInt(preparedStatement, 7, testInt);
			ConnectionManager.setInteger(preparedStatement, 8, testInteger);
			ConnectionManager.setMediumint(preparedStatement, 9, testMediumint);
			ConnectionManager.setNumeric(preparedStatement, 10, testNumeric);
			ConnectionManager.setSmallint(preparedStatement, 11, testSmallint);
			ConnectionManager.setText(preparedStatement, 12, testText);
			ConnectionManager.setTinyint(preparedStatement, 13, testTinyint);
			ConnectionManager.setVarchar(preparedStatement, 14, testVarchar);
			preparedStatement.executeUpdate();
			resultSet = preparedStatement.getGeneratedKeys();
			if(resultSet.next()) {
				this.idAllTypes = resultSet.getLong(1);
			} else {
				throw new H2ZeroPrimaryKeyException("Could not get return value for primary key!");
			}
		} finally {
			ConnectionManager.closeAll(resultSet, preparedStatement);
		}
	}

	@Override
	public void ensure(Connection connection) throws SQLException, H2ZeroPrimaryKeyException {

		PreparedStatement preparedStatement = null;
		ResultSet resultSet = null;
		try {
			preparedStatement = connection.prepareStatement(SQL_ENSURE);
			ConnectionManager.setBigint(preparedStatement, 1, testBigint);
			ConnectionManager.setBoolean(preparedStatement, 2, testBoolean);
			ConnectionManager.setDate(preparedStatement, 3, testDate);
			ConnectionManager.setDatetime(preparedStatement, 4, testDatetime);
			ConnectionManager.setDouble(preparedStatement, 5, testDouble);
			ConnectionManager.setFloat(preparedStatement, 6, testFloat);
			ConnectionManager.setInt(preparedStatement, 7, testInt);
			ConnectionManager.setInteger(preparedStatement, 8, testInteger);
			ConnectionManager.setMediumint(preparedStatement, 9, testMediumint);
			ConnectionManager.setNumeric(preparedStatement, 10, testNumeric);
			ConnectionManager.setSmallint(preparedStatement, 11, testSmallint);
			ConnectionManager.setText(preparedStatement, 12, testText);
			ConnectionManager.setTinyint(preparedStatement, 13, testTinyint);
			ConnectionManager.setVarchar(preparedStatement, 14, testVarchar);
			resultSet = preparedStatement.executeQuery();
			if(resultSet.next()) {
				this.idAllTypes = resultSet.getLong(1);
			} else {
				// could not find the value - need to insert it - null is the primary key
				insert(connection);
			}
		} finally {
			ConnectionManager.closeAll(resultSet, preparedStatement);
		}
	}

	@Override
	public void update(Connection connection) throws SQLException, H2ZeroPrimaryKeyException {
		if(!primaryKeySet()) {
			throw new H2ZeroPrimaryKeyException("Cannot update bean when primary key is null.");
		}

		if(isDirty) {
			try (PreparedStatement preparedStatement = connection.prepareStatement(SQL_UPDATE)) {
				// update this bean, but only if dirty
				ConnectionManager.setBigint(preparedStatement, 1, testBigint);
				ConnectionManager.setBoolean(preparedStatement, 2, testBoolean);
				ConnectionManager.setDate(preparedStatement, 3, testDate);
				ConnectionManager.setDatetime(preparedStatement, 4, testDatetime);
				ConnectionManager.setDouble(preparedStatement, 5, testDouble);
				ConnectionManager.setFloat(preparedStatement, 6, testFloat);
				ConnectionManager.setInt(preparedStatement, 7, testInt);
				ConnectionManager.setInteger(preparedStatement, 8, testInteger);
				ConnectionManager.setMediumint(preparedStatement, 9, testMediumint);
				ConnectionManager.setNumeric(preparedStatement, 10, testNumeric);
				ConnectionManager.setSmallint(preparedStatement, 11, testSmallint);
				ConnectionManager.setText(preparedStatement, 12, testText);
				ConnectionManager.setTinyint(preparedStatement, 13, testTinyint);
				ConnectionManager.setVarchar(preparedStatement, 14, testVarchar);
				// now set the primary key
				preparedStatement.setLong(15, idAllTypes);
				preparedStatement.executeUpdate();
			} finally {
				isDirty = false;
			}
		}
	}

	@Override
	public void delete(Connection connection) throws SQLException, H2ZeroPrimaryKeyException {
		if(!primaryKeySet()) {
			throw new H2ZeroPrimaryKeyException("Cannot delete bean when primary key is null.");
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(SQL_DELETE)) {
			preparedStatement.setLong(1, idAllTypes);
			preparedStatement.executeUpdate();
		}
	}

	@Override
	public void refresh(Connection connection) throws SQLException, H2ZeroPrimaryKeyException, H2ZeroFinderException {
		if(!primaryKeySet()) {
			throw new H2ZeroPrimaryKeyException("Cannot refresh model 'AllTypes' when primary key is null.");
		}

		AllTypes allTypes = AllTypesFinder.findByPrimaryKeySilent(connection, this.idAllTypes);
		if(null == allTypes) {
			throw new H2ZeroFinderException("Could not find the model 'AllTypes' with primaryKey of " + getPrimaryKey());
		}
		this.idAllTypes = allTypes.getIdAllTypes();
		this.testBigint = allTypes.getTestBigint();
		this.testBoolean = allTypes.getTestBoolean();
		this.testDate = allTypes.getTestDate();
		this.testDatetime = allTypes.getTestDatetime();
		this.testDouble = allTypes.getTestDouble();
		this.testFloat = allTypes.getTestFloat();
		this.testInt = allTypes.getTestInt();
		this.testInteger = allTypes.getTestInteger();
		this.testMediumint = allTypes.getTestMediumint();
		this.testNumeric = allTypes.getTestNumeric();
		this.testSmallint = allTypes.getTestSmallint();
		this.testText = allTypes.getTestText();
		this.testTinyint = allTypes.getTestTinyint();
		this.testVarchar = allTypes.getTestVarchar();
	}

	public static String[] getHitFields() { return(HIT_FIELDS); }
	public static int[] getHitCounts() { return(HIT_COUNTS); }

	/**
	 * Get the hit count for a specific field - look at the <code>public static HIT_*</code>
	 * fields to retrieve a specific field.
	 *
	 * @param hitCountField the hit count field number to retrieve the hit count from
	 *
	 * @return the hit count for the field
	 * 
	 * <p>{@link #HIT_ID_ALL_TYPES Use <code>AllTypes.HIT_ID_ALL_TYPES</code> to retrieve the hit count for the <code>id_all_types</code> field}</p>
	 * <p>{@link #HIT_TEST_BIGINT Use <code>AllTypes.HIT_TEST_BIGINT</code> to retrieve the hit count for the <code>test_bigint</code> field}</p>
	 * <p>{@link #HIT_TEST_BOOLEAN Use <code>AllTypes.HIT_TEST_BOOLEAN</code> to retrieve the hit count for the <code>test_boolean</code> field}</p>
	 * <p>{@link #HIT_TEST_DATE Use <code>AllTypes.HIT_TEST_DATE</code> to retrieve the hit count for the <code>test_date</code> field}</p>
	 * <p>{@link #HIT_TEST_DATETIME Use <code>AllTypes.HIT_TEST_DATETIME</code> to retrieve the hit count for the <code>test_datetime</code> field}</p>
	 * <p>{@link #HIT_TEST_DOUBLE Use <code>AllTypes.HIT_TEST_DOUBLE</code> to retrieve the hit count for the <code>test_double</code> field}</p>
	 * <p>{@link #HIT_TEST_FLOAT Use <code>AllTypes.HIT_TEST_FLOAT</code> to retrieve the hit count for the <code>test_float</code> field}</p>
	 * <p>{@link #HIT_TEST_INT Use <code>AllTypes.HIT_TEST_INT</code> to retrieve the hit count for the <code>test_int</code> field}</p>
	 * <p>{@link #HIT_TEST_INTEGER Use <code>AllTypes.HIT_TEST_INTEGER</code> to retrieve the hit count for the <code>test_integer</code> field}</p>
	 * <p>{@link #HIT_TEST_MEDIUMINT Use <code>AllTypes.HIT_TEST_MEDIUMINT</code> to retrieve the hit count for the <code>test_mediumint</code> field}</p>
	 * <p>{@link #HIT_TEST_NUMERIC Use <code>AllTypes.HIT_TEST_NUMERIC</code> to retrieve the hit count for the <code>test_numeric</code> field}</p>
	 * <p>{@link #HIT_TEST_SMALLINT Use <code>AllTypes.HIT_TEST_SMALLINT</code> to retrieve the hit count for the <code>test_smallint</code> field}</p>
	 * <p>{@link #HIT_TEST_TEXT Use <code>AllTypes.HIT_TEST_TEXT</code> to retrieve the hit count for the <code>test_text</code> field}</p>
	 * <p>{@link #HIT_TEST_TINYINT Use <code>AllTypes.HIT_TEST_TINYINT</code> to retrieve the hit count for the <code>test_tinyint</code> field}</p>
	 * <p>{@link #HIT_TEST_VARCHAR Use <code>AllTypes.HIT_TEST_VARCHAR</code> to retrieve the hit count for the <code>test_varchar</code> field}</p>

	 */
	public static int getHitCountForField(int hitCountField) { return(HIT_COUNTS[hitCountField]); }

	public static void updateHitCount(int offset) {
		HIT_COUNTS[0]++;
		HIT_COUNTS[offset]++;
	}

	/*
	 * Boring ol' getters and setters 
	 * 
	 * On setting any of these fields - the 'isDirty' flag will be set
	 * 
	 */

	public Long getPrimaryKey() { updateHitCount(1); return(this.idAllTypes); }
	public void setPrimaryKey(Long idAllTypes) { if(isDifferent(this.idAllTypes, idAllTypes)) { this.idAllTypes = idAllTypes;this.isDirty = true; }}
	public Long getIdAllTypes() { updateHitCount(1); return(this.idAllTypes); }
	public void setIdAllTypes(Long idAllTypes) { if(isDifferent(this.idAllTypes, idAllTypes)) { this.idAllTypes = idAllTypes;this.isDirty = true; }}
	public Long getTestBigint() { updateHitCount(2); return(this.testBigint); }
	public void setTestBigint(Long testBigint) { if(isDifferent(this.testBigint, testBigint)) { this.testBigint = testBigint;this.isDirty = true; }}
	public Boolean getTestBoolean() { updateHitCount(3); return(this.testBoolean); }
	public void setTestBoolean(Boolean testBoolean) { if(isDifferent(this.testBoolean, testBoolean)) { this.testBoolean = testBoolean;this.isDirty = true; }}
	public Date getTestDate() { updateHitCount(4); return(this.testDate); }
	public void setTestDate(Date testDate) { if(isDifferent(this.testDate, testDate)) { this.testDate = testDate;this.isDirty = true; }}
	public Timestamp getTestDatetime() { updateHitCount(5); return(this.testDatetime); }
	public void setTestDatetime(Timestamp testDatetime) { if(isDifferent(this.testDatetime, testDatetime)) { this.testDatetime = testDatetime;this.isDirty = true; }}
	public Double getTestDouble() { updateHitCount(6); return(this.testDouble); }
	public void setTestDouble(Double testDouble) { if(isDifferent(this.testDouble, testDouble)) { this.testDouble = testDouble;this.isDirty = true; }}
	public Float getTestFloat() { updateHitCount(7); return(this.testFloat); }
	public void setTestFloat(Float testFloat) { if(isDifferent(this.testFloat, testFloat)) { this.testFloat = testFloat;this.isDirty = true; }}
	public Integer getTestInt() { updateHitCount(8); return(this.testInt); }
	public void setTestInt(Integer testInt) { if(isDifferent(this.testInt, testInt)) { this.testInt = testInt;this.isDirty = true; }}
	public Integer getTestInteger() { updateHitCount(9); return(this.testInteger); }
	public void setTestInteger(Integer testInteger) { if(isDifferent(this.testInteger, testInteger)) { this.testInteger = testInteger;this.isDirty = true; }}
	public Integer getTestMediumint() { updateHitCount(10); return(this.testMediumint); }
	public void setTestMediumint(Integer testMediumint) { if(isDifferent(this.testMediumint, testMediumint)) { this.testMediumint = testMediumint;this.isDirty = true; }}
	public BigDecimal getTestNumeric() { updateHitCount(11); return(this.testNumeric); }
	public void setTestNumeric(BigDecimal testNumeric) { if(isDifferent(this.testNumeric, testNumeric)) { this.testNumeric = testNumeric;this.isDirty = true; }}
	public Short getTestSmallint() { updateHitCount(12); return(this.testSmallint); }
	public void setTestSmallint(Short testSmallint) { if(isDifferent(this.testSmallint, testSmallint)) { this.testSmallint = testSmallint;this.isDirty = true; }}
	public String getTestText() { updateHitCount(13); return(this.testText); }
	public void setTestText(String testText) { if(isDifferent(this.testText, testText)) { this.testText = testText;this.isDirty = true; }}
	public Boolean getTestTinyint() { updateHitCount(14); return(this.testTinyint); }
	public void setTestTinyint(Boolean testTinyint) { if(isDifferent(this.testTinyint, testTinyint)) { this.testTinyint = testTinyint;this.isDirty = true; }}
	public String getTestVarchar() { updateHitCount(15); return(this.testVarchar); }
	public void setTestVarchar(String testVarchar) { if(isDifferent(this.testVarchar, testVarchar)) { this.testVarchar = testVarchar;this.isDirty = true; }}

	@Override
	public ValidationBean validate() {
		ValidationBean validationBean = new ValidationBean();

		validationBean.addValidationFieldBean(new BigintValidator("test_bigint", testBigint.toString(), 0, 0, true).validate());
		validationBean.addValidationFieldBean(new BooleanValidator("test_boolean", testBoolean.toString(), 0, 0, true).validate());
		validationBean.addValidationFieldBean(new DateValidator("test_date", testDate.toString(), 0, 0, true).validate());
		validationBean.addValidationFieldBean(new DatetimeValidator("test_datetime", testDatetime.toString(), 0, 0, true).validate());
		validationBean.addValidationFieldBean(new DoubleValidator("test_double", testDouble.toString(), 0, 0, true).validate());
		validationBean.addValidationFieldBean(new FloatValidator("test_float", testFloat.toString(), 0, 0, true).validate());
		validationBean.addValidationFieldBean(new IntValidator("test_int", testInt.toString(), 0, 0, true).validate());
		validationBean.addValidationFieldBean(new IntegerValidator("test_integer", testInteger.toString(), 0, 0, true).validate());
		validationBean.addValidationFieldBean(new MediumintValidator("test_mediumint", testMediumint.toString(), 0, 0, true).validate());
		validationBean.addValidationFieldBean(new NumericValidator("test_numeric", testNumeric.toString(), 0, 0, true).validate());
		validationBean.addValidationFieldBean(new SmallintValidator("test_smallint", testSmallint.toString(), 0, 0, true).validate());
		validationBean.addValidationFieldBean(new TextValidator("test_text", testText.toString(), 0, 0, true).validate());
		validationBean.addValidationFieldBean(new TinyintValidator("test_tinyint", testTinyint.toString(), 0, 0, true).validate());
		validationBean.addValidationFieldBean(new VarcharValidator("test_varchar", testVarchar.toString(), 0, 0, true).validate());
		return(validationBean);
	}


	@Override
	public String toString() {
		return(
			"{\"AllTypes\": {" +
			"\"idAllTypes\":\"" + this.idAllTypes + "\"" +
			"\"testBigint\":\"" + this.testBigint + "\"" +
			"\"testBoolean\":\"" + this.testBoolean + "\"" +
			"\"testDate\":\"" + this.testDate + "\"" +
			"\"testDatetime\":\"" + this.testDatetime + "\"" +
			"\"testDouble\":\"" + this.testDouble + "\"" +
			"\"testFloat\":\"" + this.testFloat + "\"" +
			"\"testInt\":\"" + this.testInt + "\"" +
			"\"testInteger\":\"" + this.testInteger + "\"" +
			"\"testMediumint\":\"" + this.testMediumint + "\"" +
			"\"testNumeric\":\"" + this.testNumeric + "\"" +
			"\"testSmallint\":\"" + this.testSmallint + "\"" +
			"\"testText\":\"" + this.testText + "\"" +
			"\"testTinyint\":\"" + this.testTinyint + "\"" +
			"\"testVarchar\":\"" + this.testVarchar + "\"" +
			"}");
	}
	public JSONObject getToJSON() {
		return(toJSON());
	}

	public JSONObject toJSON() {
		JSONObject jsonObject = new JSONObject();

		jsonObject.put("type", "table");
		jsonObject.put("name", "AllTypes");
		JSONObject fieldsObject = new JSONObject();

		ModelBaseHelper.addtoJSONObject(fieldsObject, "idAllTypes", this.getIdAllTypes());
		ModelBaseHelper.addtoJSONObject(fieldsObject, "testBigint", this.getTestBigint());
		ModelBaseHelper.addtoJSONObject(fieldsObject, "testBoolean", this.getTestBoolean());
		ModelBaseHelper.addtoJSONObject(fieldsObject, "testDate", this.getTestDate());
		ModelBaseHelper.addtoJSONObject(fieldsObject, "testDatetime", this.getTestDatetime());
		ModelBaseHelper.addtoJSONObject(fieldsObject, "testDouble", this.getTestDouble());
		ModelBaseHelper.addtoJSONObject(fieldsObject, "testFloat", this.getTestFloat());
		ModelBaseHelper.addtoJSONObject(fieldsObject, "testInt", this.getTestInt());
		ModelBaseHelper.addtoJSONObject(fieldsObject, "testInteger", this.getTestInteger());
		ModelBaseHelper.addtoJSONObject(fieldsObject, "testMediumint", this.getTestMediumint());
		ModelBaseHelper.addtoJSONObject(fieldsObject, "testNumeric", this.getTestNumeric());
		ModelBaseHelper.addtoJSONObject(fieldsObject, "testSmallint", this.getTestSmallint());
		ModelBaseHelper.addtoJSONObject(fieldsObject, "testText", this.getTestText());
		ModelBaseHelper.addtoJSONObject(fieldsObject, "testTinyint", this.getTestTinyint());
		ModelBaseHelper.addtoJSONObject(fieldsObject, "testVarchar", this.getTestVarchar());

		jsonObject.put("fields", fieldsObject);

		return(jsonObject);
	}


	public String toJsonString() {
		return(toJSON().toString());
	}

	public String getJsonString() {
		return(toJsonString());
	}

	/**
	 * <p>Return an XML representation of the <code>AllTypes</code> model as a <code>String</code>, 
	 * with the root node being the name of the table - i.e. <code>&lt;all_types /&gt;</code> 
	 * and the child nodes the name of the fields.</p>
	 * 
	 * <p><strong>NOTE:</strong> Any field marked as secure will not be included as
	 * part of the XML document</p>
	 * 
	 * @return An XML representation of the model as a <code>String</code>.
	 */
	public String toXMLString() {
		return("<all_types>" + 
			String.format("<id_all_types null=\"%b\">%s</id_all_types>", (this.getIdAllTypes() == null), (this.getIdAllTypes() != null ? this.getIdAllTypes() : "")) + 
			String.format("<test_bigint null=\"%b\">%s</test_bigint>", (this.getTestBigint() == null), (this.getTestBigint() != null ? this.getTestBigint() : "")) + 
			String.format("<test_boolean null=\"%b\">%s</test_boolean>", (this.getTestBoolean() == null), (this.getTestBoolean() != null ? this.getTestBoolean() : "")) + 
			String.format("<test_date null=\"%b\">%s</test_date>", (this.getTestDate() == null), (this.getTestDate() != null ? this.getTestDate() : "")) + 
			String.format("<test_datetime null=\"%b\">%s</test_datetime>", (this.getTestDatetime() == null), (this.getTestDatetime() != null ? this.getTestDatetime() : "")) + 
			String.format("<test_double null=\"%b\">%s</test_double>", (this.getTestDouble() == null), (this.getTestDouble() != null ? this.getTestDouble() : "")) + 
			String.format("<test_float null=\"%b\">%s</test_float>", (this.getTestFloat() == null), (this.getTestFloat() != null ? this.getTestFloat() : "")) + 
			String.format("<test_int null=\"%b\">%s</test_int>", (this.getTestInt() == null), (this.getTestInt() != null ? this.getTestInt() : "")) + 
			String.format("<test_integer null=\"%b\">%s</test_integer>", (this.getTestInteger() == null), (this.getTestInteger() != null ? this.getTestInteger() : "")) + 
			String.format("<test_mediumint null=\"%b\">%s</test_mediumint>", (this.getTestMediumint() == null), (this.getTestMediumint() != null ? this.getTestMediumint() : "")) + 
			String.format("<test_numeric null=\"%b\">%s</test_numeric>", (this.getTestNumeric() == null), (this.getTestNumeric() != null ? this.getTestNumeric() : "")) + 
			String.format("<test_smallint null=\"%b\">%s</test_smallint>", (this.getTestSmallint() == null), (this.getTestSmallint() != null ? this.getTestSmallint() : "")) + 
			String.format("<test_text null=\"%b\">%s</test_text>", (this.getTestText() == null), (this.getTestText() != null ? XmlHelper.escapeXml(this.getTestText()) : "")) + 
			String.format("<test_tinyint null=\"%b\">%s</test_tinyint>", (this.getTestTinyint() == null), (this.getTestTinyint() != null ? this.getTestTinyint() : "")) + 
			String.format("<test_varchar null=\"%b\">%s</test_varchar>", (this.getTestVarchar() == null), (this.getTestVarchar() != null ? XmlHelper.escapeXml(this.getTestVarchar()) : "")) + 
			"</all_types>");
	}


	/**
	 * Get the hit count statistics as a JSON encoded object as a <code>String</code>.
	 *
	 * @return the JSON Object as a <code>String</code>.
	 */
	public static String getHitCountJson() {
		JSONObject jsonObject = new JSONObject();
		jsonObject.put("type", "AllTypes");
		jsonObject.put("total", HIT_COUNTS[0]);
		jsonObject.put("idAllTypes", HIT_COUNTS[1]);
		jsonObject.put("testBigint", HIT_COUNTS[2]);
		jsonObject.put("testBoolean", HIT_COUNTS[3]);
		jsonObject.put("testDate", HIT_COUNTS[4]);
		jsonObject.put("testDatetime", HIT_COUNTS[5]);
		jsonObject.put("testDouble", HIT_COUNTS[6]);
		jsonObject.put("testFloat", HIT_COUNTS[7]);
		jsonObject.put("testInt", HIT_COUNTS[8]);
		jsonObject.put("testInteger", HIT_COUNTS[9]);
		jsonObject.put("testMediumint", HIT_COUNTS[10]);
		jsonObject.put("testNumeric", HIT_COUNTS[11]);
		jsonObject.put("testSmallint", HIT_COUNTS[12]);
		jsonObject.put("testText", HIT_COUNTS[13]);
		jsonObject.put("testTinyint", HIT_COUNTS[14]);
		jsonObject.put("testVarchar", HIT_COUNTS[15]);
		return(jsonObject.toString());
	}

}