package com.synapticloop.sample.h2zero.sqlite3.inserter;

// - - - - thoughtfully generated by synapticloop h2zero - - - - 
//    with the use of synapticloop templar templating language
//              (java-create-inserter.templar)

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.math.BigDecimal;
import java.sql.Timestamp;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.synapticloop.h2zero.base.manager.sqlite3.ConnectionManager;
import com.synapticloop.sample.h2zero.sqlite3.model.util.Constants;

/**
 * This class contains the methods to insert new rows into the: 
 *   <code>sample.author</code>
 * table.  The fields that are available are as follows:
 * 
 * <ul>
 *  <li><code>id_author</code> (bigint)  <strong>NOT</strong> nullable  (PRIMARY)</li>
 *  <li><code>id_author_status</code> (bigint)  nullable </li>
 *  <li><code>txt_id_author</code> (varchar)  <strong>NOT</strong> nullable </li>
 *  <li><code>nm_author</code> (varchar)  <strong>NOT</strong> nullable </li>
 *  <li><code>nm_username</code> (varchar)  <strong>NOT</strong> nullable </li>
 *  <li><code>txt_bio</code> (varchar)  <strong>NOT</strong> nullable </li>
 *  <li><code>txt_url_cache_image</code> (varchar)  <strong>NOT</strong> nullable </li>
 *  <li><code>num_following</code> (bigint)  nullable </li>
 *  <li><code>num_followers</code> (bigint)  nullable </li>
 *  <li><code>dtm_started_following</code> (datetime)  nullable </li>
 *  <li><code>fl_is_updating</code> (boolean)  nullable </li>
 *  <li><code>fl_author_is_following_user</code> (boolean)  nullable </li>
 *  <li><code>fl_author_is_followed_by_user</code> (boolean)  nullable </li>
 * </ul>
 * 
 * @author synapticloop h2zero
 */

public class AuthorInserter {
	// the binder is unused in code, but will generate compile problems if this 
	// class is no longer referenced in the h2zero file. Just a nicety for
	// removing dead code
	@SuppressWarnings("unused")
	private static final String BINDER = Constants.AUTHOR_BINDER;

		private static final Logger LOGGER = LoggerFactory.getLogger(AuthorInserter.class);

	// static fields generated by synapticloop h2zero
	private static final String SQL_BUILTIN_INSERT_ALL = "insert into author(id_author, id_author_status, txt_id_author, nm_author, nm_username, txt_bio, txt_url_cache_image, num_following, num_followers, dtm_started_following, fl_is_updating, fl_author_is_following_user, fl_author_is_followed_by_user)";
	private static final String SQL_BUILTIN_INSERT_VALUES = SQL_BUILTIN_INSERT_ALL + " values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
	// static inserter SQL generated from the user input

	private AuthorInserter() {}

	/**
	 * Insert a new Author into the database utilising the passed in connection.
	 * 
	 * @param connection the connection to use for the database, this __MUST__ be 
	 *   closed by the calling function.
	 * @param idAuthor  maps to id_author
	 * @param idAuthorStatus  maps to id_author_status
	 * @param txtIdAuthor  maps to txt_id_author
	 * @param nmAuthor  maps to nm_author
	 * @param nmUsername  maps to nm_username
	 * @param txtBio  maps to txt_bio
	 * @param txtUrlCacheImage  maps to txt_url_cache_image
	 * @param numFollowing  maps to num_following
	 * @param numFollowers  maps to num_followers
	 * @param dtmStartedFollowing  maps to dtm_started_following
	 * @param flIsUpdating  maps to fl_is_updating
	 * @param flAuthorIsFollowingUser  maps to fl_author_is_following_user
	 * @param flAuthorIsFollowedByUser  maps to fl_author_is_followed_by_user
	 * 
	 * @return the number of rows that were inserted, or -1 if an error occurred
	 * 
	 * @throws SQLException if there was an error in the SQL insert statement
	 */
	public static int insert(Connection connection, Long idAuthor, Long idAuthorStatus, String txtIdAuthor, String nmAuthor, String nmUsername, String txtBio, String txtUrlCacheImage, Long numFollowing, Long numFollowers, Timestamp dtmStartedFollowing, Boolean flIsUpdating, Boolean flAuthorIsFollowingUser, Boolean flAuthorIsFollowedByUser) throws SQLException {
		try (PreparedStatement preparedStatement = connection.prepareStatement(SQL_BUILTIN_INSERT_VALUES)) {
			ConnectionManager.setBigint(preparedStatement, 1, idAuthor);
			ConnectionManager.setBigint(preparedStatement, 2, idAuthorStatus);
			ConnectionManager.setVarchar(preparedStatement, 3, txtIdAuthor);
			ConnectionManager.setVarchar(preparedStatement, 4, nmAuthor);
			ConnectionManager.setVarchar(preparedStatement, 5, nmUsername);
			ConnectionManager.setVarchar(preparedStatement, 6, txtBio);
			ConnectionManager.setVarchar(preparedStatement, 7, txtUrlCacheImage);
			ConnectionManager.setBigint(preparedStatement, 8, numFollowing);
			ConnectionManager.setBigint(preparedStatement, 9, numFollowers);
			ConnectionManager.setDatetime(preparedStatement, 10, dtmStartedFollowing);
			ConnectionManager.setBoolean(preparedStatement, 11, flIsUpdating);
			ConnectionManager.setBoolean(preparedStatement, 12, flAuthorIsFollowingUser);
			ConnectionManager.setBoolean(preparedStatement, 13, flAuthorIsFollowedByUser);
			return(preparedStatement.executeUpdate());
		}
	}

	/**
	 * Insert a new Author into the database utilising the passed in connection 
	 * with only the fields that are allowed to be not null.
	 * 
	 * @param connection the connection to use for the database, this __MUST__ be 
	 *   closed by the calling function.
	 * @param idAuthor  maps to id_author
	 * @param txtIdAuthor  maps to txt_id_author
	 * @param nmAuthor  maps to nm_author
	 * @param nmUsername  maps to nm_username
	 * @param txtBio  maps to txt_bio
	 * @param txtUrlCacheImage  maps to txt_url_cache_image
	 * 
	 * @return the number of rows that were inserted, or -1 if an error occurred
	 * 
	 * @throws SQLException if there was an error in the SQL insert statement
	 */
	public static int insert(Connection connection, Long idAuthor, String txtIdAuthor, String nmAuthor, String nmUsername, String txtBio, String txtUrlCacheImage) throws SQLException {
		try (PreparedStatement preparedStatement = connection.prepareStatement(SQL_BUILTIN_INSERT_VALUES)) {
			ConnectionManager.setBigint(preparedStatement, 1, idAuthor);
			ConnectionManager.setBigint(preparedStatement, 2, null);
			ConnectionManager.setVarchar(preparedStatement, 3, txtIdAuthor);
			ConnectionManager.setVarchar(preparedStatement, 4, nmAuthor);
			ConnectionManager.setVarchar(preparedStatement, 5, nmUsername);
			ConnectionManager.setVarchar(preparedStatement, 6, txtBio);
			ConnectionManager.setVarchar(preparedStatement, 7, txtUrlCacheImage);
			ConnectionManager.setBigint(preparedStatement, 8, null);
			ConnectionManager.setBigint(preparedStatement, 9, null);
			ConnectionManager.setDatetime(preparedStatement, 10, null);
			ConnectionManager.setBoolean(preparedStatement, 11, null);
			ConnectionManager.setBoolean(preparedStatement, 12, null);
			ConnectionManager.setBoolean(preparedStatement, 13, null);
			return(preparedStatement.executeUpdate());
		}
	}

	/**
	 * Insert a new Author into the database a new connection will be retrieved 
	 * from the pool, used and then closed.
	 * 
	 * @param idAuthor  maps to id_author
	 * @param idAuthorStatus  maps to id_author_status
	 * @param txtIdAuthor  maps to txt_id_author
	 * @param nmAuthor  maps to nm_author
	 * @param nmUsername  maps to nm_username
	 * @param txtBio  maps to txt_bio
	 * @param txtUrlCacheImage  maps to txt_url_cache_image
	 * @param numFollowing  maps to num_following
	 * @param numFollowers  maps to num_followers
	 * @param dtmStartedFollowing  maps to dtm_started_following
	 * @param flIsUpdating  maps to fl_is_updating
	 * @param flAuthorIsFollowingUser  maps to fl_author_is_following_user
	 * @param flAuthorIsFollowedByUser  maps to fl_author_is_followed_by_user
	 * 
	 * @return the number of rows that were inserted, or -1 if an error occurred
	 * 
	 * @throws SQLException if there was an error in the SQL insert statement
	 */
	public static int insert(Long idAuthor, Long idAuthorStatus, String txtIdAuthor, String nmAuthor, String nmUsername, String txtBio, String txtUrlCacheImage, Long numFollowing, Long numFollowers, Timestamp dtmStartedFollowing, Boolean flIsUpdating, Boolean flAuthorIsFollowingUser, Boolean flAuthorIsFollowedByUser) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(insert(connection, idAuthor, idAuthorStatus, txtIdAuthor, nmAuthor, nmUsername, txtBio, txtUrlCacheImage, numFollowing, numFollowers, dtmStartedFollowing, flIsUpdating, flAuthorIsFollowingUser, flAuthorIsFollowedByUser));
		}
	}

	/**
	 * Insert a new Author into the database a new connection will be retrieved 
	 * from the pool, used and then closed. This is for fields which have a nullable allowed default
	 * 
	 * @param idAuthor  maps to id_author
	 * @param txtIdAuthor  maps to txt_id_author
	 * @param nmAuthor  maps to nm_author
	 * @param nmUsername  maps to nm_username
	 * @param txtBio  maps to txt_bio
	 * @param txtUrlCacheImage  maps to txt_url_cache_image
	 * 
	 * @return the number of rows that were inserted, or -1 if an error occurred
	 * 
	 * @throws SQLException if there was an error in the SQL insert statement
	 */
	public static int insert(Long idAuthor, String txtIdAuthor, String nmAuthor, String nmUsername, String txtBio, String txtUrlCacheImage) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(insert(connection, idAuthor, txtIdAuthor, nmAuthor, nmUsername, txtBio, txtUrlCacheImage));
		}
	}

	/**
	 * Silently (i.e. swallow any exceptions) Insert a new Author into the 
	 * database utilising the passed in connection. If an exception is thrown by the
	 * method, the exception message will be logged as an 'error', if 'trace' logging
	 * is enabled, the stack trace will be printed to the output stream.
	 * 
	 * @param connection the connection to use for the database, this __MUST__ be 
	 *   closed by the calling function.
	 * @param idAuthor  maps to id_author
	 * @param idAuthorStatus  maps to id_author_status
	 * @param txtIdAuthor  maps to txt_id_author
	 * @param nmAuthor  maps to nm_author
	 * @param nmUsername  maps to nm_username
	 * @param txtBio  maps to txt_bio
	 * @param txtUrlCacheImage  maps to txt_url_cache_image
	 * @param numFollowing  maps to num_following
	 * @param numFollowers  maps to num_followers
	 * @param dtmStartedFollowing  maps to dtm_started_following
	 * @param flIsUpdating  maps to fl_is_updating
	 * @param flAuthorIsFollowingUser  maps to fl_author_is_following_user
	 * @param flAuthorIsFollowedByUser  maps to fl_author_is_followed_by_user
	 * 
	 * @return the number of rows that were inserted, or -1 if an error occurred
	 */
	public static int insertSilent(Connection connection, Long idAuthor, Long idAuthorStatus, String txtIdAuthor, String nmAuthor, String nmUsername, String txtBio, String txtUrlCacheImage, Long numFollowing, Long numFollowers, Timestamp dtmStartedFollowing, Boolean flIsUpdating, Boolean flAuthorIsFollowingUser, Boolean flAuthorIsFollowedByUser) {
		try {
			return(insert(connection, idAuthor, idAuthorStatus, txtIdAuthor, nmAuthor, nmUsername, txtBio, txtUrlCacheImage, numFollowing, numFollowers, dtmStartedFollowing, flIsUpdating, flAuthorIsFollowingUser, flAuthorIsFollowedByUser));
		} catch (SQLException sqlex) {
			LOGGER.error("SQLException caught, message was: {}", sqlex.getMessage());
			if(LOGGER.isTraceEnabled()){
				sqlex.printStackTrace();
			}
			return(-1);
		}
	}

	/**
	 * Silently (i.e. swallow any exceptions) Insert a new Author into the 
	 * database utilising the passed in connection. If an exception is thrown by the
	 * method, the exception message will be logged as an 'error', if 'trace' logging
	 * is enabled, the stack trace will be printed to the output stream.
	 * 
	 * This is only for Non-Nullable fields
	 * 
	 * @param connection the connection to use for the database, this __MUST__ be 
	 *   closed by the calling function.
	 * @param idAuthor  maps to id_author
	 * @param txtIdAuthor  maps to txt_id_author
	 * @param nmAuthor  maps to nm_author
	 * @param nmUsername  maps to nm_username
	 * @param txtBio  maps to txt_bio
	 * @param txtUrlCacheImage  maps to txt_url_cache_image
	 * 
	 * @return the number of rows that were inserted, or -1 if an error occurred
	 */
	public static int insertSilent(Connection connection, Long idAuthor, String txtIdAuthor, String nmAuthor, String nmUsername, String txtBio, String txtUrlCacheImage) {
		try {
			return(insert(connection, idAuthor, txtIdAuthor, nmAuthor, nmUsername, txtBio, txtUrlCacheImage));
		} catch (SQLException sqlex) {
			LOGGER.error("SQLException caught, message was: {}", sqlex.getMessage());
			if(LOGGER.isTraceEnabled()){
				sqlex.printStackTrace();
			}
			return(-1);
		}
	}

	/**
	 * Silently (i.e. swallow any exceptions) Insert a new Author into the 
	 * database, creating and closing a connection in the process. If an exception is thrown 
	 * by the method, the exception message will be logged as an 'error', if 'trace' logging
	 * is enabled, the stack trace will be printed to the output stream.
	 * 
	 * @param idAuthor  maps to id_author
	 * @param idAuthorStatus  maps to id_author_status
	 * @param txtIdAuthor  maps to txt_id_author
	 * @param nmAuthor  maps to nm_author
	 * @param nmUsername  maps to nm_username
	 * @param txtBio  maps to txt_bio
	 * @param txtUrlCacheImage  maps to txt_url_cache_image
	 * @param numFollowing  maps to num_following
	 * @param numFollowers  maps to num_followers
	 * @param dtmStartedFollowing  maps to dtm_started_following
	 * @param flIsUpdating  maps to fl_is_updating
	 * @param flAuthorIsFollowingUser  maps to fl_author_is_following_user
	 * @param flAuthorIsFollowedByUser  maps to fl_author_is_followed_by_user
	 * 
	 * @return the number of rows that were inserted, or -1 if an error occurred
	 */
	public static int insertSilent(Long idAuthor, Long idAuthorStatus, String txtIdAuthor, String nmAuthor, String nmUsername, String txtBio, String txtUrlCacheImage, Long numFollowing, Long numFollowers, Timestamp dtmStartedFollowing, Boolean flIsUpdating, Boolean flAuthorIsFollowingUser, Boolean flAuthorIsFollowedByUser) {
		try (Connection connection = ConnectionManager.getConnection()){
			return(insert(connection, idAuthor, idAuthorStatus, txtIdAuthor, nmAuthor, nmUsername, txtBio, txtUrlCacheImage, numFollowing, numFollowers, dtmStartedFollowing, flIsUpdating, flAuthorIsFollowingUser, flAuthorIsFollowedByUser));
		} catch (SQLException sqlex) {
			LOGGER.error("SQLException caught, message was: {}", sqlex.getMessage());
			if(LOGGER.isTraceEnabled()){
				sqlex.printStackTrace();
			}
			return(-1);
		}
	}

	/**
	 * Silently (i.e. swallow any exceptions) Insert a new Author into the 
	 * database, creating and closing a connection in the process. If an exception is thrown 
	 * by the method, the exception message will be logged as an 'error', if 'trace' logging
	 * is enabled, the stack trace will be printed to the output stream.
	 * 
	 * This is for non-nullable fields only
	 * 
	 * @param idAuthor  maps to id_author
	 * @param txtIdAuthor  maps to txt_id_author
	 * @param nmAuthor  maps to nm_author
	 * @param nmUsername  maps to nm_username
	 * @param txtBio  maps to txt_bio
	 * @param txtUrlCacheImage  maps to txt_url_cache_image
	 * 
	 * @return the number of rows that were inserted, or -1 if an error occurred
	 */
	public static int insertSilent(Long idAuthor, String txtIdAuthor, String nmAuthor, String nmUsername, String txtBio, String txtUrlCacheImage) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(insert(connection, idAuthor, txtIdAuthor, nmAuthor, nmUsername, txtBio, txtUrlCacheImage));
		} catch (SQLException sqlex) {
			LOGGER.error("SQLException caught, message was: {}", sqlex.getMessage());
			if(LOGGER.isTraceEnabled()){
				sqlex.printStackTrace();
			}
			return(-1);
		}
	}

}