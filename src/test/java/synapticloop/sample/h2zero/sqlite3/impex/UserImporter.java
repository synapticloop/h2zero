package synapticloop.sample.h2zero.sqlite3.impex;

// - - - - thoughtfully generated by synapticloop h2zero - - - - 
//    with the use of synapticloop templar templating language
//                 (/impex/impex-importer.templar)

import synapticloop.h2zero.exception.H2ZeroParseException;
import synapticloop.h2zero.base.manager.sqlite3.ConnectionManager;
import synapticloop.sample.h2zero.sqlite3.model.User;
import synapticloop.sample.h2zero.sqlite3.finder.UserTypeFinder;
import synapticloop.sample.h2zero.sqlite3.model.UserType;

import java.math.*;
import java.sql.*;
import java.util.HashMap;
import java.util.Map;

public class UserImporter {
	// The primary key cache is keyed on the id from the imported line -> value 
	// is the actual inserted value - which may be the same 
	public static final Map<Long, Long> PRIMARY_KEY_CACHE = new HashMap<>();

	// unique field nmUsername
	private static final String SQL_SELECT_START_nmUsername ="select id_user, id_user_type, fl_is_alive, num_age, nm_username, txt_address_email, txt_password, dtm_signup from user where nm_username = ?";

	// unique field txtAddressEmail
	private static final String SQL_SELECT_START_txtAddressEmail ="select id_user, id_user_type, fl_is_alive, num_age, nm_username, txt_address_email, txt_password, dtm_signup from user where txt_address_email = ?";

	private static final String SQL_SELECT_UNIQUE = "";
	public static void importLine(String line) throws H2ZeroParseException {
		String[] splits = line.split("\t");
		if(splits.length != 8) {
			// we don't have enough tokens to import - we always import every field
			throw new H2ZeroParseException(String.format("Insufficient fields, found '%d', required '%d'",8 , splits.length));
		}

		// we are good to go
		// for each field - we parse the value
		Long idUser = ImpexConverter.convertLong(splits[0], false);
		Long idUserType = ImpexConverter.convertLong(splits[1], false);
		Boolean flIsAlive = ImpexConverter.convertBoolean(splits[2], true);
		Integer numAge = ImpexConverter.convertInteger(splits[3], false);
		String nmUsername = ImpexConverter.convertString(splits[4], false);
		String txtAddressEmail = ImpexConverter.convertString(splits[5], false);
		String txtPassword = ImpexConverter.convertString(splits[6], false);
		Timestamp dtmSignup = ImpexConverter.convertTimestamp(splits[7], true);

		if(confirmExisting(idUser, idUserType, flIsAlive, numAge, nmUsername, txtAddressEmail, txtPassword, dtmSignup)) {
			return;
		}
// nm_username
// txt_address_email
	}


	// IMPORT 'find-existing.templar' START

	/**
	 * Confirm whether there is an existing table with all of the fields matching 
	 * (apart from the primary key)
	 * 
	 * @param idUser The id_user which is used as the lookup
	 * @param idUserType The id_user_type which is used as the lookup
	 * @param flIsAlive The fl_is_alive which is used as the lookup
	 * @param numAge The num_age which is used as the lookup
	 * @param nmUsername The nm_username which is used as the lookup
	 * @param txtAddressEmail The txt_address_email which is used as the lookup
	 * @param txtPassword The txt_password which is used as the lookup
	 * @param dtmSignup The dtm_signup which is used as the lookup
	 * 
	 * @return whether we were able to find the exact duplicat of this table row
	 * 
	 * @throws H2ZeroParseException - if there was a SQLException, or this is a 
	 * constant table and we couldn't look up the constant value
	 */
	private static boolean confirmExisting(Long idUser, Long idUserType, Boolean flIsAlive, Integer numAge, String nmUsername, String txtAddressEmail, String txtPassword, Timestamp dtmSignup) throws H2ZeroParseException {
		StringBuilder SQL_FIND_EXACT = new StringBuilder("select * from user where ");
		if (null == idUserType) {
			SQL_FIND_EXACT.append(" id_user_type is null");
		} else {
			SQL_FIND_EXACT.append(" id_user_type = ?");
		}
		SQL_FIND_EXACT.append(" and ");
		if (null == flIsAlive) {
			SQL_FIND_EXACT.append(" fl_is_alive is null");
		} else {
			SQL_FIND_EXACT.append(" fl_is_alive = ?");
		}
		SQL_FIND_EXACT.append(" and ");
		if (null == numAge) {
			SQL_FIND_EXACT.append(" num_age is null");
		} else {
			SQL_FIND_EXACT.append(" num_age = ?");
		}
		SQL_FIND_EXACT.append(" and ");
		if (null == nmUsername) {
			SQL_FIND_EXACT.append(" nm_username is null");
		} else {
			SQL_FIND_EXACT.append(" nm_username = ?");
		}
		SQL_FIND_EXACT.append(" and ");
		if (null == txtAddressEmail) {
			SQL_FIND_EXACT.append(" txt_address_email is null");
		} else {
			SQL_FIND_EXACT.append(" txt_address_email = ?");
		}
		SQL_FIND_EXACT.append(" and ");
		if (null == txtPassword) {
			SQL_FIND_EXACT.append(" txt_password is null");
		} else {
			SQL_FIND_EXACT.append(" txt_password = ?");
		}
		SQL_FIND_EXACT.append(" and ");
		if (null == dtmSignup) {
			SQL_FIND_EXACT.append(" dtm_signup is null");
		} else {
			SQL_FIND_EXACT.append(" dtm_signup = ?");
		}
		ResultSet resultSetExact = null;
		// now set all of the parameters
		try (Connection connection = ConnectionManager.getConnection();
				 PreparedStatement preparedStatement = connection.prepareStatement(SQL_FIND_EXACT.toString())) {
			resultSetExact = preparedStatement.getResultSet();
			if(resultSetExact.next()) {
				// we have found one, this means that we do not need to import it
				// just update the primary key cache
				PRIMARY_KEY_CACHE.put(idUser, resultSetExact.getLong(1));
				return(true);
			} else {
				// fall through and see if we can find it by some other means...
			}
		} catch (SQLException e) {
			throw new H2ZeroParseException(String.format("Could not execute the SQL statement.  Exception, message was: '%s'", e.getMessage()), e);
		} finally {
			if(null != resultSetExact) {
				try { resultSetExact.close(); } catch (SQLException e) { /* do nothing */ }
			}
		}

		return(false);
	}
	// IMPORT 'find-existing.templar' END





		// IMPORT 'find-unique.templar' START

	public static void findUniqueNmUsername(Long idUser, Long idUserType, Boolean flIsAlive, Integer numAge, String nmUsername, String txtAddressEmail, String txtPassword, Timestamp dtmSignup) throws H2ZeroParseException {
		 // unique field dtmSignup
		User user;
		ResultSet resultSet;
		try (Connection connection = ConnectionManager.getConnection();
				 PreparedStatement preparedStatement = connection.prepareStatement(SQL_SELECT_START_nmUsername)) {
			ConnectionManager.setVarchar(preparedStatement, 1, nmUsername);
			resultSet = preparedStatement.getResultSet();
			if(resultSet.next()) {
				// we have found one, load it up
				user = new User(
					ConnectionManager.getNullableResultLong(resultSet, 1), 
					ConnectionManager.getNullableResultLong(resultSet, 2), 
					ConnectionManager.getNullableResultBoolean(resultSet, 3), 
					ConnectionManager.getNullableResultInt(resultSet, 4), 
					ConnectionManager.getNullableResultString(resultSet, 5), 
					ConnectionManager.getNullableResultString(resultSet, 6), 
					ConnectionManager.getNullableResultString(resultSet, 7), 
					ConnectionManager.getNullableResultTimestamp(resultSet, 8)
				);
				// now set all of the fields that we have
				PRIMARY_KEY_CACHE.put(idUser, user.getPrimaryKey());
			} else {
				user = new User(null, idUserType, flIsAlive, numAge, nmUsername, txtAddressEmail, txtPassword, dtmSignup);
				// id_user_type is a foreign key - look it up to make sure that it exists
				if(null != idUserType) {
					Long idUserTypeLookup = UserTypeImporter.PRIMARY_KEY_CACHE.get(idUserType);
					if(null == idUserTypeLookup) {
						// we don't have a lookup - which is OK
						idUserTypeLookup = idUserType;
					}
					UserType userType = UserTypeFinder.findByPrimaryKeySilent(idUserTypeLookup);

					if(null == userType) {
						throw new H2ZeroParseException(String.format("Could not find the foreignKey for author_status.id_author_status of '%d'", idUserTypeLookup));
					}

					user.setIdUserType(userType.getPrimaryKey());
				}
				user.insertSilent();
			}
		} catch (SQLException e) {
			throw new RuntimeException(e);
		}
	}
	public static void findUniqueTxtAddressEmail(Long idUser, Long idUserType, Boolean flIsAlive, Integer numAge, String nmUsername, String txtAddressEmail, String txtPassword, Timestamp dtmSignup) throws H2ZeroParseException {
		 // unique field dtmSignup
		User user;
		ResultSet resultSet;
		try (Connection connection = ConnectionManager.getConnection();
				 PreparedStatement preparedStatement = connection.prepareStatement(SQL_SELECT_START_txtAddressEmail)) {
			ConnectionManager.setVarchar(preparedStatement, 1, txtAddressEmail);
			resultSet = preparedStatement.getResultSet();
			if(resultSet.next()) {
				// we have found one, load it up
				user = new User(
					ConnectionManager.getNullableResultLong(resultSet, 1), 
					ConnectionManager.getNullableResultLong(resultSet, 2), 
					ConnectionManager.getNullableResultBoolean(resultSet, 3), 
					ConnectionManager.getNullableResultInt(resultSet, 4), 
					ConnectionManager.getNullableResultString(resultSet, 5), 
					ConnectionManager.getNullableResultString(resultSet, 6), 
					ConnectionManager.getNullableResultString(resultSet, 7), 
					ConnectionManager.getNullableResultTimestamp(resultSet, 8)
				);
				// now set all of the fields that we have
				PRIMARY_KEY_CACHE.put(idUser, user.getPrimaryKey());
			} else {
				user = new User(null, idUserType, flIsAlive, numAge, nmUsername, txtAddressEmail, txtPassword, dtmSignup);
				// id_user_type is a foreign key - look it up to make sure that it exists
				if(null != idUserType) {
					Long idUserTypeLookup = UserTypeImporter.PRIMARY_KEY_CACHE.get(idUserType);
					if(null == idUserTypeLookup) {
						// we don't have a lookup - which is OK
						idUserTypeLookup = idUserType;
					}
					UserType userType = UserTypeFinder.findByPrimaryKeySilent(idUserTypeLookup);

					if(null == userType) {
						throw new H2ZeroParseException(String.format("Could not find the foreignKey for author_status.id_author_status of '%d'", idUserTypeLookup));
					}

					user.setIdUserType(userType.getPrimaryKey());
				}
				user.insertSilent();
			}
		} catch (SQLException e) {
			throw new RuntimeException(e);
		}
	}
// we have a unique field 

		// IMPORT 'find-unique.templar' END





	/**
	 * Clear the primary key cache, ready for data importing 
	 */
	public static void clearPrimaryKeyCache() {
		PRIMARY_KEY_CACHE.clear();
	}
}