package synapticloop.sample.h2zero.sqlite3.deleter;

// - - - - thoughtfully generated by synapticloop h2zero - - - - 
//    with the use of synapticloop templar templating language
//                (java-create-deleter.templar)

import java.sql.Connection;
import java.sql.Timestamp;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.*;
import java.math.BigDecimal;
import java.util.List;
import java.util.ArrayList;
import synapticloop.h2zero.util.LruCache;

import synapticloop.h2zero.base.manager.sqlite3.ConnectionManager;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


import synapticloop.sample.h2zero.sqlite3.model.util.Constants;

public class AllTypesDeleter {
	// the binder is unused in code, but will generate compile problems if this 
	// class is no longer referenced in the h2zero file. Just a nicety for
	// removing dead code
	@SuppressWarnings("unused")
	private static final String BINDER = Constants.ALL_TYPES_BINDER;

	private static final Logger LOGGER = LoggerFactory.getLogger(AllTypesDeleter.class);

	// static fields generated by synapticloop h2zero
	private static final String SQL_BUILTIN_DELETE_ALL = "delete from all_types";
	private static final String SQL_DELETE_START = "delete from all_types ";
	private static final String SQL_BUILTIN_DELETE_BY_PRIMARY_KEY = SQL_DELETE_START + "where id_all_types = ?";

	// static fields generated from the user input
	private static final String SQL_DELETE_BY_ID_ALL_TYPES = SQL_DELETE_START + " where id_all_types = ?";
	private static final String SQL_DELETE_BY_TEST_BIGINT = SQL_DELETE_START + " where test_bigint = ?";
	private static final String SQL_DELETE_BY_TEST_BOOLEAN = SQL_DELETE_START + " where test_boolean = ?";
	private static final String SQL_DELETE_BY_TEST_DATE = SQL_DELETE_START + " where test_date = ?";
	private static final String SQL_DELETE_BY_TEST_DATETIME = SQL_DELETE_START + " where test_datetime = ?";
	private static final String SQL_DELETE_BY_TEST_DOUBLE = SQL_DELETE_START + " where test_double = ?";
	private static final String SQL_DELETE_BY_TEST_FLOAT = SQL_DELETE_START + " where test_float = ?";
	private static final String SQL_DELETE_BY_TEST_INT = SQL_DELETE_START + " where test_int = ?";
	private static final String SQL_DELETE_BY_TEST_INTEGER = SQL_DELETE_START + " where test_integer = ?";
	private static final String SQL_DELETE_BY_TEST_MEDIUMINT = SQL_DELETE_START + " where test_mediumint = ?";
	private static final String SQL_DELETE_BY_TEST_NUMERIC = SQL_DELETE_START + " where test_numeric = ?";
	private static final String SQL_DELETE_BY_TEST_SMALLINT = SQL_DELETE_START + " where test_smallint = ?";
	private static final String SQL_DELETE_BY_TEST_TEXT = SQL_DELETE_START + " where test_text = ?";
	private static final String SQL_DELETE_BY_TEST_TINYINT = SQL_DELETE_START + " where test_tinyint = ?";
	private static final String SQL_DELETE_BY_TEST_VARCHAR = SQL_DELETE_START + " where test_varchar = ?";
	// now for the statement limit cache(s)
	private static final LruCache<String, String> deleteAll_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByIdAllTypes_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByTestBigint_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByTestBoolean_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByTestDate_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByTestDatetime_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByTestDouble_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByTestFloat_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByTestInt_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByTestInteger_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByTestMediumint_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByTestNumeric_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByTestSmallint_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByTestText_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByTestTinyint_limit_statement_cache = new LruCache<>(1024);
	private static final LruCache<String, String> deleteByTestVarchar_limit_statement_cache = new LruCache<>(1024);

	// We don't allow instantiation
	private AllTypesDeleter() {}

 	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 	 * 
 	 * The following deleters are built in by h2zero and are always generated 
 	 * 
 	 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

	/**
	 * Delete a row in the ALL_TYPES table by its primary key
	 * 
	 * @param connection The connection to use - the caller must close this connection
	 * @param idAllTypes the primary key to delete
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the delete
	 */
	public static int deleteByPrimaryKey(Connection connection, Long idAllTypes) throws SQLException {
		try (PreparedStatement preparedStatement = connection.prepareStatement(SQL_BUILTIN_DELETE_BY_PRIMARY_KEY)) {
		preparedStatement.setLong(1, idAllTypes);
			return(preparedStatement.executeUpdate());
		}
	}

	/**
	 * Delete a row in the ALL_TYPES table by its primary key
	 * 
	 * @param idAllTypes the primary key to delete
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the delete
	 */
	public static int deleteByPrimaryKey(Long idAllTypes) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByPrimaryKey(connection, idAllTypes));
		}
	}

	/**
	 * Delete a row in the ALL_TYPES table by its primary key silently
	 * (i.e. don't throw an exception if it couldn't be deleted).
	 * 
	 * @param connection - the connection to use - the caller must close this connection
	 * @param idAllTypes the primary key to delete
	 * 
	 * @return the number of rows deleted
	 */
	public static int deleteByPrimaryKeySilent(Connection connection, Long idAllTypes) {
		try {
			return(deleteByPrimaryKey(connection, idAllTypes));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByPrimaryKey, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	/**
	 * Delete a row in the ALL_TYPES table by its primary key silently
	 * (i.e. don't throw an exception if it coudn't be deleted).
	 * 
	 * @param idAllTypes the primary key to delete
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByPrimaryKeySilent(Long idAllTypes) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByPrimaryKeySilent(connection, idAllTypes));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByPrimaryKey, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	/**
	 * Delete all of the rows in the table 'all_types'.
	 * 
	 * This database does not have the 'truncate' keyword hence the 'DELETE FROM' SQL
	 * statement is used
	 * 
	 * @param connection - the connection to use - the caller must close this connection
	 * 
	 * @return The number of rows affected by this statement
	 */
	public static int deleteAll(Connection connection) throws SQLException {
		try (PreparedStatement preparedStatement = connection.prepareStatement(SQL_BUILTIN_DELETE_ALL)) {
			return(preparedStatement.executeUpdate());
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteAll, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	/**
	 * Delete all the rows in the ALL_TYPES table
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the delete
	 */
	public static int deleteAll() throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteAll(connection));
		}
	}

	/**
	 * Delete all the rows in the ALL_TYPES table silently - i.e
	 * swallow any SQL exceptions
	 * 
	 * @param connection - the connection to use - the caller must close this connection
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteAllSilent(Connection connection) {
		try {
			return(deleteAll(connection));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteAll, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	/**
	 * Delete all the rows in the ALL_TYPES table silently - i.e
	 * swallow any SQL exceptions
	 * 
	 * @return the number of rows deleted, or -1 if there was an error
	 */
	public static int deleteAllSilent() {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteAll(connection));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteAll, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * 
	 *     USER DEFINED DELETERS FOR THE TABLE: all_types
	 * 
	 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * 
	 * This is the start of the user defined Deleters which are generated
	 * through either the "deleters" JSON key, or the "fieldDeleters" JSON
	 * key.
	 * 
	 * There are 15 defined Deleters on the all_types table:
	 * 
	 * - deleteByIdAllTypes - 'fieldDeleters' JSON key 
	 * - deleteByTestBigint - 'fieldDeleters' JSON key 
	 * - deleteByTestBoolean - 'fieldDeleters' JSON key 
	 * - deleteByTestDate - 'fieldDeleters' JSON key 
	 * - deleteByTestDatetime - 'fieldDeleters' JSON key 
	 * - deleteByTestDouble - 'fieldDeleters' JSON key 
	 * - deleteByTestFloat - 'fieldDeleters' JSON key 
	 * - deleteByTestInt - 'fieldDeleters' JSON key 
	 * - deleteByTestInteger - 'fieldDeleters' JSON key 
	 * - deleteByTestMediumint - 'fieldDeleters' JSON key 
	 * - deleteByTestNumeric - 'fieldDeleters' JSON key 
	 * - deleteByTestSmallint - 'fieldDeleters' JSON key 
	 * - deleteByTestText - 'fieldDeleters' JSON key 
	 * - deleteByTestTinyint - 'fieldDeleters' JSON key 
	 * - deleteByTestVarchar - 'fieldDeleters' JSON key 
	 * 
	 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

	/**
	 * deleteByIdAllTypes - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param idAllTypes - maps to the id_all_types field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByIdAllTypes(Connection connection, Long idAllTypes, Integer limit) throws SQLException {
		String cacheKey = limit  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByIdAllTypes_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_ID_ALL_TYPES);

			if(null != limit) {
				stringBuilder.append(" limit ");
				stringBuilder.append(limit);
			}

			statement = stringBuilder.toString();
			deleteByIdAllTypes_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByIdAllTypes_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setBigint(preparedStatement, 1, idAllTypes);

			return(preparedStatement.executeUpdate());
		}
	}

	/**
	 * deleteByTestBigint - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testBigint - maps to the test_bigint field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestBigint(Connection connection, Long testBigint, Integer limit) throws SQLException {
		String cacheKey = limit  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByTestBigint_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_TEST_BIGINT);

			if(null != limit) {
				stringBuilder.append(" limit ");
				stringBuilder.append(limit);
			}

			statement = stringBuilder.toString();
			deleteByTestBigint_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByTestBigint_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setBigint(preparedStatement, 1, testBigint);

			return(preparedStatement.executeUpdate());
		}
	}

	/**
	 * deleteByTestBoolean - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testBoolean - maps to the test_boolean field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestBoolean(Connection connection, Boolean testBoolean, Integer limit) throws SQLException {
		String cacheKey = limit  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByTestBoolean_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_TEST_BOOLEAN);

			if(null != limit) {
				stringBuilder.append(" limit ");
				stringBuilder.append(limit);
			}

			statement = stringBuilder.toString();
			deleteByTestBoolean_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByTestBoolean_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setBoolean(preparedStatement, 1, testBoolean);

			return(preparedStatement.executeUpdate());
		}
	}

	/**
	 * deleteByTestDate - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testDate - maps to the test_date field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestDate(Connection connection, Date testDate, Integer limit) throws SQLException {
		String cacheKey = limit  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByTestDate_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_TEST_DATE);

			if(null != limit) {
				stringBuilder.append(" limit ");
				stringBuilder.append(limit);
			}

			statement = stringBuilder.toString();
			deleteByTestDate_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByTestDate_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setDate(preparedStatement, 1, testDate);

			return(preparedStatement.executeUpdate());
		}
	}

	/**
	 * deleteByTestDatetime - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testDatetime - maps to the test_datetime field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestDatetime(Connection connection, Timestamp testDatetime, Integer limit) throws SQLException {
		String cacheKey = limit  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByTestDatetime_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_TEST_DATETIME);

			if(null != limit) {
				stringBuilder.append(" limit ");
				stringBuilder.append(limit);
			}

			statement = stringBuilder.toString();
			deleteByTestDatetime_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByTestDatetime_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setDatetime(preparedStatement, 1, testDatetime);

			return(preparedStatement.executeUpdate());
		}
	}

	/**
	 * deleteByTestDouble - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testDouble - maps to the test_double field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestDouble(Connection connection, Double testDouble, Integer limit) throws SQLException {
		String cacheKey = limit  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByTestDouble_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_TEST_DOUBLE);

			if(null != limit) {
				stringBuilder.append(" limit ");
				stringBuilder.append(limit);
			}

			statement = stringBuilder.toString();
			deleteByTestDouble_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByTestDouble_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setDouble(preparedStatement, 1, testDouble);

			return(preparedStatement.executeUpdate());
		}
	}

	/**
	 * deleteByTestFloat - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testFloat - maps to the test_float field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestFloat(Connection connection, Float testFloat, Integer limit) throws SQLException {
		String cacheKey = limit  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByTestFloat_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_TEST_FLOAT);

			if(null != limit) {
				stringBuilder.append(" limit ");
				stringBuilder.append(limit);
			}

			statement = stringBuilder.toString();
			deleteByTestFloat_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByTestFloat_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setFloat(preparedStatement, 1, testFloat);

			return(preparedStatement.executeUpdate());
		}
	}

	/**
	 * deleteByTestInt - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testInt - maps to the test_int field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestInt(Connection connection, Integer testInt, Integer limit) throws SQLException {
		String cacheKey = limit  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByTestInt_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_TEST_INT);

			if(null != limit) {
				stringBuilder.append(" limit ");
				stringBuilder.append(limit);
			}

			statement = stringBuilder.toString();
			deleteByTestInt_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByTestInt_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setInt(preparedStatement, 1, testInt);

			return(preparedStatement.executeUpdate());
		}
	}

	/**
	 * deleteByTestInteger - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testInteger - maps to the test_integer field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestInteger(Connection connection, Integer testInteger, Integer limit) throws SQLException {
		String cacheKey = limit  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByTestInteger_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_TEST_INTEGER);

			if(null != limit) {
				stringBuilder.append(" limit ");
				stringBuilder.append(limit);
			}

			statement = stringBuilder.toString();
			deleteByTestInteger_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByTestInteger_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setInteger(preparedStatement, 1, testInteger);

			return(preparedStatement.executeUpdate());
		}
	}

	/**
	 * deleteByTestMediumint - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testMediumint - maps to the test_mediumint field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestMediumint(Connection connection, Integer testMediumint, Integer limit) throws SQLException {
		String cacheKey = limit  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByTestMediumint_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_TEST_MEDIUMINT);

			if(null != limit) {
				stringBuilder.append(" limit ");
				stringBuilder.append(limit);
			}

			statement = stringBuilder.toString();
			deleteByTestMediumint_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByTestMediumint_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setMediumint(preparedStatement, 1, testMediumint);

			return(preparedStatement.executeUpdate());
		}
	}

	/**
	 * deleteByTestNumeric - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testNumeric - maps to the test_numeric field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestNumeric(Connection connection, BigDecimal testNumeric, Integer limit) throws SQLException {
		String cacheKey = limit  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByTestNumeric_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_TEST_NUMERIC);

			if(null != limit) {
				stringBuilder.append(" limit ");
				stringBuilder.append(limit);
			}

			statement = stringBuilder.toString();
			deleteByTestNumeric_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByTestNumeric_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setNumeric(preparedStatement, 1, testNumeric);

			return(preparedStatement.executeUpdate());
		}
	}

	/**
	 * deleteByTestSmallint - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testSmallint - maps to the test_smallint field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestSmallint(Connection connection, Short testSmallint, Integer limit) throws SQLException {
		String cacheKey = limit  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByTestSmallint_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_TEST_SMALLINT);

			if(null != limit) {
				stringBuilder.append(" limit ");
				stringBuilder.append(limit);
			}

			statement = stringBuilder.toString();
			deleteByTestSmallint_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByTestSmallint_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setSmallint(preparedStatement, 1, testSmallint);

			return(preparedStatement.executeUpdate());
		}
	}

	/**
	 * deleteByTestText - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testText - maps to the test_text field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestText(Connection connection, String testText, Integer limit) throws SQLException {
		String cacheKey = limit  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByTestText_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_TEST_TEXT);

			if(null != limit) {
				stringBuilder.append(" limit ");
				stringBuilder.append(limit);
			}

			statement = stringBuilder.toString();
			deleteByTestText_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByTestText_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setText(preparedStatement, 1, testText);

			return(preparedStatement.executeUpdate());
		}
	}

	/**
	 * deleteByTestTinyint - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testTinyint - maps to the test_tinyint field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestTinyint(Connection connection, Boolean testTinyint, Integer limit) throws SQLException {
		String cacheKey = limit  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByTestTinyint_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_TEST_TINYINT);

			if(null != limit) {
				stringBuilder.append(" limit ");
				stringBuilder.append(limit);
			}

			statement = stringBuilder.toString();
			deleteByTestTinyint_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByTestTinyint_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setTinyint(preparedStatement, 1, testTinyint);

			return(preparedStatement.executeUpdate());
		}
	}

	/**
	 * deleteByTestVarchar - from 'fieldDeleters' JSON key
	 *
	 * This is the main method for all other deleter methods with the same prefix,
	 * including the (silent method signatures).  All methods chain to this one.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testVarchar - maps to the test_varchar field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestVarchar(Connection connection, String testVarchar, Integer limit) throws SQLException {
		String cacheKey = limit  + "";
		boolean hasConnection = (null != connection);
		String statement = null;
		if(!deleteByTestVarchar_limit_statement_cache.containsKey(cacheKey)) {
			// place the cacheKey in the cache for later use

			StringBuilder stringBuilder = new StringBuilder(SQL_DELETE_BY_TEST_VARCHAR);

			if(null != limit) {
				stringBuilder.append(" limit ");
				stringBuilder.append(limit);
			}

			statement = stringBuilder.toString();
			deleteByTestVarchar_limit_statement_cache.put(cacheKey, statement);
		} else {
			statement = deleteByTestVarchar_limit_statement_cache.get(cacheKey);
		}

		if(!hasConnection) {
			connection = ConnectionManager.getConnection();
		}
		try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {
			ConnectionManager.setVarchar(preparedStatement, 1, testVarchar);

			return(preparedStatement.executeUpdate());
		}
	}

	/**
	 * deleteByIdAllTypes - from 'fieldDeleters' JSON key
	 *
	 * @param idAllTypes - maps to the id_all_types field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByIdAllTypes(Long idAllTypes, Integer limit) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByIdAllTypes(connection, idAllTypes, limit));
		}
	}

	/**
	 * deleteByIdAllTypes - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param idAllTypes - maps to the id_all_types field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */

	public static int deleteByIdAllTypesSilent(Long idAllTypes) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByIdAllTypes(connection, idAllTypes, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByIdAllTypes, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	/**
	 * deleteByIdAllTypes - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param idAllTypes - maps to the id_all_types field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByIdAllTypesSilent(Connection connection, Long idAllTypes) {
		try {
			return(deleteByIdAllTypes(connection, idAllTypes, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByIdAllTypes, a SQL Exception occurred.", ex);
			return(-1);
		}
	}
	/**
	 * deleteByIdAllTypes - from 'fieldDeleters' JSON key.
	 * 
	 * @param idAllTypes - maps to the id_all_types field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByIdAllTypes(Long idAllTypes) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()){
			return(deleteByIdAllTypes(connection, idAllTypes, null));
		}
	}
	/**
	 * deleteByIdAllTypes - from 'fieldDeleters' JSON key.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param idAllTypes - maps to the id_all_types field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByIdAllTypes(Connection connection, Long idAllTypes) throws SQLException {
			return(deleteByIdAllTypes(connection, idAllTypes, null));
	}
	/**
	 * deleteByTestBigint - from 'fieldDeleters' JSON key
	 *
	 * @param testBigint - maps to the test_bigint field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestBigint(Long testBigint, Integer limit) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestBigint(connection, testBigint, limit));
		}
	}

	/**
	 * deleteByTestBigint - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testBigint - maps to the test_bigint field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */

	public static int deleteByTestBigintSilent(Long testBigint) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestBigint(connection, testBigint, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestBigint, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	/**
	 * deleteByTestBigint - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testBigint - maps to the test_bigint field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestBigintSilent(Connection connection, Long testBigint) {
		try {
			return(deleteByTestBigint(connection, testBigint, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestBigint, a SQL Exception occurred.", ex);
			return(-1);
		}
	}
	/**
	 * deleteByTestBigint - from 'fieldDeleters' JSON key.
	 * 
	 * @param testBigint - maps to the test_bigint field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestBigint(Long testBigint) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()){
			return(deleteByTestBigint(connection, testBigint, null));
		}
	}
	/**
	 * deleteByTestBigint - from 'fieldDeleters' JSON key.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testBigint - maps to the test_bigint field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestBigint(Connection connection, Long testBigint) throws SQLException {
			return(deleteByTestBigint(connection, testBigint, null));
	}
	/**
	 * deleteByTestBoolean - from 'fieldDeleters' JSON key
	 *
	 * @param testBoolean - maps to the test_boolean field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestBoolean(Boolean testBoolean, Integer limit) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestBoolean(connection, testBoolean, limit));
		}
	}

	/**
	 * deleteByTestBoolean - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testBoolean - maps to the test_boolean field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */

	public static int deleteByTestBooleanSilent(Boolean testBoolean) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestBoolean(connection, testBoolean, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestBoolean, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	/**
	 * deleteByTestBoolean - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testBoolean - maps to the test_boolean field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestBooleanSilent(Connection connection, Boolean testBoolean) {
		try {
			return(deleteByTestBoolean(connection, testBoolean, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestBoolean, a SQL Exception occurred.", ex);
			return(-1);
		}
	}
	/**
	 * deleteByTestBoolean - from 'fieldDeleters' JSON key.
	 * 
	 * @param testBoolean - maps to the test_boolean field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestBoolean(Boolean testBoolean) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()){
			return(deleteByTestBoolean(connection, testBoolean, null));
		}
	}
	/**
	 * deleteByTestBoolean - from 'fieldDeleters' JSON key.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testBoolean - maps to the test_boolean field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestBoolean(Connection connection, Boolean testBoolean) throws SQLException {
			return(deleteByTestBoolean(connection, testBoolean, null));
	}
	/**
	 * deleteByTestDate - from 'fieldDeleters' JSON key
	 *
	 * @param testDate - maps to the test_date field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestDate(Date testDate, Integer limit) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestDate(connection, testDate, limit));
		}
	}

	/**
	 * deleteByTestDate - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testDate - maps to the test_date field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */

	public static int deleteByTestDateSilent(Date testDate) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestDate(connection, testDate, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestDate, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	/**
	 * deleteByTestDate - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testDate - maps to the test_date field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestDateSilent(Connection connection, Date testDate) {
		try {
			return(deleteByTestDate(connection, testDate, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestDate, a SQL Exception occurred.", ex);
			return(-1);
		}
	}
	/**
	 * deleteByTestDate - from 'fieldDeleters' JSON key.
	 * 
	 * @param testDate - maps to the test_date field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestDate(Date testDate) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()){
			return(deleteByTestDate(connection, testDate, null));
		}
	}
	/**
	 * deleteByTestDate - from 'fieldDeleters' JSON key.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testDate - maps to the test_date field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestDate(Connection connection, Date testDate) throws SQLException {
			return(deleteByTestDate(connection, testDate, null));
	}
	/**
	 * deleteByTestDatetime - from 'fieldDeleters' JSON key
	 *
	 * @param testDatetime - maps to the test_datetime field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestDatetime(Timestamp testDatetime, Integer limit) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestDatetime(connection, testDatetime, limit));
		}
	}

	/**
	 * deleteByTestDatetime - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testDatetime - maps to the test_datetime field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */

	public static int deleteByTestDatetimeSilent(Timestamp testDatetime) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestDatetime(connection, testDatetime, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestDatetime, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	/**
	 * deleteByTestDatetime - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testDatetime - maps to the test_datetime field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestDatetimeSilent(Connection connection, Timestamp testDatetime) {
		try {
			return(deleteByTestDatetime(connection, testDatetime, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestDatetime, a SQL Exception occurred.", ex);
			return(-1);
		}
	}
	/**
	 * deleteByTestDatetime - from 'fieldDeleters' JSON key.
	 * 
	 * @param testDatetime - maps to the test_datetime field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestDatetime(Timestamp testDatetime) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()){
			return(deleteByTestDatetime(connection, testDatetime, null));
		}
	}
	/**
	 * deleteByTestDatetime - from 'fieldDeleters' JSON key.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testDatetime - maps to the test_datetime field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestDatetime(Connection connection, Timestamp testDatetime) throws SQLException {
			return(deleteByTestDatetime(connection, testDatetime, null));
	}
	/**
	 * deleteByTestDouble - from 'fieldDeleters' JSON key
	 *
	 * @param testDouble - maps to the test_double field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestDouble(Double testDouble, Integer limit) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestDouble(connection, testDouble, limit));
		}
	}

	/**
	 * deleteByTestDouble - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testDouble - maps to the test_double field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */

	public static int deleteByTestDoubleSilent(Double testDouble) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestDouble(connection, testDouble, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestDouble, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	/**
	 * deleteByTestDouble - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testDouble - maps to the test_double field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestDoubleSilent(Connection connection, Double testDouble) {
		try {
			return(deleteByTestDouble(connection, testDouble, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestDouble, a SQL Exception occurred.", ex);
			return(-1);
		}
	}
	/**
	 * deleteByTestDouble - from 'fieldDeleters' JSON key.
	 * 
	 * @param testDouble - maps to the test_double field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestDouble(Double testDouble) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()){
			return(deleteByTestDouble(connection, testDouble, null));
		}
	}
	/**
	 * deleteByTestDouble - from 'fieldDeleters' JSON key.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testDouble - maps to the test_double field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestDouble(Connection connection, Double testDouble) throws SQLException {
			return(deleteByTestDouble(connection, testDouble, null));
	}
	/**
	 * deleteByTestFloat - from 'fieldDeleters' JSON key
	 *
	 * @param testFloat - maps to the test_float field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestFloat(Float testFloat, Integer limit) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestFloat(connection, testFloat, limit));
		}
	}

	/**
	 * deleteByTestFloat - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testFloat - maps to the test_float field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */

	public static int deleteByTestFloatSilent(Float testFloat) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestFloat(connection, testFloat, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestFloat, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	/**
	 * deleteByTestFloat - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testFloat - maps to the test_float field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestFloatSilent(Connection connection, Float testFloat) {
		try {
			return(deleteByTestFloat(connection, testFloat, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestFloat, a SQL Exception occurred.", ex);
			return(-1);
		}
	}
	/**
	 * deleteByTestFloat - from 'fieldDeleters' JSON key.
	 * 
	 * @param testFloat - maps to the test_float field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestFloat(Float testFloat) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()){
			return(deleteByTestFloat(connection, testFloat, null));
		}
	}
	/**
	 * deleteByTestFloat - from 'fieldDeleters' JSON key.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testFloat - maps to the test_float field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestFloat(Connection connection, Float testFloat) throws SQLException {
			return(deleteByTestFloat(connection, testFloat, null));
	}
	/**
	 * deleteByTestInt - from 'fieldDeleters' JSON key
	 *
	 * @param testInt - maps to the test_int field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestInt(Integer testInt, Integer limit) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestInt(connection, testInt, limit));
		}
	}

	/**
	 * deleteByTestInt - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testInt - maps to the test_int field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */

	public static int deleteByTestIntSilent(Integer testInt) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestInt(connection, testInt, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestInt, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	/**
	 * deleteByTestInt - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testInt - maps to the test_int field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestIntSilent(Connection connection, Integer testInt) {
		try {
			return(deleteByTestInt(connection, testInt, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestInt, a SQL Exception occurred.", ex);
			return(-1);
		}
	}
	/**
	 * deleteByTestInt - from 'fieldDeleters' JSON key.
	 * 
	 * @param testInt - maps to the test_int field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestInt(Integer testInt) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()){
			return(deleteByTestInt(connection, testInt, null));
		}
	}
	/**
	 * deleteByTestInt - from 'fieldDeleters' JSON key.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testInt - maps to the test_int field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestInt(Connection connection, Integer testInt) throws SQLException {
			return(deleteByTestInt(connection, testInt, null));
	}
	/**
	 * deleteByTestInteger - from 'fieldDeleters' JSON key
	 *
	 * @param testInteger - maps to the test_integer field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestInteger(Integer testInteger, Integer limit) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestInteger(connection, testInteger, limit));
		}
	}

	/**
	 * deleteByTestInteger - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testInteger - maps to the test_integer field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */

	public static int deleteByTestIntegerSilent(Integer testInteger) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestInteger(connection, testInteger, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestInteger, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	/**
	 * deleteByTestInteger - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testInteger - maps to the test_integer field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestIntegerSilent(Connection connection, Integer testInteger) {
		try {
			return(deleteByTestInteger(connection, testInteger, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestInteger, a SQL Exception occurred.", ex);
			return(-1);
		}
	}
	/**
	 * deleteByTestInteger - from 'fieldDeleters' JSON key.
	 * 
	 * @param testInteger - maps to the test_integer field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestInteger(Integer testInteger) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()){
			return(deleteByTestInteger(connection, testInteger, null));
		}
	}
	/**
	 * deleteByTestInteger - from 'fieldDeleters' JSON key.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testInteger - maps to the test_integer field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestInteger(Connection connection, Integer testInteger) throws SQLException {
			return(deleteByTestInteger(connection, testInteger, null));
	}
	/**
	 * deleteByTestMediumint - from 'fieldDeleters' JSON key
	 *
	 * @param testMediumint - maps to the test_mediumint field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestMediumint(Integer testMediumint, Integer limit) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestMediumint(connection, testMediumint, limit));
		}
	}

	/**
	 * deleteByTestMediumint - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testMediumint - maps to the test_mediumint field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */

	public static int deleteByTestMediumintSilent(Integer testMediumint) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestMediumint(connection, testMediumint, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestMediumint, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	/**
	 * deleteByTestMediumint - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testMediumint - maps to the test_mediumint field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestMediumintSilent(Connection connection, Integer testMediumint) {
		try {
			return(deleteByTestMediumint(connection, testMediumint, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestMediumint, a SQL Exception occurred.", ex);
			return(-1);
		}
	}
	/**
	 * deleteByTestMediumint - from 'fieldDeleters' JSON key.
	 * 
	 * @param testMediumint - maps to the test_mediumint field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestMediumint(Integer testMediumint) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()){
			return(deleteByTestMediumint(connection, testMediumint, null));
		}
	}
	/**
	 * deleteByTestMediumint - from 'fieldDeleters' JSON key.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testMediumint - maps to the test_mediumint field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestMediumint(Connection connection, Integer testMediumint) throws SQLException {
			return(deleteByTestMediumint(connection, testMediumint, null));
	}
	/**
	 * deleteByTestNumeric - from 'fieldDeleters' JSON key
	 *
	 * @param testNumeric - maps to the test_numeric field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestNumeric(BigDecimal testNumeric, Integer limit) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestNumeric(connection, testNumeric, limit));
		}
	}

	/**
	 * deleteByTestNumeric - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testNumeric - maps to the test_numeric field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */

	public static int deleteByTestNumericSilent(BigDecimal testNumeric) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestNumeric(connection, testNumeric, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestNumeric, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	/**
	 * deleteByTestNumeric - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testNumeric - maps to the test_numeric field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestNumericSilent(Connection connection, BigDecimal testNumeric) {
		try {
			return(deleteByTestNumeric(connection, testNumeric, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestNumeric, a SQL Exception occurred.", ex);
			return(-1);
		}
	}
	/**
	 * deleteByTestNumeric - from 'fieldDeleters' JSON key.
	 * 
	 * @param testNumeric - maps to the test_numeric field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestNumeric(BigDecimal testNumeric) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()){
			return(deleteByTestNumeric(connection, testNumeric, null));
		}
	}
	/**
	 * deleteByTestNumeric - from 'fieldDeleters' JSON key.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testNumeric - maps to the test_numeric field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestNumeric(Connection connection, BigDecimal testNumeric) throws SQLException {
			return(deleteByTestNumeric(connection, testNumeric, null));
	}
	/**
	 * deleteByTestSmallint - from 'fieldDeleters' JSON key
	 *
	 * @param testSmallint - maps to the test_smallint field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestSmallint(Short testSmallint, Integer limit) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestSmallint(connection, testSmallint, limit));
		}
	}

	/**
	 * deleteByTestSmallint - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testSmallint - maps to the test_smallint field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */

	public static int deleteByTestSmallintSilent(Short testSmallint) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestSmallint(connection, testSmallint, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestSmallint, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	/**
	 * deleteByTestSmallint - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testSmallint - maps to the test_smallint field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestSmallintSilent(Connection connection, Short testSmallint) {
		try {
			return(deleteByTestSmallint(connection, testSmallint, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestSmallint, a SQL Exception occurred.", ex);
			return(-1);
		}
	}
	/**
	 * deleteByTestSmallint - from 'fieldDeleters' JSON key.
	 * 
	 * @param testSmallint - maps to the test_smallint field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestSmallint(Short testSmallint) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()){
			return(deleteByTestSmallint(connection, testSmallint, null));
		}
	}
	/**
	 * deleteByTestSmallint - from 'fieldDeleters' JSON key.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testSmallint - maps to the test_smallint field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestSmallint(Connection connection, Short testSmallint) throws SQLException {
			return(deleteByTestSmallint(connection, testSmallint, null));
	}
	/**
	 * deleteByTestText - from 'fieldDeleters' JSON key
	 *
	 * @param testText - maps to the test_text field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestText(String testText, Integer limit) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestText(connection, testText, limit));
		}
	}

	/**
	 * deleteByTestText - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testText - maps to the test_text field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */

	public static int deleteByTestTextSilent(String testText) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestText(connection, testText, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestText, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	/**
	 * deleteByTestText - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testText - maps to the test_text field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestTextSilent(Connection connection, String testText) {
		try {
			return(deleteByTestText(connection, testText, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestText, a SQL Exception occurred.", ex);
			return(-1);
		}
	}
	/**
	 * deleteByTestText - from 'fieldDeleters' JSON key.
	 * 
	 * @param testText - maps to the test_text field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestText(String testText) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()){
			return(deleteByTestText(connection, testText, null));
		}
	}
	/**
	 * deleteByTestText - from 'fieldDeleters' JSON key.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testText - maps to the test_text field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestText(Connection connection, String testText) throws SQLException {
			return(deleteByTestText(connection, testText, null));
	}
	/**
	 * deleteByTestTinyint - from 'fieldDeleters' JSON key
	 *
	 * @param testTinyint - maps to the test_tinyint field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestTinyint(Boolean testTinyint, Integer limit) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestTinyint(connection, testTinyint, limit));
		}
	}

	/**
	 * deleteByTestTinyint - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testTinyint - maps to the test_tinyint field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */

	public static int deleteByTestTinyintSilent(Boolean testTinyint) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestTinyint(connection, testTinyint, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestTinyint, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	/**
	 * deleteByTestTinyint - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testTinyint - maps to the test_tinyint field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestTinyintSilent(Connection connection, Boolean testTinyint) {
		try {
			return(deleteByTestTinyint(connection, testTinyint, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestTinyint, a SQL Exception occurred.", ex);
			return(-1);
		}
	}
	/**
	 * deleteByTestTinyint - from 'fieldDeleters' JSON key.
	 * 
	 * @param testTinyint - maps to the test_tinyint field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestTinyint(Boolean testTinyint) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()){
			return(deleteByTestTinyint(connection, testTinyint, null));
		}
	}
	/**
	 * deleteByTestTinyint - from 'fieldDeleters' JSON key.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testTinyint - maps to the test_tinyint field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestTinyint(Connection connection, Boolean testTinyint) throws SQLException {
			return(deleteByTestTinyint(connection, testTinyint, null));
	}
	/**
	 * deleteByTestVarchar - from 'fieldDeleters' JSON key
	 *
	 * @param testVarchar - maps to the test_varchar field (from the where clause)
	 * @param limit - The limit of the number of rows to affect
	 * 
	 * @return the number of rows deleted
	 * 
	 * @throws SQLException if there was an error in the deletion
	 */
	public static int deleteByTestVarchar(String testVarchar, Integer limit) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestVarchar(connection, testVarchar, limit));
		}
	}

	/**
	 * deleteByTestVarchar - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param testVarchar - maps to the test_varchar field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */

	public static int deleteByTestVarcharSilent(String testVarchar) {
		try (Connection connection = ConnectionManager.getConnection()) {
			return(deleteByTestVarchar(connection, testVarchar, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestVarchar, a SQL Exception occurred.", ex);
			return(-1);
		}
	}

	/**
	 * deleteByTestVarchar - from 'fieldDeleters' JSON key.
	 * This will silently swallow any exceptions.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testVarchar - maps to the test_varchar field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestVarcharSilent(Connection connection, String testVarchar) {
		try {
			return(deleteByTestVarchar(connection, testVarchar, null));
		} catch (SQLException ex) {
			LOGGER.error("Could not deleteByTestVarchar, a SQL Exception occurred.", ex);
			return(-1);
		}
	}
	/**
	 * deleteByTestVarchar - from 'fieldDeleters' JSON key.
	 * 
	 * @param testVarchar - maps to the test_varchar field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestVarchar(String testVarchar) throws SQLException {
		try (Connection connection = ConnectionManager.getConnection()){
			return(deleteByTestVarchar(connection, testVarchar, null));
		}
	}
	/**
	 * deleteByTestVarchar - from 'fieldDeleters' JSON key.
	 * 
	 * @param connection - the connection - the caller __MUST__ close this connection
	 *        if the caller created this connection. If the passed in connection is 
	 *        null, then a new connection will be created, utilised, and closed within
	 *        this method.
	 * @param testVarchar - maps to the test_varchar field (from the where clause)
	 * 
	 * @return the number of rows deleted or -1 if there was an error
	 */
	public static int deleteByTestVarchar(Connection connection, String testVarchar) throws SQLException {
			return(deleteByTestVarchar(connection, testVarchar, null));
	}
}