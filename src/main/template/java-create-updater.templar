{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
		PACKAGE DECLARATION, IMPORT STATEMENTS AND CLASS DEFINITION

 		NOTES:
		  If the table is a constant - then this file will not be generated
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

package {database.package}.updater;{\n}{\n}
// - - - - thoughtfully generated by synapticloop h2zero - - - - {\n}
//    with the use of synapticloop templar templating language{\n}
//              (java-create-updater.templar){\n}{\n}

import java.sql.Connection;{\n}
import java.sql.PreparedStatement;{\n}
import java.sql.SQLException;{\n}
import java.sql.Types;{\n}
import java.sql.Timestamp;{\n}
{\n}
import synapticloop.h2zero.base.manager.ConnectionManager;{\n}{\n}
import {database.package}.finder.{table.javaClassName}Finder;{\n}
import {database.package}.model.util.Constants;{\n}
{\n}

public class {table.javaClassName}Updater {{{\n}
{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				THE UPDATER STRINGS FIELDS
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}
{set table as baseSchemaObject}
{import classpath:/snippet/global/java-binder-declaration.templar}

{\t}// static fields generated by synapticloop h20{\n}
{\t}private static final String SQL_UPDATE_START = "update {table.name} ";{\n}{\n}

{\t}// static fields generated from the user input{\n}
{loop table.updaters as updater}
	{\t}private static final String SQL_{updater.staticName} = SQL_UPDATE_START
	{if fn:notNull[updater.setClause]} + " {updater.setClause}"{endif}
	{if fn:notNull[updater.whereClause]} + " {updater.whereClause}"{endif};{\n}
{endloop}
{\n}

{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				THE UPDATER STATEMENTS
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}
{loop table.updaters as updater}
	{set fn:length[updater.updateFields] as updateFieldsLength}

	{\t}public static int {updater.name}(Connection connection{if fn:>[updateFieldsLength, 0]}, {endif}
	{--
		Now for the set and where fields
	}

		{import classpath:/snippet/updater/method-parameters.templar}

	) throws SQLException {{{\n}

	{\t}{\t}PreparedStatement preparedStatement = connection.prepareStatement(SQL_{updater.staticName});{\n}

	{loop updater.updateFields as updateField}
		{\t}{\t}ConnectionManager.set{updateField.upperType}(preparedStatement, {updateFieldStatus.index}, {updateField.javaName});{\n}
	{endloop}
	{\n}

	{if table.cacheable}
		{\t}{\t}{table.javaClassName}Finder.markRefreshAllCaches();{\n}
	{endif}

	{\t}{\t}int numRowsUpdated = preparedStatement.executeUpdate();{\n}{\n}
	{\t}{\t}ConnectionManager.closeAll(preparedStatement);{\n}{\n}
	{\t}{\t}return(numRowsUpdated);{\n}
	{\t}}{\n}
{\n}

	{\t}public static int {updater.name}Silent(

		{import classpath:/snippet/updater/method-parameters.templar}

	) {{{\n}
	{\t}{\t}Connection connection;{\n}
	{\t}{\t}try {{{\n}
	{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
	{\t}{\t}{\t}int numRowsUpdated = {updater.name}(connection{if fn:>[updateFieldsLength, 0]}, {endif}

		{import classpath:/snippet/updater/method-parameters-call.templar}

	);{\n}
	{\t}{\t}{\t}ConnectionManager.closeAll(connection);{\n}
	{\t}{\t}{\t}return(numRowsUpdated);{\n}
	{\t}{\t}} catch (SQLException sqlex) {{{\n}
	{\t}{\t}{\t}sqlex.printStackTrace();{\n}
	{\t}{\t}{\t}return(-1);{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}
{\n}

	{\t}public static int {updater.name}(

		{import classpath:/snippet/updater/method-parameters.templar}

	) throws SQLException {{{\n}
	{\t}{\t}Connection connection = ConnectionManager.getConnection();{\n}
	{\t}{\t}int numRowsUpdated = {updater.name}(connection{if fn:>[updateFieldsLength, 0]}, {endif}

		{import classpath:/snippet/updater/method-parameters-call.templar}

	);{\n}
	{\t}{\t}ConnectionManager.closeAll(connection);{\n}
	{\t}{\t}return(numRowsUpdated);{\n}
	{\t}}{\n}
{\n}
{endloop}

}