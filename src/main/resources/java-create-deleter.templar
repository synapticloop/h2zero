{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
		PACKAGE DECLARATION, IMPORT STATEMENTS AND CLASS DEFINITION

		NOTES:
		  If the table is a constant - then this file will not be generated
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

package {database.package}.deleter;{\n}{\n}
// - - - - thoughtfully generated by synapticloop h2zero - - - - {\n}
//    with the use of synapticloop templar templating language{\n}
//                (java-create-deleter.templar){\n}{\n}
import java.sql.Connection;{\n}
import java.sql.Timestamp;{\n}
import java.sql.PreparedStatement;{\n}
import java.sql.SQLException;{\n}
import java.sql.*;{\n}
import java.math.BigDecimal;{\n}
import java.util.List;{\n}
import java.util.ArrayList;{\n}
import com.synapticloop.h2zero.util.LruCache;{\n}

{\n}
import com.synapticloop.h2zero.base.manager.{options.database}.ConnectionManager;{\n}

{\n}
{import classpath:/snippet/global/java-logger.templar}
{\n}

import {database.package}.model.util.Constants;{\n}
{\n}

public class {table.javaClassName}Deleter {{{\n}
{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				THE DELETER STRINGS FIELDS
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}
{set table as baseSchemaObject}
{import classpath:/snippet/global/java-binder-declaration.templar}

{set "Deleter" as classType}
{set table.javaClassName as loggerClass}

{import classpath:/snippet/global/java-logger-declaration.templar}{\n}

{\t}// static fields generated by synapticloop h2zero{\n}

{if fn:or[table.hasForeignKey, fn:=[options.database, "sqlite3"]]}
	{\t}private static final String SQL_BUILTIN_DELETE_ALL = "delete from {table.name}";{\n}
{else}
	{\t}private static final String SQL_BUILTIN_DELETE_ALL = "truncate table {table.name}";{\n}
{endif}

{\t}private static final String SQL_DELETE_START = "delete from {table.name} ";{\n}
{loop table.fields as field}
	{if field.primary}
		{set field.name as primaryFieldName}
		{set field.javaName as primaryFieldJavaName}
	{endif}
{endloop}

{\t}private static final String SQL_BUILTIN_DELETE_BY_PRIMARY_KEY = SQL_DELETE_START + "where {primaryFieldName} = ?";{\n}{\n}

{loop table.deleters as deleter}
	{if deleterStatus.first}
		{\t}// static fields generated from the user input{\n}
	{endif}
	{\t}private static final String SQL_{deleter.staticName} = SQL_DELETE_START
	{if fn:notNull[deleter.whereClause]} + " {deleter.whereClause}"{endif};{\n}
{endloop}

{--
The statement caches
}

{set tableOrView.deleters as queryObjects}
{if fn:null[deleter]}
	{set "1024" as statementCacheSize}
{else}
	{set deleter.statementCacheSize as statementCacheSize}
{endif}
{set "delete" as allName}
{import classpath:/snippet/global/java-query-objects-statement-caches.templar}

{\n}
{\t}// We don't allow instantiation{\n}
{\t}private {table.javaClassName}Deleter() {{}{\n}{\n}
{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				DELETE BY PRIMARY KEY
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}
 {\t}/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *{\n}
 {\t} * {\n}
 {\t} * The following deleters are built in by h2zero and are always generated {\n}
 {\t} * {\n}
 {\t} * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */{\n}{\n}


{\t}/**{\n}
{\t} * Delete a row in the {table.upperName} table by its primary key{\n}
{\t} * {\n}
{\t} * @param connection The connection to use - the caller must close this connection{\n}
{\t} * @param {primaryFieldJavaName} the primary key to delete{\n}
{\t} * {\n}
{\t} * @return the number of rows deleted{\n}
{\t} * {\n}
{\t} * @throws SQLException if there was an error in the delete{\n}
{\t} */{\n}

{\t}public static int deleteByPrimaryKey(Connection connection, Long {primaryFieldJavaName}) throws SQLException {{{\n}

	{\t}{\t}try (PreparedStatement preparedStatement = connection.prepareStatement(SQL_BUILTIN_DELETE_BY_PRIMARY_KEY)) {{{\n}
	{\t}{\t}{\t}preparedStatement.setLong(1, {primaryFieldJavaName});{\n}
	{\t}{\t}{\t}return(preparedStatement.executeUpdate());{\n}
	{\t}{\t}}{\n}
{\t}}{\n}{\n}

{\t}/**{\n}
{\t} * Delete a row in the {table.upperName} table by its primary key{\n}
{\t} * {\n}
{\t} * @param {primaryFieldJavaName} the primary key to delete{\n}
{\t} * {\n}
{\t} * @return the number of rows deleted{\n}
{\t} * {\n}
{\t} * @throws SQLException if there was an error in the delete{\n}
{\t} */{\n}

{\t}public static int deleteByPrimaryKey(Long {primaryFieldJavaName}) throws SQLException {{{\n}
	{\t}{\t}try (Connection connection = ConnectionManager.getConnection()) {{{\n}
	{\t}{\t}{\t}return(deleteByPrimaryKey(connection, {primaryFieldJavaName}));{\n}
	{\t}{\t}}{\n}
{\t}}{\n}
{\n}

{\t}/**{\n}
{\t} * Delete a row in the {table.upperName} table by its primary key silently{\n}
{\t} * (i.e. don't throw an exception if it couldn't be deleted).{\n}
{\t} * {\n}
{\t} * @param connection - the connection to use - the caller must close this connection{\n}
{\t} * @param {primaryFieldJavaName} the primary key to delete{\n}
{\t} * {\n}
{\t} * @return the number of rows deleted{\n}
{\t} */{\n}


{\t}public static int deleteByPrimaryKeySilent(Connection connection, Long {primaryFieldJavaName}) {{{\n}
	{\t}{\t}try {{{\n}
	{\t}{\t}{\t}return(deleteByPrimaryKey(connection, {primaryFieldJavaName}));{\n}
	{\t}{\t}} catch (SQLException ex) {{{\n}
	{\t}{\t}{\t}LOGGER.error("Could not deleteByPrimaryKey, a SQL Exception occurred.", ex);{\n}
	{\t}{\t}{\t}return(-1);{\n}
	{\t}{\t}}{\n}
{\t}}{\n}
{\n}

{\t}/**{\n}
{\t} * Delete a row in the {table.upperName} table by its primary key silently{\n}
{\t} * (i.e. don't throw an exception if it coudn't be deleted).{\n}
{\t} * {\n}
{\t} * @param {primaryFieldJavaName} the primary key to delete{\n}
{\t} * {\n}
{\t} * @return the number of rows deleted or -1 if there was an error{\n}
{\t} */{\n}


{\t}public static int deleteByPrimaryKeySilent(Long {primaryFieldJavaName}) {{{\n}
	{\t}{\t}try (Connection connection = ConnectionManager.getConnection()) {{{\n}
	{\t}{\t}{\t}return(deleteByPrimaryKeySilent(connection, {primaryFieldJavaName}));{\n}
	{\t}{\t}} catch (SQLException ex) {{{\n}
	{\t}{\t}{\t}LOGGER.error("Could not deleteByPrimaryKey, a SQL Exception occurred.", ex);{\n}
	{\t}{\t}{\t}return(-1);{\n}
	{\t}{\t}}{\n}
{\t}}{\n}
{\n}

{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				DELETE ALL STATEMENT
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

{\t}/**{\n}
{\t} * Delete all of the rows in the table '{table.name}'.{\n}
{if fn:or[table.hasForeignKey, fn:=[options.database, "sqlite3"]]}
	{if fn:=[options.database, "sqlite3"]}
		{\t} * {\n}
		{\t} * This database does not have the 'truncate' keyword hence the 'DELETE FROM' SQL{\n}
		{\t} * statement is used{\n}
	{else}
		{\t} * {\n}
		{\t} * This table has a foreign key relationship on it, consequently the truncate{\n}
		{\t} * method would have been faster, but would fail, hence the 'DELETE FROM' SQL{\n}
		{\t} * statement is used{\n}
	{endif}
{else}
	{\t} * {\n}
	{\t} * This table has no foreign key relationships and consequently can be truncated.{\n}
{endif}
{\t} * {\n}
{\t} * @param connection - the connection to use - the caller must close this connection{\n}
{\t} * {\n}
{\t} * @return The number of rows affected by this statement{\n}
{\t} */{\n}
{\t}public static int deleteAll(Connection connection) throws SQLException {{{\n}

	{\t}{\t}try (PreparedStatement preparedStatement = connection.prepareStatement(SQL_BUILTIN_DELETE_ALL)) {{{\n}

	{\t}{\t}{\t}return(preparedStatement.executeUpdate());{\n}
	{\t}{\t}} catch (SQLException ex) {{{\n}
	{\t}{\t}{\t}LOGGER.error("Could not deleteAll, a SQL Exception occurred.", ex);{\n}
	{\t}{\t}{\t}return(-1);{\n}
	{\t}{\t}}{\n}
{\t}}{\n}{\n}

{\t}/**{\n}
{\t} * Delete all the rows in the {table.upperName} table{\n}
{\t} * {\n}
{\t} * @return the number of rows deleted{\n}
{\t} * {\n}
{\t} * @throws SQLException if there was an error in the delete{\n}
{\t} */{\n}

{\t}public static int deleteAll() throws SQLException {{{\n}
	{\t}{\t}try (Connection connection = ConnectionManager.getConnection()) {{{\n}
	{\t}{\t}{\t}return(deleteAll(connection));{\n}
	{\t}{\t}}{\n}
{\t}}{\n}
{\n}

{\t}/**{\n}
{\t} * Delete all the rows in the {table.upperName} table silently - i.e{\n}
{\t} * swallow any SQL exceptions{\n}
{\t} * {\n}
{\t} * @param connection - the connection to use - the caller must close this connection{\n}
{\t} * {\n}
{\t} * @return the number of rows deleted or -1 if there was an error{\n}
{\t} */{\n}

{\t}public static int deleteAllSilent(Connection connection) {{{\n}
	{\t}{\t}try {{{\n}
	{\t}{\t}{\t}return(deleteAll(connection));{\n}
	{\t}{\t}} catch (SQLException ex) {{{\n}
	{\t}{\t}{\t}LOGGER.error("Could not deleteAll, a SQL Exception occurred.", ex);{\n}
	{\t}{\t}{\t}return(-1);{\n}
	{\t}{\t}}{\n}
{\t}}{\n}
{\n}

{\t}/**{\n}
{\t} * Delete all the rows in the {table.upperName} table silently - i.e{\n}
{\t} * swallow any SQL exceptions{\n}
{\t} * {\n}
{\t} * @return the number of rows deleted, or -1 if there was an error{\n}
{\t} */{\n}
{\t}public static int deleteAllSilent() {{{\n}
	{\t}{\t}try (Connection connection = ConnectionManager.getConnection()) {{{\n}
	{\t}{\t}{\t}return(deleteAll(connection));{\n}
	{\t}{\t}} catch (SQLException ex) {{{\n}
	{\t}{\t}{\t}LOGGER.error("Could not deleteAll, a SQL Exception occurred.", ex);{\n}
	{\t}{\t}{\t}return(-1);{\n}
	{\t}{\t}}{\n}
{\t}}{\n}
{\n}




{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 


				THE USER DELETER STATEMENTS


 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

{set tableOrView.deleters as queryObjects}
{set tableOrView.name as tableName}
{set "Deleter" as type}
{import classpath:/snippet/global/java-query-objects-user-comments.templar}

{loop table.deleters as deleter}
	{set fn:length[deleter.whereFields] as deleterFieldsLength}

{if fn:notEqual[options.database, "sqlite3"]}
{-- SQLITE DOES NOT ALLOW LIMITS ON DELETERS }
	{\t}// USER DEFINED DELETER CONNECTION, PARAMS, LIMIT{\n}
	{\t}/**{\n}
	{\t} * {deleter.name} - {if deleter.isAutoDeleter}from 'fieldDeleters' JSON key{else}from 'deleters' JSON key{endif}{\n}
	{\t} *{\n}
	{\t} * This is the main method for all other deleter methods with the same prefix,{\n}
	{\t} * including the (silent method signatures).  All methods chain to this one.{\n}
	{\t} * {\n}

{set deleter as queryObject}
{set tableOrView.name as tableName}
{set "true" as hasConnection}
{set "true" as hasLimit}
{set "false" as hasOffset}
{import classpath:/snippet/global/java-query-objects-method-where-comments.templar}

	{\t} * {\n}
	{\t} * @return the number of rows deleted{\n}
	{\t} * {\n}
	{\t} * @throws SQLException if there was an error in the deletion{\n}
	{\t} */{\n}
	{\t}public static int {deleter.name}(
		{--
			Now for the where field parameters
		}

{set deleter as queryObject}
{set "true" as hasConnection}
{set "true" as hasLimit}
{set "false" as hasOffset}
{import classpath:/snippet/global/java-query-objects-method-where-parameters.templar}

) throws SQLException {{{\n}

	{--
			need to add in the correct cache keys for infields....

			this is a little more complex...  the cacheKey now becomes the values of:
			<limit>:<num_args in list>:...
		}

		{\t}{\t}String cacheKey = limit {if deleter.hasInFields} + ":" +{\ }
			{loop deleter.inWhereFields as whereField}
				{whereField.javaName}List.size() + ":" {if !whereFieldStatus.last} + {endif}
			{endloop}{endif} + "";{\n}

		{\t}{\t}boolean hasConnection = (null != connection);{\n}
		{\t}{\t}String statement = null;{\n}

		{\t}{\t}if(!{deleter.name}_limit_statement_cache.containsKey(cacheKey)) {{{\n}

		{\t}{\t}{\t}// place the cacheKey in the cache for later use{\n}
		{\n}

		{if deleter.hasInFields}
			{\t}{\t}{\t}String preparedStatementTemp = SQL_{deleter.staticName};{\n}
			{\t}{\t}{\t}StringBuilder whereFieldStringBuilder = null;{\n}
			{loop deleter.whereFields as whereField}
				{if whereField.isInField}
					{\t}{\t}{\t}whereFieldStringBuilder = new StringBuilder();{\n}
					{\t}{\t}{\t}for(int i = 0; i < {whereField.javaName}List.size(); i++) {{{\n}
					{\t}{\t}{\t}{\t}if(i > 0) {{{\n}
					{\t}{\t}{\t}{\t}{\t}whereFieldStringBuilder.append(", ");{\n}
					{\t}{\t}{\t}{\t}}{\n}
					{\t}{\t}{\t}{\t}whereFieldStringBuilder.append("?");{\n}
					{\t}{\t}{\t}}{\n}

					{\t}{\t}{\t}preparedStatementTemp = preparedStatementTemp.replaceFirst("\\.\\.\\.", whereFieldStringBuilder.toString());{\n}
				{endif}
			{endloop}
			{\t}{\t}{\t}StringBuilder stringBuilder = new StringBuilder(preparedStatementTemp);{\n}
		{else}
			{\t}{\t}{\t}StringBuilder stringBuilder = new StringBuilder(SQL_{deleter.staticName});{\n}
		{endif}

		{\n}
		{\t}{\t}{\t}if(null != limit) {{{\n}
		{\t}{\t}{\t}{\t}stringBuilder.append(" limit ");{\n}
		{\t}{\t}{\t}{\t}stringBuilder.append(limit);{\n}
		{\t}{\t}{\t}}{\n}
		{\n}
		{\t}{\t}{\t}statement = stringBuilder.toString();{\n}
		{\t}{\t}{\t}{deleter.name}_limit_statement_cache.put(cacheKey, statement);{\n}
		{\t}{\t}} else {{{\n}
		{\t}{\t}{\t}statement = {deleter.name}_limit_statement_cache.get(cacheKey);{\n}
		{\t}{\t}}{\n}
		{\n}


		{\t}{\t}if(!hasConnection) {{{\n}
		{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
		{\t}{\t}}{\n}


		{\t}{\t}try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {{{\n}
		{if deleter.hasInFields}
			{\t}{\t}{\t}int i = 1;{\n}
			{loop deleter.whereFields as whereField}
				{if whereField.isInField}
					{\t}{\t}{\t}for ({whereField.javaType} {whereField.javaName}In : {whereField.javaName}List) {{{\n}
					{\t}{\t}{\t}{\t}ConnectionManager.set{whereField.upperType}(preparedStatement, i, {whereField.javaName}In);{\n}
					{\t}{\t}{\t}{\t}i++;{\n}
					{\t}{\t}{\t}}{\n}

				{else}
					{\t}{\t}{\t}ConnectionManager.set{whereField.upperType}(preparedStatement, i, {whereField.javaName});{\n}
					{\t}{\t}{\t}i++;{\n}
				{endif}
			{endloop}
		{else}
			{loop deleter.whereFields as whereField}
				{\t}{\t}{\t}ConnectionManager.set{whereField.upperType}(preparedStatement, {whereFieldStatus.index}, {whereField.javaName});{\n}
			{endloop}
		{endif}
		{\n}

	{\t}{\t}{\t}return(preparedStatement.executeUpdate());{\n}

	{\t}{\t}}{\n}
	{\t}}{\n}
	{\n}

	{else}


	{\t}// USER DEFINED DELETER CONNECTION, PARAMS - NO LIMIT - SQLITE3 STATEMENT{\n}
	{\t}/**{\n}
	{\t} * {deleter.name} - {if deleter.isAutoDeleter}from 'fieldDeleters' JSON key{else}from 'deleters' JSON key{endif}{\n}
	{\t} *{\n}
	{\t} * This is the main method for all other deleter methods with the same prefix,{\n}
	{\t} * including the (silent method signatures).  All methods chain to this one.{\n}
	{\t} * {\n}

{set deleter as queryObject}
{set tableOrView.name as tableName}
{set "true" as hasConnection}
{set "false" as hasLimit}
{set "false" as hasOffset}
{import classpath:/snippet/global/java-query-objects-method-where-comments.templar}

	{\t} * {\n}
	{\t} * @return the number of rows deleted{\n}
	{\t} * {\n}
	{\t} * @throws SQLException if there was an error in the deletion{\n}
	{\t} */{\n}
	{\t}public static int {deleter.name}(
		{--
			Now for the where field parameters
		}

{set deleter as queryObject}
{set "true" as hasConnection}
{set "false" as hasLimit}
{set "false" as hasOffset}
{import classpath:/snippet/global/java-query-objects-method-where-parameters.templar}

) throws SQLException {{{\n}

	{--
			need to add in the correct cache keys for infields....

			this is a little more complex...  the cacheKey now becomes the values of:
			<limit>:<num_args in list>:...
		}

		{\t}{\t}String cacheKey = "cacheKey" {if deleter.hasInFields} + ":" +{\ }
			{loop deleter.inWhereFields as whereField}
				{whereField.javaName}List.size() + ":" {if !whereFieldStatus.last} + {endif}
			{endloop}{endif} + "";{\n}

		{\t}{\t}boolean hasConnection = (null != connection);{\n}
		{\t}{\t}String statement = null;{\n}

		{\t}{\t}if(!{deleter.name}_limit_statement_cache.containsKey(cacheKey)) {{{\n}

		{\t}{\t}{\t}// place the cacheKey in the cache for later use{\n}
		{\n}

		{if deleter.hasInFields}
			{\t}{\t}{\t}String preparedStatementTemp = SQL_{deleter.staticName};{\n}
			{\t}{\t}{\t}StringBuilder whereFieldStringBuilder = null;{\n}
			{loop deleter.whereFields as whereField}
				{if whereField.isInField}
					{\t}{\t}{\t}whereFieldStringBuilder = new StringBuilder();{\n}
					{\t}{\t}{\t}for(int i = 0; i < {whereField.javaName}List.size(); i++) {{{\n}
					{\t}{\t}{\t}{\t}if(i > 0) {{{\n}
					{\t}{\t}{\t}{\t}{\t}whereFieldStringBuilder.append(", ");{\n}
					{\t}{\t}{\t}{\t}}{\n}
					{\t}{\t}{\t}{\t}whereFieldStringBuilder.append("?");{\n}
					{\t}{\t}{\t}}{\n}

					{\t}{\t}{\t}preparedStatementTemp = preparedStatementTemp.replaceFirst("\\.\\.\\.", whereFieldStringBuilder.toString());{\n}
				{endif}
			{endloop}
			{\t}{\t}{\t}StringBuilder stringBuilder = new StringBuilder(preparedStatementTemp);{\n}
		{else}
			{\t}{\t}{\t}StringBuilder stringBuilder = new StringBuilder(SQL_{deleter.staticName});{\n}
		{endif}

		{\n}
		{\t}{\t}{\t}statement = stringBuilder.toString();{\n}
		{\t}{\t}{\t}{deleter.name}_limit_statement_cache.put(cacheKey, statement);{\n}
		{\t}{\t}} else {{{\n}
		{\t}{\t}{\t}statement = {deleter.name}_limit_statement_cache.get(cacheKey);{\n}
		{\t}{\t}}{\n}
		{\n}


		{\t}{\t}if(!hasConnection) {{{\n}
		{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
		{\t}{\t}}{\n}


		{\t}{\t}try (PreparedStatement preparedStatement = connection.prepareStatement(statement)) {{{\n}
		{if deleter.hasInFields}
			{\t}{\t}{\t}int i = 1;{\n}
			{loop deleter.whereFields as whereField}
				{if whereField.isInField}
					{\t}{\t}{\t}for ({whereField.javaType} {whereField.javaName}In : {whereField.javaName}List) {{{\n}
					{\t}{\t}{\t}{\t}ConnectionManager.set{whereField.upperType}(preparedStatement, i, {whereField.javaName}In);{\n}
					{\t}{\t}{\t}{\t}i++;{\n}
					{\t}{\t}{\t}}{\n}

				{else}
					{\t}{\t}{\t}ConnectionManager.set{whereField.upperType}(preparedStatement, i, {whereField.javaName});{\n}
					{\t}{\t}{\t}i++;{\n}
				{endif}
			{endloop}
		{else}
			{loop deleter.whereFields as whereField}
				{\t}{\t}{\t}ConnectionManager.set{whereField.upperType}(preparedStatement, {whereFieldStatus.index}, {whereField.javaName});{\n}
			{endloop}
		{endif}
		{\n}

	{\t}{\t}{\t}return(preparedStatement.executeUpdate());{\n}

	{\t}{\t}}{\n}
	{\t}}{\n}
	{\n}


	{-- SQLITE DOES NOT ALLOW LIMITS ON DELETERS }

  	{\t}// USER DEFINED DELETER CONNECTION, PARAMS SILENT{\n}
  	{\t}/**{\n}
  	{\t} * {deleter.name} - {if deleter.isAutoDeleter}from 'fieldDeleters' JSON key{else}from 'deleters' JSON key{endif}{\n}
  	{\t} *{\n}
  	{\t} * This is the main method for all other deleter methods with the same prefix,{\n}
  	{\t} * including the (silent method signatures).  All methods chain to this one.{\n}
  	{\t} * {\n}

  {set deleter as queryObject}
  {set tableOrView.name as tableName}
  {set "true" as hasConnection}
  {set "false" as hasLimit}
  {set "false" as hasOffset}
  {import classpath:/snippet/global/java-query-objects-method-where-comments.templar}

  	{\t} * {\n}
  	{\t} * @return the number of rows deleted{\n}
  	{\t} */{\n}
  	{\t}public static int {deleter.name}Silent(
		{--
			Now for the where field parameters
		}
{set deleter as queryObject}
{set "true" as hasConnection}
{set "false" as hasLimit}
{set "false" as hasOffset}
{import classpath:/snippet/global/java-query-objects-method-where-parameters.templar}) {{{\n}
  	{\t}{\t}try {{{\n}
  	{\t}{\t}{\t}return({deleter.name}(connection{if fn:>[fn:length[deleter.whereFields], '0']}, {endif}{loop deleter.whereFields as whereField}
  		{whereField.javaName}{if whereField.isInField}List{endif}
  		{if whereFieldStatus.last}{else}, {endif}
  	{endloop}));{\n}
  	{\t}{\t}} catch (SQLException ex) {{{\n}
  	{\t}{\t}{\t}LOGGER.error("Could not {deleter.name}, a SQL Exception occurred.", ex);{\n}
  	{\t}{\t}{\t}return(-1);{\n}
  	{\t}{\t}}{\n}
  	{\t}}{\n}
  	{\n}


{endif}

{if fn:notEqual[options.database, "sqlite3"]}
{-- SQLITE DOES NOT ALLOW LIMITS ON DELETERS }

	{\t}// USER DEFINED DELETER CONNECTION, PARAMS, LIMIT SILENT{\n}
	{\t}/**{\n}
	{\t} * {deleter.name} - {if deleter.isAutoDeleter}from 'fieldDeleters' JSON key{else}from 'deleters' JSON key{endif}{\n}
	{\t} *{\n}
	{\t} * This is the main method for all other deleter methods with the same prefix,{\n}
	{\t} * including the (silent method signatures).  All methods chain to this one.{\n}
	{\t} * {\n}

{set deleter as queryObject}
{set tableOrView.name as tableName}
{set "true" as hasConnection}
{set "true" as hasLimit}
{set "false" as hasOffset}
{import classpath:/snippet/global/java-query-objects-method-where-comments.templar}

	{\t} * {\n}
	{\t} * @return the number of rows deleted{\n}
	{\t} */{\n}
	{\t}public static int {deleter.name}Silent(
{--
	Now for the where field parameters
}
{set deleter as queryObject}
{set "true" as hasConnection}
{set "true" as hasLimit}
{set "false" as hasOffset}
{import classpath:/snippet/global/java-query-objects-method-where-parameters.templar}) {{{\n}
	{\t}{\t}try {{{\n}
	{\t}{\t}{\t}return({deleter.name}(null{if fn:>[fn:length[deleter.whereFields], '0']}, {endif}{loop deleter.whereFields as whereField}
		{whereField.javaName}{if whereField.isInField}List{endif}
		{if whereFieldStatus.last}{else}, {endif}
	{endloop}, limit));{\n}
	{\t}{\t}} catch (SQLException ex) {{{\n}
	{\t}{\t}{\t}LOGGER.error("Could not {deleter.name}, a SQL Exception occurred.", ex);{\n}
	{\t}{\t}{\t}return(-1);{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}
	{\n}
{endif}


{if fn:notEqual[options.database, "sqlite3"]}
	{\t}// USER DEFINED DELETER - CONNECTION, PARAMS, NULL - LOUD{\n}

	{\t}public static int {deleter.name}(
	{--
		Now for the where fields
	}
{set deleter as queryObject}
{set "true" as hasConnection}
{set "false" as hasLimit}
{set "false" as hasOffset}
{import classpath:/snippet/global/java-query-objects-method-where-parameters.templar}) throws SQLException {{{\n}
	{\t}{\t}{\t}return({deleter.name}(connection{if fn:>[deleterFieldsLength, '0']}, {endif}{loop deleter.whereFields as whereField}
		{whereField.javaName}{if whereField.isInField}List{endif}
		{if whereFieldStatus.last}{else}, {endif}
	{endloop}{if fn:notEqual[options.database, "sqlite3"]}, null{endif}));{\n}
	{\t}}{\n}
	{\n}


	{\t}// USER DEFINED DELETER - CONNECTION, PARAMS, NULL - SILENT{\n}

	{\t}public static int {deleter.name}Silent(
	{--
		Now for the where fields
	}
{set deleter as queryObject}
{set "true" as hasConnection}
{set "false" as hasLimit}
{set "false" as hasOffset}
{import classpath:/snippet/global/java-query-objects-method-where-parameters.templar}) {{{\n}
	{\t}{\t}try {{{\n}
	{\t}{\t}{\t}return({deleter.name}(connection{if fn:>[deleterFieldsLength, '0']}, {endif}{loop deleter.whereFields as whereField}
		{whereField.javaName}{if whereField.isInField}List{endif}
		{if whereFieldStatus.last}{else}, {endif}
	{endloop}{if fn:notEqual[options.database, "sqlite3"]}, null{endif}));{\n}
	{\t}{\t}} catch (SQLException ex) {{{\n}
	{\t}{\t}{\t}LOGGER.error("Could not {deleter.name}, a SQL Exception occurred.", ex);{\n}
	{\t}{\t}{\t}return(-1);{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}
{endif}



{if fn:notEqual[options.database, "sqlite3"]}
{-- SQLITE DOES NOT ALLOW LIMITS ON DELETERS }

	{\t}// USER DEFINED DELETER - NULL, PARAMS, LIMIT{\n}

	{\t}/**{\n}
	{\t} * {deleter.name} - {if deleter.isAutoDeleter}from 'fieldDeleters' JSON key{else}from 'deleters' JSON key{endif}.{\n}
	{\t} * {\n}

{set deleter as queryObject}
{set tableOrView.name as tableName}
{set "false" as hasConnection}
{set "true" as hasLimit}
{set "false" as hasOffset}
{import classpath:/snippet/global/java-query-objects-method-where-comments.templar}

	{\t} * {\n}
	{\t} * @return the number of rows deleted or -1 if there was an error{\n}
	{\t} */{\n}

	{\t}public static int {deleter.name}(
	{--
		Now for the where fields
	}
{set deleter as queryObject}
{set "false" as hasConnection}
{set "true" as hasLimit}
{set "false" as hasOffset}
{import classpath:/snippet/global/java-query-objects-method-where-parameters.templar}) throws SQLException {{{\n}
	{\t}{\t}try (Connection connection = ConnectionManager.getConnection()){{{\n}
	{\t}{\t}{\t}return({deleter.name}(null{if fn:>[fn:length[deleter.whereFields], '0']}, {endif}{loop deleter.whereFields as whereField}
		{whereField.javaName}{if whereField.isInField}List{endif}
		{if whereFieldStatus.last}{else}, {endif}
	{endloop}, limit));{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}
	{\n}

	{\t}// USER DEFINED DELETER - NULL, PARAMS, LIMIT (SILENT){\n}

	{\t}/**{\n}
	{\t} * {deleter.name} - {if deleter.isAutoDeleter}from 'fieldDeleters' JSON key{else}from 'deleters' JSON key{endif}.{\n}
	{\t} * {\n}

{set deleter as queryObject}
{set tableOrView.name as tableName}
{set "false" as hasConnection}
{set "true" as hasLimit}
{set "false" as hasOffset}
{import classpath:/snippet/global/java-query-objects-method-where-comments.templar}

	{\t} * {\n}
	{\t} * @return the number of rows deleted or -1 if there was an error{\n}
	{\t} */{\n}

	{\t}public static int {deleter.name}Silent(
	{--
		Now for the where fields
	}
{set deleter as queryObject}
{set "false" as hasConnection}
{set "true" as hasLimit}
{set "false" as hasOffset}
{import classpath:/snippet/global/java-query-objects-method-where-parameters.templar}) {{{\n}
	{\t}{\t}try (Connection connection = ConnectionManager.getConnection()){{{\n}
	{\t}{\t}{\t}return({deleter.name}(null{if fn:>[fn:length[deleter.whereFields], '0']}, {endif}{loop deleter.whereFields as whereField}
		{whereField.javaName}{if whereField.isInField}List{endif}
		{if whereFieldStatus.last}{else}, {endif}
	{endloop}, limit));{\n}
	{\t}{\t}} catch (SQLException ex) {{{\n}
	{\t}{\t}{\t}LOGGER.error("Could not {deleter.name}, a SQL Exception occurred.", ex);{\n}
	{\t}{\t}{\t}return(-1);{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}
	{\n}

{endif}

	{\t}// USER DEFINED DELETER - NULL, PARAMS, NULL LOUD{\n}

	{\t}/**{\n}
	{\t} * {deleter.name} - {if deleter.isAutoDeleter}from 'fieldDeleters' JSON key{else}from 'deleters' JSON key{endif}.{\n}
	{\t} * This will silently swallow any exceptions.{\n}
	{\t} * {\n}

{set deleter as queryObject}
{set tableOrView.name as tableName}
{set "false" as hasConnection}
{set "false" as hasLimit}
{set "false" as hasOffset}
{import classpath:/snippet/global/java-query-objects-method-where-comments.templar}

	{\t} * {\n}
	{\t} * @return the number of rows deleted or -1 if there was an error{\n}
	{\t} */{\n}

  {\n}

	{\t}public static int {deleter.name}(
{--
	Now for the where fields
}
{set deleter as queryObject}
{set "false" as hasConnection}
{set "false" as hasLimit}
{set "false" as hasOffset}
{import classpath:/snippet/global/java-query-objects-method-where-parameters.templar}) throws SQLException {{{\n}
	{\t}{\t}try (Connection connection = ConnectionManager.getConnection()) {{{\n}
	{\t}{\t}{\t}return({deleter.name}(connection{if fn:>[deleterFieldsLength, '0']}, {endif}{loop deleter.whereFields as whereField}
		{whereField.javaName}{if whereField.isInField}List{endif}
		{if whereFieldStatus.last}{else}, {endif}
	{endloop}{if fn:notEqual[options.database, "sqlite3"]}, null{endif}));{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}
{\n}

	{\t}// USER DEFINED DELETER - NULL, PARAMS, NULL SILENT{\n}

	{\t}/**{\n}
	{\t} * {deleter.name} - {if deleter.isAutoDeleter}from 'fieldDeleters' JSON key{else}from 'deleters' JSON key{endif}.{\n}
	{\t} * This will silently swallow any exceptions.{\n}
	{\t} * {\n}

{set deleter as queryObject}
{set tableOrView.name as tableName}
{set "false" as hasConnection}
{set "false" as hasLimit}
{set "false" as hasOffset}
{import classpath:/snippet/global/java-query-objects-method-where-comments.templar}

	{\t} * {\n}
	{\t} * @return the number of rows deleted or -1 if there was an error{\n}
	{\t} */{\n}

  {\n}

	{\t}public static int {deleter.name}Silent(
{--
	Now for the where fields
}
{set deleter as queryObject}
{set "false" as hasConnection}
{set "false" as hasLimit}
{set "false" as hasOffset}
{import classpath:/snippet/global/java-query-objects-method-where-parameters.templar}) {{{\n}
	{\t}{\t}try (Connection connection = ConnectionManager.getConnection()) {{{\n}
	{\t}{\t}{\t}return({deleter.name}(connection{if fn:>[deleterFieldsLength, '0']}, {endif}{loop deleter.whereFields as whereField}
		{whereField.javaName}{if whereField.isInField}List{endif}
		{if whereFieldStatus.last}{else}, {endif}
	{endloop}{if fn:notEqual[options.database, "sqlite3"]}, null{endif}));{\n}
	{\t}{\t}} catch (SQLException ex) {{{\n}
	{\t}{\t}{\t}LOGGER.error("Could not {deleter.name}, a SQL Exception occurred.", ex);{\n}
	{\t}{\t}{\t}return(-1);{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}
{\n}
{endloop}


}