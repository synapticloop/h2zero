{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
		PACKAGE DECLARATION, IMPORT STATEMENTS AND CLASS DEFINITION

 		NOTES:
		  If the table is a constant - then this file will not be generated
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

package {database.package}.updater;{\n}{\n}
// - - - - thoughtfully generated by synapticloop h2zero - - - - {\n}
//    with the use of synapticloop templar templating language{\n}
//              (java-create-updater.templar){\n}{\n}

import java.sql.Connection;{\n}
import java.sql.PreparedStatement;{\n}
import java.sql.SQLException;{\n}
import java.sql.Types;{\n}
import java.sql.Timestamp;{\n}
{\n}
import com.synapticloop.h2zero.base.manager.{options.database}.ConnectionManager;{\n}
import {database.package}.model.util.Constants;{\n}
{\n}
{import classpath:/snippet/global/java-logger.templar}
{\n}

public class {table.javaClassName}Updater {{{\n}
{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				THE UPDATER STRINGS FIELDS
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}
{set "Updater" as classType}
{set table as baseSchemaObject}
{import classpath:/snippet/global/java-binder-declaration.templar}

{set table.javaClassName as loggerClass}
{import classpath:/snippet/global/java-logger-declaration.templar}
{\n}
{\t}// static fields generated by synapticloop h2zero{\n}
{\t}private static final String SQL_UPDATE_START = "update {table.name} ";{\n}{\n}

{\t}// static fields generated from the user input{\n}
{loop table.updaters as updater}
	{\t}private static final String SQL_{updater.staticName} = SQL_UPDATE_START
	{if fn:notNull[updater.setClause]} + " {updater.setClause}"{endif}
	{if fn:notNull[updater.whereClause]} + " {updater.whereClause}"{endif};{\n}
{endloop}
{\n}

{\t}private {table.javaClassName}Updater() {{}{\n}{\n}

{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				THE UPDATER STATEMENTS
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}
{loop table.updaters as updater}
	{set updater as baseQueryObject}
	{set fn:length[updater.updateFields] as updateFieldsLength}
	{set fn:length[updater.whereFields] as whereFieldsLength}

	{\t}/**{\n}
	{\t} * This is the updater for '{updater.name}' and will throw a SQLException on error{\n}
	{\t} * See the '{updater.name}Silent' method for a non-throwing method.{\n}
	{\t} * {\n}
	{\t} * @param connection the connection to the database{\n}
{loop baseQueryObject.updateFields as setField}
	{\t} * @param {setField.javaName}{if setField.isInField}List{endif} the field to set as a {if setField.isInField}List<{whereField.javaType}>{else}{setField.javaType}{endif}{\n}
{endloop}

{if baseQueryObject.hasWhereFieldAliases}
	{loop baseQueryObject.whereFields as whereField}
		{\t} * @param {whereField.javaName}{if whereField.isInField}List{endif} - The where clause to set as a {if whereField.isInField}List<{whereField.javaType}>{else}{whereField.javaType}{endif}{\n}
	{endloop}
{else}
	{loop baseQueryObject.uniqueWhereFields as whereField}
		{\t} * @param {whereField.javaName}{if whereField.isInField}List{endif} - The where clause to set as a {if whereField.isInField}List<{whereField.javaType}>{else}{whereField.javaType}{endif}{\n}
	{endloop}
{endif}	{\t} * {\n}
	{\t} * @return The number of rows that were updated{\n}
	{\t} * @throws SQLException if there was an error in the statement or database connection{\n}
	{\t} */ {\n}
	{\t}public static int {updater.name}(Connection connection
	{--
		Now for the set and where fields
	}

		{import classpath:/snippet/global/java-method-parameters-with-connection.templar}
	) throws SQLException {{{\n}

	{\t}{\t}try (PreparedStatement preparedStatement = connection.prepareStatement(SQL_{updater.staticName})) {{{\n}

	{set '0' as updateFieldsIndex}
	{loop updater.updateFields as updateField}
		{set updateFieldStatus.index as updateFieldsIndex}
		{\t}{\t}{\t}ConnectionManager.set{updateField.upperType}(preparedStatement, {updateFieldStatus.index}, {updateField.javaName});{\n}
	{endloop}

	{loop updater.whereFields as whereField}
		{\t}{\t}{\t}ConnectionManager.set{whereField.upperType}(preparedStatement, {fn:+[whereFieldStatus.index, updateFieldsIndex]}, {whereField.javaName});{\n}
	{endloop}

	{\n}

	{\t}{\t}{\t}return(preparedStatement.executeUpdate());{\n}
	{\t}{\t}}{\n}

	{\t}}{\n}
{\n}




	{\t}/**{\n}
	{\t} * This is the updater for '{updater.name}' and will throw a SQLException on error{\n}
	{\t} * See the '{updater.name}Silent' method for a non-throwing method.{\n}
	{\t} * {\n}
{loop baseQueryObject.updateFields as setField}
	{\t} * @param {setField.javaName}{if setField.isInField}List{endif} the field to set as a {if setField.isInField}List<{whereField.javaType}>{else}{setField.javaType}{endif}{\n}
{endloop}

{if baseQueryObject.hasWhereFieldAliases}
	{loop baseQueryObject.whereFields as whereField}
		{\t} * @param {whereField.javaName}{if whereField.isInField}List{endif} - The where clause to set as a {if whereField.isInField}List<{whereField.javaType}>{else}{whereField.javaType}{endif}{\n}
	{endloop}
{else}
	{loop baseQueryObject.uniqueWhereFields as whereField}
		{\t} * @param {whereField.javaName}{if whereField.isInField}List{endif} - The where clause to set as a {if whereField.isInField}List<{whereField.javaType}>{else}{whereField.javaType}{endif}{\n}
	{endloop}
{endif}	{\t} * {\n}
	{\t} * @return The number of rows that were updated or -1 on error{\n}
	{\t} */ {\n}

	{\t}public static int {updater.name}(

		{import classpath:/snippet/global/java-method-parameters.templar}

	) throws SQLException {{{\n}

	{\t}{\t}try (Connection connection = ConnectionManager.getConnection()) {{{\n}
	{\t}{\t}{\t}return({updater.name}(connection{if fn:>[fn:+[updateFieldsLength, whereFieldsLength], '0']}, {endif}

		{import classpath:/snippet/global/java-method-parameters-call.templar}

	));{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}
{\n}





	{\t}/**{\n}
	{\t} * This is the updater for '{updater.name}' and will silently swallow any {\n}
	{\t} * SQLException on error and return a -1 as the number of rows updated.{\n}
	{\t} * See the '{updater.name}' method for a throwing method.{\n}
	{\t} * {\n}
{loop baseQueryObject.updateFields as setField}
	{\t} * @param {setField.javaName}{if setField.isInField}List{endif} the field to set as a {if setField.isInField}List<{whereField.javaType}>{else}{setField.javaType}{endif}{\n}
{endloop}

{if baseQueryObject.hasWhereFieldAliases}
	{loop baseQueryObject.whereFields as whereField}
		{\t} * @param {whereField.javaName}{if whereField.isInField}List{endif} - The where clause to set as a {if whereField.isInField}List<{whereField.javaType}>{else}{whereField.javaType}{endif}{\n}
	{endloop}
{else}
	{loop baseQueryObject.uniqueWhereFields as whereField}
		{\t} * @param {whereField.javaName}{if whereField.isInField}List{endif} - The where clause to set as a {if whereField.isInField}List<{whereField.javaType}>{else}{whereField.javaType}{endif}{\n}
	{endloop}
{endif}	{\t} * {\n}
	{\t} * @return The number of rows that were updated or -1 on error{\n}
	{\t} */ {\n}

	{\t}public static int {updater.name}Silent(

		{import classpath:/snippet/global/java-method-parameters.templar}

	) {{{\n}
	{\t}{\t}try (Connection connection = ConnectionManager.getConnection()) {{{\n}
	{\t}{\t}{\t}return({updater.name}(connection{if fn:>[fn:+[updateFieldsLength, whereFieldsLength], '0']}, {endif}

		{import classpath:/snippet/global/java-method-parameters-call.templar}

	));{\n}
	{\t}{\t}} catch (SQLException sqlex) {{{\n}
	{import classpath:/snippet/global/exception-sql-log-silent.templar}
	{\t}{\t}{\t}return(-1);{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}
{\n}
{endloop}
}