package {database.package}.counter;{\n}{\n}
// - - - - thoughtfully generated by synapticloop h2zero - - - - {\n}
//    with the use of synapticloop templar templating language{\n}
//       (/java/counter/java-create-view-counter.templar){\n}{\n}

import java.sql.Connection;{\n}
import java.sql.PreparedStatement;{\n}
import java.sql.ResultSet;{\n}
import java.sql.SQLException;{\n}
import java.util.HashMap;{\n}
import java.util.Map;{\n}
import java.util.List;{\n}
import java.sql.*;{\n}
{\n}
import com.synapticloop.h2zero.base.manager.{options.database}.ConnectionManager;{\n}
{\n}
{import classpath:/java/snippet/global/java-logger-import.templar}
{\n}
import {database.package}.model.util.Constants;{\n}
{\n}

import com.synapticloop.h2zero.base.sql.nolimitoffset.Counter;{\n}
{\n}
/**{\n}
 * <p>This class contains all of the counters that are defined in the h2zero{\n}
 * file.</p>{\n}
 * {\n}
 * <p>A counter may only return a simple integer (i.e. the count) response{\n}
 * from a query.</p>{\n}
 * {\n}
 * <p>View name: <code>{table.name}</code></p>{\n}
 * {\n}
{loop table.counters as counter}
	{if counterStatus.first}
 * <p>Counters defined:{\n}
 * <ul>{\n}
	{endif}
 * <li><code>{counter.name}</code> - SQL query run {{@link #SQL_{counter.staticName}}</li>{\n}
	{if counterStatus.last}
 * </ul>{\n}
	{endif}
{endloop}
 * {\n}
* <p>To execute any counter SQL query, you may optionally pass in a connection, and execute it (silently if desired)</p>{\n}
 *{\n}
 * <p><strong><em>Executing a counter without a passed in connection.</em></strong></p>{\n}
 *{\n}
 * <pre>{table.javaClassName}Counter.counterName(parameter1, parameter2, ...){\n}
 *          .execute();{\n}
 * </pre>{\n}
 *{\n}
 * <p><strong><em>Executing a counter WITH a passed in connection.</em></strong></p>{\n}
 *{\n}
 * <pre>{table.javaClassName}Counter.counterName(parameter1, parameter2, ...){\n}
 *          .withConnection(connection){\n}
 *          .execute();{\n}
 *  </pre>{\n}
 *{\n}
 * <p><strong><em>Executing a counter WITHOUT a passed in connection SILENTLY{\n}
 * (i.e. All Exceptions are silently swallowed and logged as an error through{\n}
 * the logger.)</em></strong></p>{\n}
 *{\n}
 * <pre>{table.javaClassName}Counter.counterName(parameter1, parameter2, ...){\n}
 *          .executeSilent();{\n}
 * </pre>{\n}
 *{\n}
 * <p><strong><em>Executing a counter WITH a passed in connection SILENTLY{\n}
 * (i.e. All Exceptions are silently swallowed and logged as an error through{\n}
 * the logger.)</em></strong></p>{\n}
 *{\n}
 * <pre>{table.javaClassName}Counter.counterName(parameter1, parameter2, ...){\n}
 *          .withConnection(connection){\n}
 *          .executeSilent();{\n}
 * </pre>{\n}
 *{\n}
 * @author synapticloop h2zero{\n}
 * {\n}
 * <p>@see <a href="https://github.com/synapticloop/h2zero">Synapticloop h2zero GitHub repository</a></p>{\n}
 */{\n}
public class {table.javaClassName}ViewCounter {{{\n}

	{set view as baseSchemaObject}
	{import classpath:/java/snippet/global/java-binder-declaration.templar}

	{set "ViewCounter" as classType}
	{set baseSchemaObject.javaClassName as loggerClass}
	{import classpath:/java/snippet/global/java-logger-declaration.templar}{\n}
	{\n}

{\t}private static final String SQL_BUILTIN_COUNT_ALL = "select count(*) from {table.name}";{\n}
{\n}
{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				THE COUNT FINDERS FOR THE SELECT CLAUSES AND NORMAL CLAUSES
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

{loop table.counters as counter}
	{\t}private static final String SQL_{counter.staticName} = "{counter.selectClause}"
	{if fn:notNull[counter.whereClause]} + " {counter.whereClause}"{endif}
	{if fn:notNull[counter.orderBy]} + " order by {counter.orderBy}"{endif};{\n}
{endloop}
{\n}

{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				THE COUNT FINDERS FOR THE SELECT CLAUSES CACHES
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

{loop table.counters as counter}
	{if counter.hasInFields}
		{\t}private static Map<String, String> {counter.name}_statement_cache = new HashMap<String, String>();{\n}
	{endif}
{endloop}

{\n}
{\t}private {table.javaClassName}ViewCounter() {{}{\n}
{\n}
{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				FIND COUNT ALL
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

{\t}/**{\n}
{\t} * Find the count of all {table.javaClassName} objects{\n}
{\t} * {\n}
{\t} * @return the count of {table.javaClassName} objects{\n}
{\t} * {\n}
{\t} * @throws SQLException if there was an error in the SQL statement{\n}
{\t} */{\n}

{\t}public static Counter countAll() throws SQLException {{{\n}
{\t}return({\n}
{\t}{\t}new Counter({\n}
{\t}{\t}{\t}{\t}LOGGER,{\n}
{\t}{\t}{\t}{\t}SQL_BUILTIN_COUNT_ALL));{\n}
{\t}}{\n}
{\n}

{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				AND THE SELECT CLAUSE COUNTERS
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

{loop table.counters as counter}
	{set counter as baseQueryObject}

{\t}/**{\n}
{\t} * <p>Return the counter object (optionally setting a connection) for this query,{\n}
{\t} * ready for execution.</p>{\n}
{\t} *{\n}
{\t} * <p>A <code>Connection</code> object may optionally be set for this query.{\n}
{\t} * Note that if no connection is set, one will automatically be retrieved from{\n}
{\t} * the connection pool.</p>{\n}
{\t} *{\n}
{\t} * <p><code>.withConnection(connection)</code></p>{\n}
{\t} *{\n}
{\t} * <p>And then can be executed with the following call:</p>{\n}
{\t} *{\n}
{\t} * <p><code>.execute()</code></p>{\n}
{\t} *{\n}
{\t} * <p>Alternatively the call can be executed silently (i.e. any exceptions that{\n}
{\t} * may have been thrown will be silently swallowed and the error logged.)</p>{\n}
{\t} *{\n}
{\t} * <p><code>.executeSilent()</code></p>{\n}
{\t} *{\n}
{\t} * <p>This counter executes the following sql statement:</p>{\n}
{\t} *{\n}
{\t} * <pre>{counter.selectClause}{\n}
{if fn:notNull[counter.whereClause]}{\t} * {counter.whereClause}{\n}{endif}
{\t} * </pre>{\n}
{\t} *{\n}
{loop counter.whereFields as whereField}
{if whereField.isInField}
	{\t} * @param {whereField.javaName}List The list of <code>{whereField.name}<code> fields to be {\n}
	{\t} *        set on the prepared SQL statement which is part of an 'in' clause.{\n}
{else}
	{\t} * @param {whereField.javaName}{if whereField.isInField}List{endif} maps to the <code>{whereField.name}<code> field{\n}
{endif}
{endloop}
{\t} *{\n}
{\t} * @return The counter object (optionally setting a connection) ready for {\n}
{\t} *    and execution.{\n}
{\t} */{\n}

{\t}public static Counter {counter.name}(
	{import classpath:/java/snippet/global/java-method-parameters.templar}
) {{{\n}
{\t}{\t}return({\n}
{\t}{\t}{\t}{\t}new Counter({\n}
{\t}{\t}{\t}{\t}{\t}{\t}LOGGER, {\n}
{\t}{\t}{\t}{\t}{\t}{\t}SQL_{counter.staticName}, {\n}
{\t}{\t}{\t}{\t}{\t}{\t}new Object[] {{ {import classpath:/java/snippet/global/java-method-parameters-call.templar} } ));{\n}
{\t}}{\n}
{\n}
{endloop}
}
