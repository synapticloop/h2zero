package {database.package}.view;{\n}{\n}

//        - - - - thoughtfully generated by synapticloop h2zero - - - -        {\n}
//          with the use of synapticloop templar templating language{\n}
//              (/java/model/java-create-view-model.templar){\n}{\n}

import com.synapticloop.h2zero.base.view.ViewBase;{\n}
import com.synapticloop.h2zero.util.XmlHelper;{\n}
{\n}
{if fn:requiresImport[table, "Date"]}import java.sql.Date;{\n}{endif}
{if fn:requiresImport[table, "Clob"]}import java.sql.Clob;{\n}{endif}
{if fn:requiresImport[table, "Blob"]}import java.sql.Blob;{\n}{endif}
{if fn:requiresImport[table, "Timestamp"]}import java.sql.Timestamp;{\n}{endif}
{if fn:requiresImport[table, "Time"]}import java.sql.Time;{\n}{endif}
import {database.package}.model.util.Constants;{\n}
import org.json.JSONObject;{\n}
import com.synapticloop.h2zero.base.model.ModelBaseHelper;{\n}

{\n}{\n}

{--
  if this isn't a lookup on a foreign key and if the foreign key is not a constant
  table, then we need to import the finder
}
{loop table.fields as field}
	{if fn:and[fn:notNull[field.foreignKeyTable], !field.foreignKeyTableLookup.isConstant]}
		import {database.package}.finder.{field.foreignKeyTableLookup.javaClassName}Finder;{\n}
		import {database.package}.model.{field.foreignKeyTableLookup.javaClassName};{\n}
	{endif}
{endloop}

/**{\n}
 * <p>This is the model for the <code>{view.javaClassName}</code> which maps to the <code>{view.name}</code> database view.</p>{\n}
 * {\n}
 * <p>This model maps all of the fields from the database as defined in the{\n}
 * <code>.h2zero</code> file.  The parsed definition of the table and fields are:</p>{\n}
 * {\n}
 * <p><strong>NOTE:</strong> This is a view which cannot be changed and no CRUD methods are available.</p>{\n}
 * {\n}
 * <p>This view was created with the following SQL select statement:</p>{\n}
 * <pre>{\n}{loop view.asClauseLines as asClauseLine}
 * {asClauseLine}{\n}{endloop}</pre>{\n}
 * {\n}
 * <p>With the following fields defined:</p>{\n}
 * {\n}
 * <table>{\n}
 *   <thead>{\n}
 *     <tr>{\n}
 *       <th>Field name</th>{\n}
 *       <th>SQL type</th>{\n}
 *       <th>Field length<br />(min:max)</th>{\n}
 *       <th>Nullable?</th>{\n}
 *       <th>Keys</th>{\n}
 *       <th>Comments</th>{\n}
 *     </tr>{\n}
 *   </thead>{\n}
 *   <tbody>{\n}

{loop view.fields as field}
 *     <tr>{\n}
 *       <td><code>{field.name}</code></td>{\n}
 *       <td>{field.type}</td>{\n}
 *       <td>{if !fn:=[field.maxLength, "0"]}({field.minLength}:{field.maxLength}){else} -- {endif}</td>{\n}
 *       <td>{field.nullable}</td>{\n}
 *       <td>{if field.primary}<code>primary</code>{endif}
{if field.unique} <primary>unique</primary>{endif}
{if fn:notNull[field.foreignKeyTable]} <code>foreign -> {field.foreignKeyTable}.{field.foreignKeyField}</code>{endif}</td>{\n}
 *       <td>{if fn:null[field.comment]} -- {else}{field.comment}{endif}</td>{\n}
 *     </tr>{\n}
{endloop}

 *   </tbody>{\n}
 * </table>{\n}
 * {\n}
 * @author synapticloop h2zero{\n}
 * {\n}
 * <p>@see <a href="https://github.com/synapticloop/h2zero">Synapticloop h2zero GitHub repository</a></p>{\n}
 */{\n}
public class {view.javaClassName} extends ViewBase {{{\n}
{\t}// the binder is unused in code, but will generate compile problems if this {\n}
{\t}// class is no longer referenced in the h2zero file. Just a nicety for{\n}
{\t}// removing dead code{\n}
{\t}@SuppressWarnings("unused"){\n}
{\t}private static final String BINDER = Constants.{view.upperName}_BINDER;{\n}{\n}

{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				LIST ALL OF THE JAVA FIELDS
}

{loop table.fields as field}
	{if fn:notNull[field.foreignKeyTable]}
		{if !field.foreignKeyTableLookup.isConstant}
			{\t}private {field.foreignKeyTableLookup.javaClassName} {field.secondaryJavaName} = null;{\n}
		{endif}
	{endif}
	{if fieldStatus.last}
		{\n}
	{endif}
{endloop}

{loop table.fields as field}
	{\t}private {field.javaType} {field.javaName} = null;{\n}
{endloop}
{\n}


{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				CONSTRUCTORS
			what about null-able fields?
}

{\t}public {view.javaClassName}(
	{loop view.fields as field}
		{field.javaType} {field.javaName}
		{if fieldStatus.last}{else}, {endif}
	{endloop}
) {{{\n}
	{loop view.fields as field}
		{\t}{\t}this.{field.javaName} = {field.javaName};{\n}
	{endloop}

{\t}}{\n}
{\n}


	{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					SETTERS AND GETTERS

					The first getter is for any referenced foreign key tables that exist
					which will get the actual object, rather than the primary key that 
					references it.
	}

	{loop table.fields as field}
		{if fn:notNull[field.foreignKeyTable]}
			{\t}public {field.foreignKeyTableLookup.javaClassName} get{field.secondaryJavaName}() {{{\n}
			{if !field.foreignKeyTableLookup.isConstant}
				{\t}{\t}if(null == this.{field.secondaryJavaName}) {{{\n}

				{\t}{\t}{\t}this.{field.secondaryJavaName} = {field.foreignKeyTableLookup.javaClassName}Finder.findByPrimaryKey(this.{field.javaName}).executeSilent();{\n}

				{\t}{\t}}{\n}

				{\t}{\t}return(this.{field.secondaryJavaName});{\n}
			{else}

				{--
					At this point the foreign table is constant so it was already looked up
					at construction time
				}

				{\t}{\t}return({field.foreignKeyTableLookup.javaClassName}.ALL_LOOKUP.get(this.{field.javaName}));{\n}
			{endif}

			{\t}}{\n}{\n}
		{endif}
	{endloop}

{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				GETTERS ONLY
}
{\t}/*{\n}
{\t} * Boring ol' getters{\n}
{\t} */{\n}
{\n}

{loop view.fields as field}
		{\t}/**{\n}
		{\t} * <p>Return the value of the {field.name}, updating the hit count for this field.</p>{\n}
		{\t} * {\n}
		{\t} * @return the value of the {field.name} which may {if !field.nullable}NOT {endif}be null.{\n}
		{\t} */{\n}
	{\t}public {field.javaType} get{field.javaAccessorName}() {{ return(this.{field.javaName}); }{\n}{\n}
{endloop}

	{-- Now we need the toString Method--}
	{\n}
	{\t}@Override{\n}
{--    --}{\t}public String toString() {{{\n}
{--    --}{\t}{\t}return(new StringBuilder(){\n}
{--    --}{\t}{\t}{\t}.append("Model: '{table.javaClassName}'\n"){\n}
{loop table.fields as field}
	{if field.isSecure}
{--    --}{\t}{\t}{\t}.append("  Field: '{field.javaName}:<**secure**>'\n"){\n}
	{else}
{--    --}{\t}{\t}{\t}.append("  Field: '{field.javaName}:").append(this.{field.javaName}).append("'\n"){\n}
	{endif}
	{if fieldStatus.last}{\t}{\t}{\t}.toString());{\n}{endif}
{endloop}

{--    --}{\t}}{\n}



	{-- Now we need the toJsonString Method--}
	{\n}
		{\t}public String toJsonString() {{{\n}
		{\t}{\t}return(toJSON().toString());{\n}
		{\t}}{\n}
		{\n}

	{-- and the getJSONString - for chaining --}
	{\t}public JSONObject getToJSON() {{{\n}
	{\t}{\t}return(toJSON());{\n}
	{\t}}{\n}

	{-- Now we need the toJson Method--}
	{\n}
	{\t}public JSONObject toJSON() {{{\n}
	{\t}{\t}JSONObject jsonObject = new JSONObject();{\n}
	{\n}
	{\t}{\t}jsonObject.put("type", "view");{\n}
	{\t}{\t}jsonObject.put("name", "{table.javaClassName}");{\n}
	{\t}{\t}JSONObject fieldsObject = new JSONObject();{\n}
	{\n}
	{loop table.fields as field}
		{if !field.isSecure}
			{\t}{\t}ModelBaseHelper.addToJSONObject(fieldsObject, "{field.javaName}", this.get{field.javaAccessorName}());{\n}
		{endif}
	{endloop}
{\n}
	{\t}{\t}jsonObject.put("fields", fieldsObject);{\n}{\n}

	{\t}{\t}return(jsonObject);{\n}
	{\t}}{\n}
	{\n}

	{-- and the getJSONString - for chaining --}
	{\t}public String getJsonString() {{{\n}
	{\t}{\t}return(toJsonString());{\n}
	{\t}}{\n}


{\n}
	{\t}/**{\n}
	{\t} * <p>Return an XML representation of the <code>{view.javaClassName}</code> model as a <code>String</code>, {\n}
	{\t} * with the root node being the name of the table - i.e. <code>&lt;{view.name} /&gt;</code> {\n}
	{\t} * and the child nodes the name of the fields.</p>{\n}
	{\t} * {\n}
	{\t} * <p><strong>NOTE:</strong> Any field marked as secure will not be included as{\n}
	{\t} * part of the XML document</p>{\n}
	{\t} * {\n}
	{\t} * @return An XML representation of the model as a <code>String</code>.{\n}
	{\t} */{\n}

	{\t}public String toXMLString() {{{\n}
	{\t}{\t}return("<{table.name}>" + {\n}
	{loop view.fields as field}
		{if !field.isSecure}
			{if fn:=[field.javaType, "String"]}
				{\t}{\t}{\t}String.format("<{field.name} null=\"%b\">%s</{field.name}>", (this.get{field.javaAccessorName}() == null), (this.get{field.javaAccessorName}() != null ? XmlHelper.escapeXml(this.get{field.javaAccessorName}()) : "")) + {\n}
			{else}
				{\t}{\t}{\t}String.format("<{field.name} null=\"%b\">%s</{field.name}>", (this.get{field.javaAccessorName}() == null), (this.get{field.javaAccessorName}() != null ? this.get{field.javaAccessorName}() : "")) + {\n}
			{endif}
		{endif}
	{endloop}

	{\t}{\t}{\t}"</{table.name}>");{\n}
	{\t}}{\n}
	{\n}

}
