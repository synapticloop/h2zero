package {database.package}.model;{\n}{\n}

//        - - - - thoughtfully generated by synapticloop h2zero - - - -        {\n}
//          with the use of synapticloop templar templating language{\n}
//                  (/java/model/java-create-model.templar){\n}{\n}

{if !table.isConstant}
	import com.synapticloop.h2zero.base.manager.{options.database}.ConnectionManager;{\n}
	import com.synapticloop.h2zero.base.validator.bean.ValidationBean;{\n}

	{if table.hasForeignKey}
		import com.synapticloop.h2zero.base.validator.bean.ValidationFieldBean;{\n}

		{loop table.foreignKeys as foreignKey}
			import {database.package}.question.{foreignKey.foreignKeyTableLookup.javaClassName}Question;{\n}
		{endloop}

	{endif}

	import com.synapticloop.h2zero.base.validator.*;{\n}
	import com.synapticloop.h2zero.base.model.{options.database}.ModelBase;{\n}
	import com.synapticloop.h2zero.base.exception.H2ZeroPrimaryKeyException;{\n}
	import com.synapticloop.h2zero.base.exception.H2ZeroFinderException;{\n}
	import java.lang.StringBuilder;{\n}
	import java.sql.Connection;{\n}
	{if fn:requiresImport[table, "Date"]}import java.sql.Date;{\n}{endif}
	import java.math.BigDecimal;{\n}
	{if fn:requiresImport[table, "Clob"]}import java.sql.Clob;{\n}{endif}
	{if fn:requiresImport[table, "Blob"]}import java.sql.Blob;{\n}{endif}
	{if fn:requiresImport[table, "Timestamp"]}import java.sql.Timestamp;{\n}{endif}
	{if fn:requiresImport[table, "Time"]}import java.sql.Time;{\n}{endif}
	import java.sql.ResultSet;{\n}
	import java.sql.Statement;{\n}
	import java.sql.PreparedStatement;{\n}
	import java.sql.SQLException;{\n}
{else}
	import java.util.HashMap;{\n}{\n}
	import java.util.Map;{\n}{\n}

{endif}

{\n}
import org.json.JSONObject;{\n}
import com.synapticloop.h2zero.util.XmlHelper;{\n}
{\n}

import com.synapticloop.h2zero.base.model.ModelBaseHelper;{\n}
import {database.package}.model.util.Constants;{\n}

{if !table.isConstant}
	{\n}

	import {database.package}.finder.{table.javaClassName}Finder;{\n}

	{--
	  if this isn't a lookup on a foreign key and if the foreign key is not a constant
	  table, then we need to import the finder
	}
	{loop table.fields as field}
		{if fn:and[fn:notNull[field.foreignKeyTable], !field.foreignKeyTableLookup.isConstant]}
			import {database.package}.finder.{field.foreignKeyTableLookup.javaClassName}Finder;{\n}
		{endif}
	{endloop}

{endif}

{\n}{\n}
/**{\n}
 * <p>This is the model for the <code>{table.javaClassName}</code> which maps to the <code>{table.name}</code> database table.</p>{\n}
 * {\n}
 * <p>This model maps all of the fields from the database as defined in the{\n}
 * <code>.h2zero</code> file.  The parsed definition of the table and fields are:</p>{\n}
 * {\n}
 {if table.isConstant}
 * <p><strong>NOTE:</strong> This is a constant table which cannot be changed and no CRUD methods are available.</p>{\n}
 {else}
 * <p>This class contains all the base CRUD (Create, Read, Update, and Delete){\n}
 * methods for a model.</p>{\n}
 {endif}
 * {\n}
 * <table>{\n}
 *   <thead>{\n}
 *     <tr>{\n}
 *       <th>Field name</th>{\n}
 *       <th>SQL type</th>{\n}
 *       <th>Field length<br />(min:max)</th>{\n}
 *       <th>Nullable?</th>{\n}
 *       <th>Keys</th>{\n}
 *       <th>Comments</th>{\n}
 *     </tr>{\n}
 *   </thead>{\n}
 *   <tbody>{\n}

{loop table.fields as field}
 *     <tr>{\n}
 *       <td><code>{field.name}</code></td>{\n}
 *       <td>{field.type}</td>{\n}
 *       <td>{if !fn:=[field.maxLength, "0"]}({field.minLength}:{field.maxLength}){else} -- {endif}</td>{\n}
 *       <td>{field.nullable}</td>{\n}
 *       <td>{if field.primary}<code>primary</code>{endif}
{if field.unique} <primary>unique</primary>{endif}
{if fn:notNull[field.foreignKeyTable]} <code>foreign -> {field.foreignKeyTable}.{field.foreignKeyField}</code>{endif}</td>{\n}
 *       <td>{if fn:null[field.comment]} -- {else}{field.comment}{endif}</td>{\n}
 *     </tr>{\n}
{endloop}

 *   </tbody>{\n}
 * </table>{\n}
 * {\n}

	{if table.isConstant}
 * <p><strong>NOTE:</strong>This table is a <code>CONSTANT</code> table with the following values:</p>{\n}
		{\n}{\n}

 * <table>{\n}
 *   <thead>{\n}
 *     <tr>{\n}
 *       <th>Constant<br />accessor</th>{\n}

{loop table.fields as field}
 *       <th>{field.name}</th>
{endloop}
 *     </tr>{\n}
 *   </thead>{\n}
 *   <tbody>{\n}

{loop table.constants as constant}
 *     <tr>{\n}
 *       <td><code>{table.javaClassName}.{constant.name}</code></td>{\n}
{loop constant.sqlValues as sqlValue}
 *       <td><code>{sqlValue}</code></td>{\n}
{endloop}
 *     <tr>{\n}
{endloop}

 *   </tbody>{\n}
 * </table>{\n}
 * {\n}
	{endif}
 * @author synapticloop h2zero{\n}
 * {\n}
 * <p>@see <a href="https://github.com/synapticloop/h2zero">Synapticloop h2zero GitHub repository</a></p>{\n}
 */{\n}

public class {table.javaClassName} {if !table.isConstant}extends ModelBase{endif} {{{\n}
{\t}// the binder is unused in code, but will generate compile problems if this {\n}
{\t}// class is no longer referenced in the h2zero file. Just a nicety for{\n}
{\t}// removing dead code{\n}
{\t}@SuppressWarnings("unused"){\n}
{\t}private static final String BINDER = Constants.{table.upperName}_BINDER;{\n}{\n}

{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				CONSTANTS GENERATOR
}
{if table.isConstant}
	{loop table.constants as constant}
		{\t}public static final {table.javaClassName} {constant.name} = new {table.javaClassName}(
			{loop constant.values as value}
				{value}{if !valueStatus.last}, {endif}
			{endloop}
		);{\n}
	{endloop}


	{loop table.constants as constant}
 		{\t}public static final {constant.primaryKeyJavaType} {constant.name}_PRIMARY_KEY_VALUE = {constant.primaryKeyValue};{\n}
	{endloop}
	{\n}

	{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		Now add in the static array
	}

	{\t}public static final {table.javaClassName}[] ALL =  {{{\n}
		{\t}{\t}{loop table.constants as constant}
				{table.javaClassName}.{constant.name}{if !constantStatus.last}, {endif}
			{endloop}{\n}
	{\t}};{\n}
	{\n}

	{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		And the static HashMap lookup
	}

	{\t}public static final Map<Long, {table.javaClassName}> ALL_LOOKUP = new HashMap<>();{\n}
	{\t}static{{{\n}
		{loop table.constants as constant}
			{\t}{\t}ALL_LOOKUP.put({constant.primaryKeyValue}, {table.javaClassName}.{constant.name});{\n}
		{endloop}{\n}
	{\t}};{\n}
	{\n}

{-- NOW FOR THE CACHE_CONSTANTS--}

	{loop table.constantCaches as cacheConstant}
	{\t}public static final Map<{cacheConstant.cacheField.javaType}, {table.javaClassName}> {cacheConstant.cacheName} = new HashMap<>();{\n}
	{endloop}

	{loop table.constantCaches as cacheConstant}
		{if cacheConstantStatus.first}
	{\t}static {{{\n}
		{endif}
		{loop table.constants as constant}
			{\t}{\t}{cacheConstant.cacheName}.put({table.javaClassName}.{constant.name}.get{cacheConstant.cacheField.javaAccessorName}(), {table.javaClassName}.{constant.name});{\n}
		{endloop}{\n}
		{if cacheConstantStatus.last}
	{\t}};{\n}
		{endif}
	{endloop}
{endif}
{\n}

	{loop table.fields as field}
		{if field.primary}
			{\t}public static final String PRIMARY_KEY_FIELD = "{field.name}";  // the primary key - a convenience field{\n}{\n}
		{endif}
	{endloop}

{if !table.isConstant}
	{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					SQL insert
	}

	{\t}private static final String SQL_INSERT = {\n}
	{\t}{\t}"""{\n}{\t}{\t}{\t}insert into{\n}
	{\t}{\t}{\t}{table.name} ({\n}

		{loop table.nonPrimaryFields as field}
			{\t}{\t}{\t}{\t}{field.name}
			{if !fieldStatus.last},{endif}{\n}
		{endloop}
		{\t}{\t}{\t}) values ({\n}

	{-- now loop through all of the fields }
	{loop table.nonPrimaryFields as field}
		{\t}{\t}{\t}{\t}?
		{if !fieldStatus.last},{endif}{\n}

	{endloop}{\t}{\t}{\t}){\n}
	{\t}{\t}""";{\n}

	{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					SQL update
	}

	{\t}private static final String SQL_UPDATE = {\n}
	{\t}{\t}"""{\n}
	{\t}{\t}{\t}update{\n}
	{\t}{\t}{\t}{\t}{table.name}{\n}
	{\t}{\t}{\t}set{\n}

	{-- now loop through all of the fields }
	{loop table.fields as field}
		{if field.primary}{else}
			{\t}{\t}{\t}{\t}{field.name} = ?
			{if fieldStatus.last}{else},{endif}{\n}
		{endif}

	{endloop}{\t}{\t}{\t}where{\n}
	{\t}{\t}"""{\n}
	{\t}{\t}{\t}+ PRIMARY_KEY_FIELD + {\n}
	{\t}{\t}"""{\n}
	{\t}{\t}{\t}= ?{\n}
	{\t}{\t}""";{\n}

	{\t}private static final String SQL_DELETE = "delete from {table.name} where " + PRIMARY_KEY_FIELD + " = ?";{\n}

	{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					INSERT IF NOT EXISTS SQL - ENSURE
	}
	{\t}private static final String SQL_ENSURE = "select " + PRIMARY_KEY_FIELD + " from {table.name} where 
	{loop table.fields as field}
		{if !field.primary}
			{field.name} = ?
			{if !fieldStatus.last} and {endif}
		{endif}
	{endloop}";{\n}
{\n}

{if table.shouldHydrate}
	{\t}private static final String SQL_SELECT_HYDRATE = "select 
	{loop table.nonPopulateFields as field}
		{field.name}
		{if !fieldStatus.last}, {endif}
	{endloop}
	 from {table.name} where " + PRIMARY_KEY_FIELD + " = ?";{\n}
{endif}{-- end of check whether we should hydrate some of the fields }

	{\n}
	{\t}// Static lookups for fields in the hit counter.{\n}
	{\t}// Whilst these aren't used internally (the offset to the array is {\n}
	{\t}// automatically computed, external classes can use these static {\n}
	{\t}// fields to look up the hit counts in the array {\n}
	{\t}public static final int HIT_TOTAL = 0;  // The total number of hits on all fields of this model{\n}
	{loop table.fields as field}
		{\t}public static final int HIT_{field.upperName} = {fieldStatus.index}; // The number of hits on the {field.name} property{\n}
	{endloop}{\n}
	{\n}
	{\t}// the list of fields for the hit - starting with 'TOTAL'{\n}
	{\t}private static final String[] HIT_FIELDS = {{ "TOTAL", {loop table.fields as field}"{field.name}"{if fieldStatus.last}{else}, {endif}{endloop} };{\n}
	{\t}// the number of read-hits for a particular field{\n}
	{\t}private static final int[] HIT_COUNTS = {{ 0, {loop table.fields as field}0{if fieldStatus.last}{else}, {endif}{endloop} };{\n}
	{set fn:length[table.nonPopulateFields] as nonPopulateFieldsLength}

	{if table.shouldHydrate}
		{\t}private boolean isHydrated = {if fn:=[nonPopulateFieldsLength, '0']}true{else}false{endif}; // whether this model is populated{\n}
	{endif}{-- end of check whether we should hydrate some of the fields }

{endif}{-- end of !if.isConstant}
{\n}
	{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					LIST ALL OF THE JAVA FIELDS
	}

	{loop table.fields as field}
		{if fn:notNull[field.foreignKeyTable]}
			{if !field.foreignKeyTableLookup.isConstant}
				{\t}private {field.foreignKeyTableLookup.javaClassName} {field.secondaryJavaName} = null; // maps to the {field.name} field{\n}
			{endif}
		{endif}
		{if fieldStatus.last}
			{\n}
		{endif}
	{endloop}

	{loop table.fields as field}
		{\t}private {field.javaType} {field.javaName} = null; // maps to the {field.name} field{\n}
	{endloop}
	{\n}


	{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					CONSTRUCTORS
				what about null-able fields?
	}

	{\t}/**{\n}
	{\t} * <p>Create a new <code>{table.javaClassName}</code> object with all fields{\n}
	{\t} * some of which can be null.</p>{\n}
	{\t} * {\n}
	{\t} * <p><strong>NOTE:</strong> this does not insert the object into the database{\n}
	{\t} * the <code>.insert()</code> method must be called to insert this object</p>{\n}
	{\t} * {\n}
	{\t} * <p>Creating a new {table.javaClassName}:</p>{\n}
	{\t} * {\n}
	{\t} * <pre>new {table.javaClassName}({\n}
		{loop table.fields as field}
	{\t} *     {field.javaType} {field.javaName}
			{if fieldStatus.last}{else}, {endif} // {field.name} {if field.nullable} [NULLABLE]{endif}{\n}
		{endloop}
	{\t} * );</pre>{\n}
	{\t} * {\n}
	{\t} */{\n}
	{\t}public {table.javaClassName}(
		{loop table.fields as field}
			{field.javaType} {field.javaName}
			{if fieldStatus.last}{else}, {endif}
		{endloop}
	) {{{\n}
		{loop table.fields as field}
			{\t}{\t}this.{field.javaName} = {field.javaName};{\n}
		{endloop}

	{\t}}{\n}
	{\n}

	{if table.hasNonNullConstructor}
	{\t}/**{\n}
	{\t} * <p>Create a new <code>{table.javaClassName}</code> object with only the{\n}
	{\t} * fields that are non-nullable.</p>{\n}
	{\t} * {\n}
	{\t} * <p><strong>NOTE:</strong> this does not insert the object into the database{\n}
	{\t} * the <code>.insert()</code> method must be called to insert this object</p>{\n}
	{\t} * {\n}
	{\t} * <p>Creating a new {table.javaClassName}:</p>{\n}
	{\t} * {\n}
	{\t} * <pre>new {table.javaClassName}({\n}
		{loop table.nonNullFields as field}
	{\t} *     {field.javaType} {field.javaName}
			{if fieldStatus.last}{else}, {endif} // {field.name}{\n}
		{endloop}
	{\t} * );</pre>{\n}
	{\t} * {\n}
	{\t} */{\n}

		{\t}public {table.javaClassName}(
			{loop table.nonNullFields as field}
				{field.javaType} {field.javaName}
				{if fieldStatus.last}{else}, {endif}
			{endloop}
		) {{{\n}
			{loop table.fields as field}
				{if field.nullable}
					{\t}{\t}this.{field.javaName} = null;{\n}
				{else}
					{\t}{\t}this.{field.javaName} = {field.javaName};{\n}
				{endif}
			{endloop}

		{\t}}{\n}
	{endif}
{\n}
{if !table.isConstant}
{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				getOrSet
			This will either get a new strata plan, or else it will update the strata
			plan
}

	{\t}/**{\n}
	{\t} * <p>Get a new {table.javaClassName} model, or set the fields on an existing{\n}
	{\t} * {table.javaClassName} model.</p>{\n}
	{\t} * {\n}
	{\t} * <p>If the passed in {table.javaFieldName} is null, then a new {table.javaClassName}{\n}
	{\t} * will be created.  If not null, the fields will be updated on the passed in model.</p>{\n}
	{\t} * {\n}
	{\t} * <p><strong>NOTE:</strong> You will still need to persist this to the database{\n}
	{\t} * with an <code>upsert()</code> call - this will insert the model if it .{\n}
	{\t} * doesn't exist, or update the existing model.</p>{\n}
	{\t} * {\n}
	{\t} * @param {table.javaFieldName} the model to check{\n}
		{loop table.nonPrimaryFields as field}
	{\t} * @param {field.javaName} - maps to the <code>{field.name}</code> field.{\n}
		{endloop}
	{\t} * {\n}
	{\t} * @return Either the existing {table.javaFieldName} with updated field values,{\n}
	{\t} *   or a new {table.javaClassName} with the field values set.{\n}
	{\t} */{\n}


	{\t}public static {table.javaClassName} getOrSet({table.javaClassName} {table.javaFieldName},
		{loop table.nonPrimaryFields as field}
			{field.javaType} {field.javaName}
			{if fieldStatus.last}{else}, {endif}
		{endloop}
	) {{{\n}

		{\t}{\t}if(null == {table.javaFieldName}) {{{\n}
{\t}{\t}{\t}return (new {table.javaClassName}(null, {loop table.nonPrimaryFields as field}{field.javaName}{if !fieldStatus.last}, {endif}
		{endloop}));{\n}
	{\t}{\t}} else {{{\n}
		{loop table.nonPrimaryFields as field}
	{\t}{\t}{\t}{table.javaFieldName}.set{field.javaAccessorName}({field.javaName});{\n}
		{endloop}{\n}
	{\t}{\t}{\t}return({table.javaFieldName});{\n}
	{\t}{\t}}{\n}

	{\t}}{\n}

	{if table.hasNonNullConstructor}

	{\n}
	{\t}/**{\n}
	{\t} * Get a new {table.javaClassName} model, or set the fields on an existing{\n}
	{\t} * {table.javaClassName} model.{\n}
	{\t} * <p>{\n}
	{\t} * If the passed in {table.javaFieldName} is null, then a new {table.javaClassName}{\n}
	{\t} * will be created.  If not null, the fields will be updated on the existing model.{\n}
	{\t} * <p>{\n}
	{\t} * <strong>NOTE:</strong> You will still need to persist this to the database{\n}
	{\t} * with an <code>upsert()</code> call.{\n}
	{\t} * {\n}
	{\t} * @param {table.javaFieldName} the model to check{\n}
		{loop table.nonPrimaryNullFields as field}
	{\t} * @param {field.javaName}{\n}
		{endloop}
	{\t} * {\n}
	{\t} * @return Either the existing {table.javaFieldName} with updated field values,{\n}
	{\t} *   or a new {table.javaClassName} with the field values set.{\n}
	{\t} */{\n}


		{\t}public static {table.javaClassName} getOrSet({table.javaClassName} {table.javaFieldName}
			{loop table.nonPrimaryNullFields as field}
				, {field.javaType} {field.javaName}
			{endloop}
		) {{{\n}
		{\t}{\t}if(null == {table.javaFieldName}) {{{\n}
{\t}{\t}{\t}return (new {table.javaClassName}(null {loop table.nonPrimaryNullFields as field}, {field.javaName}
		{endloop}));{\n}
	{\t}{\t}} else {{{\n}
		{loop table.nonPrimaryNullFields as field}
	{\t}{\t}{\t}{table.javaFieldName}.set{field.javaAccessorName}({field.javaName});{\n}
		{endloop}{\n}
	{\t}{\t}{\t}return({table.javaFieldName});{\n}
	{\t}{\t}}{\n}

	{\t}}{\n}

	{endif}
{endif}

{if !table.isConstant}
	{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					PRIMARY KEY TEST AND SETTER/GETTER
	}

	{loop table.fields as field}
		{if field.primary}
			{\n}
			{\t}@Override{\n}
			{\t}public boolean primaryKeySet() {{{\n}
			{\t}{\t}return(null != {field.javaName});{\n}
			{\t}}{\n}
			{\n}
		{endif}
	{endloop}{\n}

	{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				C(R)UD METHODS - WITHOUT THE READ
	}

	{\t}@Override{\n}
	{\t}public void insert(Connection connection) throws SQLException, H2ZeroPrimaryKeyException {{{\n}

	{\t}{\t}if(primaryKeySet()) {{{\n}
	{\t}{\t}{\t}throw new H2ZeroPrimaryKeyException("Cannot insert {table.name} model when primary key is not null.");{\n}
	{\t}{\t}}{\n}
	{\n}
	{\t}{\t}PreparedStatement preparedStatement = null;{\n}
	{\t}{\t}ResultSet resultSet = null;{\n}

	{\t}{\t}try {{{\n}
	{\t}{\t}{\t}// create this bean {\n}
	{\t}{\t}{\t}preparedStatement = connection.prepareStatement(SQL_INSERT, Statement.RETURN_GENERATED_KEYS);{\n}

	{loop table.nonPrimaryFields as field}
		{\t}{\t}{\t}ConnectionManager.set{field.upperType}(preparedStatement, {fieldStatus.index}, {field.javaName});{\n}
	{endloop}

	{\t}{\t}{\t}preparedStatement.executeUpdate();{\n}

	{\t}{\t}{\t}resultSet = preparedStatement.getGeneratedKeys();{\n}
	{\t}{\t}{\t}if(resultSet.next()) {{{\n}

	{loop table.fields as field}
		{if field.primary}
			{\t}{\t}{\t}{\t}this.{field.javaName} = resultSet.getLong(1);{\n}
		{endif}
	{endloop}

	{\t}{\t}{\t}} else {{{\n}
	{\t}{\t}{\t}{\t}throw new H2ZeroPrimaryKeyException("Could not get return value for primary key!");{\n}
	{\t}{\t}{\t}}{\n}

	{\t}{\t}} finally {{{\n}
	{\t}{\t}{\t}ConnectionManager.closeAll(resultSet, preparedStatement);{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}
	{\n}

	{--
	    ENSURE
	}
	{\t}@Override{\n}
	{\t}public void ensure(Connection connection) throws SQLException, H2ZeroPrimaryKeyException {{{\n}
	{\n}
	{\t}{\t}PreparedStatement preparedStatement = null;{\n}
	{\t}{\t}ResultSet resultSet = null;{\n}

	{\t}{\t}try {{{\n}

	{\t}{\t}{\t}preparedStatement = connection.prepareStatement(SQL_ENSURE);{\n}

	{loop table.nonPrimaryFields as field}
		{\t}{\t}{\t}ConnectionManager.set{field.upperType}(preparedStatement, {fieldStatus.index}, {field.javaName});{\n}
	{endloop}

	{\t}{\t}{\t}resultSet = preparedStatement.executeQuery();{\n}

	{\t}{\t}{\t}if(resultSet.next()) {{{\n}

	{loop table.fields as field}
		{if field.primary}
			{\t}{\t}{\t}{\t}this.{field.javaName} = resultSet.getLong(1);{\n}
		{endif}
	{endloop}

	{\t}{\t}{\t}} else {{{\n}
	{\t}{\t}{\t}{\t}// could not find the value - need to insert it - null is the primary key{\n}
	{\t}{\t}{\t}{\t}insert(connection);{\n}
	{\t}{\t}{\t}}{\n}

	{\t}{\t}} finally {{{\n}


	{\t}{\t}{\t}ConnectionManager.closeAll(resultSet, preparedStatement);{\n}

	{\t}{\t}}{\n}
	{\t}}{\n}
	{\n}

	{\t}@Override{\n}
	{\t}public void update(Connection connection) throws SQLException, H2ZeroPrimaryKeyException {{{\n}

	{\t}{\t}if(!primaryKeySet()) {{{\n}
	{\t}{\t}{\t}throw new H2ZeroPrimaryKeyException("Cannot update bean when primary key is null.");{\n}
	{\t}{\t}}{\n}

	{\n}

	{\t}{\t}if(isDirty) {{{\n}
	{\t}{\t}{\t}try (PreparedStatement preparedStatement = connection.prepareStatement(SQL_UPDATE)) {{{\n}
	{\t}{\t}{\t}{\t}// update this bean, but only if dirty{\n}

	{set fn:length[table.fields] as preparedStatementSize}

	{loop table.fields as field}
		{if !field.primary}
			{\t}{\t}{\t}{\t}ConnectionManager.set{field.upperType}(preparedStatement, {fieldStatus.offset}, {field.javaName});{\n}
		{endif}
	{endloop}

	{\t}{\t}{\t}{\t}// now set the primary key{\n}
	{loop table.fields as field}
		{if field.primary}
			{\t}{\t}{\t}{\t}preparedStatement.setLong({preparedStatementSize}, {field.javaName});{\n}
		{endif}
	{endloop}

	{\t}{\t}{\t}{\t}preparedStatement.executeUpdate();{\n}
	{\t}{\t}{\t}} finally {{{\n}
	{\t}{\t}{\t}{\t}isDirty = false;{\n}
	{\t}{\t}{\t}}{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}
	{\n}


	{\t}@Override{\n}
	{\t}public void delete(Connection connection) throws SQLException, H2ZeroPrimaryKeyException {{{\n}

	{\t}{\t}if(!primaryKeySet()) {{{\n}
	{\t}{\t}{\t}throw new H2ZeroPrimaryKeyException("Cannot delete bean when primary key is null.");{\n}
	{\t}{\t}}{\n}
	{\t}{\t}try (PreparedStatement preparedStatement = connection.prepareStatement(SQL_DELETE)) {{{\n}
	{loop table.fields as field}
		{if field.primary}
			{\t}{\t}{\t}preparedStatement.setLong(1, {field.javaName});{\n}
		{endif}
	{endloop}
	{\t}{\t}{\t}preparedStatement.executeUpdate();{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}
	{\n}


	{\t}@Override{\n}
	{\t}public void refresh(Connection connection) throws SQLException, H2ZeroPrimaryKeyException, H2ZeroFinderException {{{\n}

	{\t}{\t}if(!primaryKeySet()) {{{\n}
	{\t}{\t}{\t}throw new H2ZeroPrimaryKeyException("Cannot refresh model '{table.javaClassName}' when primary key is null.");{\n}
	{\t}{\t}}{\n}

	{\n}

	{loop table.fields as field}
		{if field.primary}
			{\t}{\t}{table.javaClassName} {table.javaFieldName} = {table.javaClassName}Finder.findByPrimaryKey(this.{field.javaName}){\n}
			{\t}{\t}{\t}{\t}.withConnection(connection){\n}
			{\t}{\t}{\t}{\t}.executeSilent();{\n}
			{\n}
			{\t}{\t}if(null == {table.javaFieldName}) {{{\n}
			{\t}{\t}{\t}throw new H2ZeroFinderException("Could not find the model '{table.javaClassName}' with primaryKey of " + getPrimaryKey());{\n}
			{\t}{\t}}{\n}
		{endif}
	{endloop}


		{loop table.fields as field}
			{\t}{\t}this.{field.javaName} = {table.javaFieldName}.get{field.javaAccessorName}();{\n}
		{endloop}

		{--
			Now we need to go through all of the constant fields and set them to null
		}

	{loop table.fields as field}
		{if fn:notNull[field.foreignKeyTable]}
			{if !field.foreignKeyTableLookup.isConstant}
				{\t}{\t}this.{field.secondaryJavaName} = null;{\n}
			{endif}
		{endif}
	{endloop}

	{\t}}{\n}
	{\n}

	{set fn:length[table.nonPopulateFields] as nonPopulateFieldsLength}
	{if !fn:=[nonPopulateFieldsLength, '0']}

		{loop table.fields as field}
			{if field.primary}
				{set field.name as primaryFieldName}
				{set field.javaName as primaryFieldJavaName}
			{endif}
		{endloop}

		{\t}@Override{\n}
		{\t}protected void hydrate(Connection connection) throws SQLException, H2ZeroPrimaryKeyException {{{\n}

		{\t}{\t}if(!primaryKeySet()) {{{\n}
		{\t}{\t}{\t}throw new H2ZeroPrimaryKeyException("Cannot hydrate bean when primary key is null.");{\n}
		{\t}{\t}}{\n}
		{\t}{\t}PreparedStatement preparedStatement = null;{\n}
		{\t}{\t}ResultSet resultSet = null;{\n}

		{\t}{\t}try {{{\n}
		{\t}{\t}{\t}preparedStatement = connection.prepareStatement(SQL_SELECT_HYDRATE);{\n}
		{\t}{\t}{\t}preparedStatement.setLong(1, {primaryFieldJavaName});{\n}
		{\t}{\t}{\t}resultSet = preparedStatement.executeQuery();{\n}

		{\t}{\t}{\t}if(!resultSet.next()) {{{\n}
		{\t}{\t}{\t}{\t}throw new H2ZeroPrimaryKeyException("Could not find result with primary key of: " + getPrimaryKey());{\n}
		{\t}{\t}{\t}}{\n}

		{loop table.nonPopulateFields as field}
			{\t}{\t}{\t}this.{field.javaName} = ConnectionManager.getNullableResult{field.sqlJavaType}(resultSet, {fieldStatus.index});{\n}
		{endloop}

		{\t}{\t}} catch (SQLException sqlex) {{{\n}
		{\t}{\t}{\t}throw sqlex;{\n}
		{\t}{\t}} finally {{{\n}
		{\t}{\t}this.isHydrated = true;{\n}
		{\t}{\t}{\t}ConnectionManager.closeAll(resultSet, preparedStatement);{\n}
		{\t}{\t}}{\n}
		{\t}}{\n}
		{\n}
	{endif}

	{\t}/**{\n}
	{\t} * <p>Return the names of the hit fields as an array.  The first entry of the array{\n}
	{\t} * is the static name <code>TOTAL</code></p>{\n}
	{\t} *{\n}
	{\t} * @return The array of the hit fields name{\n}
	{\t} */{\n}
	{\t}public static String[] getHitFields() {{ return(HIT_FIELDS); }{\n}
	{\n}
	{\t}/**{\n}
	{\t} * <p>Return the hit counts as an array, the first element being the total number of {\n}
	{\t} * hits for all fields</p>{\n}
	{\t} * {\n}
	{\t} * @return The field hit counts as an array, the first entry in the array is the {\n}
	{\t} *         total number of hits for all fields{\n}
	{\t} */	{\t}public static int[] getHitCounts() {{ return(HIT_COUNTS); }{\n}{\n}

{\t}/**{\n}
{\t} * Get the hit count for a specific field - look at the <code>public static HIT_*</code>{\n}
{\t} * fields to retrieve a specific field.{\n}
{\t} *{\n}
{\t} * @param hitCountField the hit count field number to retrieve the hit count from{\n}
{\t} *{\n}
{\t} * @return the hit count for the field{\n}
{\t} * {\n}
	{loop table.fields as field}
		{\t} * <p>{{@link #HIT_{field.upperName} Use <code>{table.javaClassName}.HIT_{field.upperName}</code> to retrieve the hit count for the <code>{field.name}</code> field}</p>{\n}
	{endloop}
{\t} */{\n}

{\t}public static int getHitCountForField(int hitCountField) {{ return(HIT_COUNTS[hitCountField]); }{\n}{\n}

{endif}{-- end of !isconstant table }

	{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					SETTERS AND GETTERS

					The first getter is for any referenced foreign key tables that exist
					which will get the actual object, rather than the primary key that 
					references it.
	}

	{loop table.fields as field}
		{if fn:notNull[field.foreignKeyTable]}
			{\t}/**{\n}
			{\t} * <p>The <code>{field.name}</code> is a foreign key, consequently this is a convenience{\n}
			{\t} * method to get the {field.foreignKeyTableLookup.javaClassName} Model object, rather than returning the{\n}
			{\t} * primary key field.</p>{\n}
			{\t} * {\n}
			{\t} * <p>To find the referenced primary key field - use the <code>get{field.javaAccessorName}()</code>{\n}
			{\t} * method.</p>{\n}
			{\t} * {\n}
{if !field.foreignKeyTableLookup.isConstant}
			{\t} * <p>In effect, this will look up the model from the <code>{field.foreignKeyTable}</code> database - with{\n}
			{\t} * the appropriate SQL statement <code>.findByPrimaryKey({field.javaName})</code></p>{\n}
			{\t} * {\n}
{else}
			{\t} * <p>This reference is a to a <code>CONSTANT</code> table, so the <code>ALL_LOOKUP</code>{\n}
			{\t} * reference is used, rather than a call to the database.</p>{\n}
{endif}
			{\t} * {\n}
			{\t} * @return The model for the foreign key reference. {\n}
			{\t} */{\n}
			{\t}public {field.foreignKeyTableLookup.javaClassName} get{field.secondaryJavaName}() {{{\n}
			{if !field.foreignKeyTableLookup.isConstant}
				{\t}{\t}if(null == this.{field.secondaryJavaName}) {{{\n}

				{\t}{\t}{\t}this.{field.secondaryJavaName} = {field.foreignKeyTableLookup.javaClassName}Finder.findByPrimaryKey(this.{field.javaName}).executeSilent();{\n}

				{\t}{\t}}{\n}

				{\t}{\t}return(this.{field.secondaryJavaName});{\n}
			{else}

				{--
					At this point the foreign table is constant so it was already looked up
					at construction time
				}

				{\t}{\t}return({field.foreignKeyTableLookup.javaClassName}.ALL_LOOKUP.get(this.{field.javaName}));{\n}
			{endif}

			{\t}}{\n}{\n}
		{endif}
	{endloop}

	{if !table.isConstant}
		{\t}/**{\n}
		{\t} * <p>Update the field hit count.  Use the static variables <code>HIT_&lt;FIELD_NAME&gt;</code>{\n}
		{\t} * variables for the offset.</p>{\n}
		{\t} * {\n}
		{\t} * @param offset The offset of the <code>HIT_COUNTS</code> array to update{\n}
		{\t} */{\n}
		{\t}private static void updateHitCount(int offset) {{{\n}
		{\t}{\t}HIT_COUNTS[0]++;{\n}
		{\t}{\t}HIT_COUNTS[offset]++;{\n}
		{\t}}{\n}{\n}
	{endif}

	{\t}/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *{\n}
	{\t} * Boring ol' getters and setters {\n}
	{\t} * {\n}
	{\t} * Getters will update the hit count upon access.{\n}
	{\t} * {\n}
	{\t} * Setters, if the passed in parameter's value differs will set the{\n}
	{\t} * 'isDirty' flag{\n}
	{\t} * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */{\n}
	{\n}

	{loop table.fields as field}
		{if field.primary}
		{\t}/**{\n}
		{\t} * <p>Convenience method for returning the primary key field (which is the {field.name} field).</p>{\n}
		{\t} * {\n}
		{\t} * <p><strong>NOTE:</strong> This will update the hit count.</p>{\n}
		{\t} * {\n}
		{\t} * @return The value of the primary key{\n}
		{\t} */{\n}
		{\t}public {field.javaType} getPrimaryKey() {{

			{if !table.isConstant}
				updateHitCount({fn:+[field.fieldIndex, '1']}); 
			{endif}

			return(this.{field.javaName}); 
		}{\n}
		{\n}
		{endif}
	{endloop}

	{loop table.fields as field}
		{if field.primary}
			{if !table.isConstant}
				{\t}/**{\n}
				{\t} * <p>Set the primary key field (which is the {field.name} field).</p>{\n}
				{\t} * {\n}
				{\t} * <p>If the primary key value has the same value as the passed in parameter, then {\n}
				{\t} * nothing will be done.</p>{\n}
				{\t} * {\n}
				{\t} * <p>If the primary key value differs in value to the passed in parameter, then {\n}
				{\t} * the field will be set and this model will be marked as 'dirty'.</p>{\n}
				{\t} * {\n}
				{\t} * @param idUser The primary key field to update{\n}
				{\t} */{\n}
				{\t}public void setPrimaryKey({field.javaType} {field.javaName}) {{
					if(isDifferent(this.{field.javaName}, {field.javaName})) {{ 
						this.{field.javaName} = {field.javaName}; this.isDirty = true;

						{if fn:notNull[field.foreignKeyTable]}
							{if !field.foreignKeyTableLookup.isConstant}
								this.{field.secondaryJavaName} = null;
							{endif}
						{endif}

					}
				}{\n}
			{endif}
		{endif}
	{endloop}

	{loop table.fields as field}
		{\n}
		{\t}/**{\n}
		{\t} * <p>Return the value of the {field.name}, updating the hit count for this field.</p>{\n}
		{\t} * {\n}
		{\t} * @return the value of the {field.name} which may {if field.nullable}NOT {endif}be null.{\n}
		{\t} */{\n}
		{\t}public {field.javaType} get{field.javaAccessorName}() {{

			{if !table.isConstant}
				updateHitCount({fn:+[field.fieldIndex, '1']}); 
			{endif}

			{--
				We need to check for hydration
			}
			{if !field.populate}
			if(!isHydrated) {{ hydrateSilent(); this.isHydrated = true; } 
			{endif}

			return(this.{field.javaName}); 
		}{\n}

		{if !table.isConstant}
			{\n}
			{\t}/**{\n}
			{\t} * <p>Set the {field.name} value.</p>{\n}
			{\t} * {\n}
			{\t} * <p>If the field value has the same value as the passed in parameter, then {\n}
			{\t} * nothing will be done.</p>{\n}
			{\t} *{\n}
			{\t} * <p>If the field value differs in value to the passed in parameter, then {\n}
			{\t} * the field will be set and this model will be marked as 'dirty'.</p>{\n}
			{\t} *{\n}
			{\t} * @param idUser the {field.name} value to be set{\n}
			{\t} */{\n}
			{\t}public void set{field.javaAccessorName}({field.javaType} {field.javaName}) {{
				if(isDifferent(this.{field.javaName}, {field.javaName})) {{ 
					this.{field.javaName} = {field.javaName}; this.isDirty = true;

					{if fn:notNull[field.foreignKeyTable]}
						{if !field.foreignKeyTableLookup.isConstant}
							this.{field.secondaryJavaName} = null;
						{endif}
					{endif}

				}
			}{\n}
		{endif}

	{endloop}

{if !table.isConstant}
	{\n}
	{\t}@Override{\n}
	{\t}public ValidationBean validate() {{{\n}
	{\t}{\t}ValidationBean validationBean = new ValidationBean();{\n}{\n}
	{loop table.nonPrimaryFields as field}
		{if field.isForeignKey}
			{\t}{\t}ValidationFieldBean {field.javaName}ValidationFieldBean = new {field.upperType}Validator("{field.name}", {field.javaName}.toString(), {field.minLength}, {field.maxLength}, {field.nullable}).validate();{\n}
			{\t}{\t}{field.javaName}ValidationFieldBean.setIsIncorrectForeignKey(!{field.foreignKeyTableLookup.javaClassName}Question.internalDoesPrimaryKeyExist({field.javaName}));{\n}
			{\t}{\t}validationBean.addValidationFieldBean({field.javaName}ValidationFieldBean);{\n}{\n}
		{else}
			{\t}{\t}validationBean.addValidationFieldBean(new {field.upperType}Validator("{field.name}", {field.javaName}.toString(), {field.minLength}, {field.maxLength}, {field.nullable}).validate());{\n}
		{endif}
	{endloop}
	{\t}{\t}return(validationBean);{\n}
	{\t}}{\n}
	{\n}
{endif}

	{-- Now we need the toString Method--}
	{\n}
	{\t}@Override{\n}
		{\t}public String toString() {{{\n}
		{\t}{\t}return({\n}
		{\t}{\t}{\t}"{{\"{table.javaClassName}\": {{" +{\n}
		{loop table.fields as field}
			{if field.isSecure}
				{\t}{\t}{\t}"\"{field.javaName}\": \"<**secure**>\"" +{\n}
			{else}
				{\t}{\t}{\t}"\"{field.javaName}\":\"" + this.{field.javaName} + "\"" +{\n}
			{endif}
			{if fieldStatus.last}{\t}{\t}{\t}"}");{\n}{endif}
		{endloop}
		{\t}}{\n}


	{-- and the getJSONString - for chaining --}
	{\t}public JSONObject getToJSON() {{{\n}
	{\t}{\t}return(toJSON());{\n}
	{\t}}{\n}

	{-- Now we need the toJson Method--}
	{\n}
	{\t}public JSONObject toJSON() {{{\n}
	{\t}{\t}JSONObject jsonObject = new JSONObject();{\n}
	{\n}
	{\t}{\t}jsonObject.put("type", "table");{\n}
	{\t}{\t}jsonObject.put("name", "{table.javaClassName}");{\n}
	{\t}{\t}JSONObject fieldsObject = new JSONObject();{\n}
	{\n}
	{loop table.fields as field}
		{if !field.isSecure}
			{\t}{\t}ModelBaseHelper.addToJSONObject(fieldsObject, "{field.javaName}", this.get{field.javaAccessorName}());{\n}
		{endif}
	{endloop}
{\n}
	{\t}{\t}jsonObject.put("fields", fieldsObject);{\n}{\n}

	{\t}{\t}return(jsonObject);{\n}
	{\t}}{\n}
	{\n}


	{-- Now we need the toJsonString Method--}
	{\n}
	{\t}public String toJsonString() {{{\n}
	{\t}{\t}return(toJSON().toString());{\n}
	{\t}}{\n}
	{\n}

	{-- and the getJSONString - for chaining --}
	{\t}public String getJsonString() {{{\n}
	{\t}{\t}return(toJsonString());{\n}
	{\t}}{\n}

{\n}
	{\t}/**{\n}
	{\t} * <p>Return an XML representation of the <code>{table.javaClassName}</code> model as a <code>String</code>, {\n}
	{\t} * with the root node being the name of the table - i.e. <code>&lt;{table.name} /&gt;</code> {\n}
	{\t} * and the child nodes the name of the fields.</p>{\n}
	{\t} * {\n}
	{\t} * <p><strong>NOTE:</strong> Any field marked as secure will not be included as{\n}
	{\t} * part of the XML document</p>{\n}
	{\t} * {\n}
	{\t} * @return An XML representation of the model as a <code>String</code>.{\n}
	{\t} */{\n}

	{\t}public String toXMLString() {{{\n}
	{\t}{\t}return("<{table.name}>" + {\n}
	{loop table.fields as field}
		{if !field.isSecure}
			{if fn:=[field.javaType, "String"]}
				{\t}{\t}{\t}String.format("<{field.name} null=\"%b\">%s</{field.name}>", (this.get{field.javaAccessorName}() == null), (this.get{field.javaAccessorName}() != null ? XmlHelper.escapeXml(this.get{field.javaAccessorName}()) : "")) + {\n}
			{else}
				{\t}{\t}{\t}String.format("<{field.name} null=\"%b\">%s</{field.name}>", (this.get{field.javaAccessorName}() == null), (this.get{field.javaAccessorName}() != null ? this.get{field.javaAccessorName}() : "")) + {\n}
			{endif}
		{endif}
	{endloop}

	{\t}{\t}{\t}"</{table.name}>");{\n}
	{\t}}{\n}
	{\n}


{if !table.isConstant}
	{-- This is the hitcount --}
	{\n}
		{\t}/**{\n}
		{\t} * <p>Get the hit count statistics as a JSON encoded object as a <code>String</code></p>.{\n}
		{\t} *{\n}
		{\t} * @return the JSON Object as a <code>String</code>.{\n}
		{\t} */{\n}

		{\t}public static String getHitCountJson() {{{\n}

		{\t}{\t}JSONObject jsonObject = new JSONObject();{\n}
		{\t}{\t}jsonObject.put("type", "{table.javaClassName}");{\n}
		{\t}{\t}jsonObject.put("total", HIT_COUNTS[0]);{\n}
		{loop table.fields as field}
		{\t}{\t}jsonObject.put("{field.javaName}", HIT_COUNTS[{fn:+[field.fieldIndex, '1']}]);{\n}
		{endloop}
		{\t}{\t}return(jsonObject.toString());{\n}
		{\t}}{\n}
		{\n}
{endif}


}
