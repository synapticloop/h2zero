{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
		PACKAGE DECLARATION, IMPORT STATEMENTS AND CLASS DEFINITION
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

package {database.package}.question;{\n}{\n}
// - - - - thoughtfully generated by synapticloop h2zero - - - - {\n}
//    with the use of synapticloop templar templating language{\n}
//                (java-create-question.templar){\n}{\n}

{import classpath:/snippet/global/java-model-imports.templar}

{if table.hasQuestionInFields}
	import java.util.HashMap;{\n}
	import java.util.Map;{\n}
{endif}

import java.util.List;{\n}
{\n}
/**{\n}
 * <p>This class contains all of the questions that are defined in the h2zero{\n}
 * file</p>{\n}
 * <p>A question returns a simple true/false response from a query.</p>{\n}
 * {\n}
 * <p>Table name: <code>{table.name}</code></p>{\n}
 * {\n}
{loop table.questions as question}
	{if questionStatus.first}
 * <p>Questions defined:{\n}
 * <ul>{\n}
	{endif}
 * <li><code>{question.name}</code> - SQL query run {{@link #SQL_{question.staticName}}</li>{\n}
	{if questionStatus.last}
 * </ul>{\n}
	{endif}
{endloop}
 * {\n}
 * @author synapticloop h2zero{\n}
 * {\n}
 * <p>@see <a href="https://github.com/synapticloop/h2zero">Synapticloop h2zero GitHub repository</a></p>{\n}
 */{\n}
public class {table.javaClassName}Question {{{\n}
	{set table as baseSchemaObject}
	{import classpath:/snippet/global/java-binder-declaration.templar}
	{set "Question" as classType}{set baseSchemaObject.javaClassName as loggerClass}{import classpath:/snippet/global/java-logger-declaration.templar}{\n}{\n}

{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				THE INTERNAL QUESTION FOR WHETHER A PRIMARY KEY EXISTS
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

{\t}// this is an internal SQL question select statement used by the validator{\n}
{\t}private static final String SQL_INTERNAL_DOES_PRIMARY_KEY_EXIST = "SELECT (COUNT(*) = 1) WHERE {baseSchemaObject.primaryKey.name} = ?";{\n}{\n}

{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				THE QUESTION FINDERS FOR THE SELECT CLAUSES AND NORMAL CLAUSES
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

{loop table.questions as question}
	{\t}private static final String SQL_{question.staticName} = "{question.selectClause}"
	{if fn:notNull[question.whereClause]} + " {question.whereClause}"{endif}
	{if fn:notNull[question.orderBy]} + " order by {question.orderBy}"{endif};{\n}
{endloop}
{\n}

{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				THE Question FINDERS FOR THE SELECT CLAUSES CACHES
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

{loop table.questions as question}
	{if question.hasInFields}
		{\t}private static final Map<String, String> {question.name}_statement_cache = new HashMap<String, String>();{\n}
	{endif}
{endloop}
{\n}
{\t}/** Private to deter instantiation */{\n}
{\t}private {table.javaClassName}Question() {{}{\n}
{\n}
{\t}/**{\n}
{\t} * An internal method to check whether a specific primary key exists, {\n}
{\t} * generated as part of the validation methods{\n}
{\t} * {\n}
{\t} * @param {baseSchemaObject.primaryKey.javaName} The primary key for this model{\n}
{\t} * {\n}
{\t} * @return whether the primary key exists{\n}
{\t} */{\n}
{\t}public static boolean internalDoesPrimaryKeyExist({baseSchemaObject.primaryKey.javaType} {baseSchemaObject.primaryKey.javaName}) {{{\n}
{\t}{\t}Connection connection = null;{\n}
{\t}{\t}PreparedStatement preparedStatement = null;{\n}
{\t}{\t}ResultSet resultSet = null;{\n}
{\n}
{\t}{\t}boolean answer = false;{\n}
{\n}
{\t}{\t}try {{{\n}
{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
{\t}{\t}{\t}preparedStatement = connection.prepareStatement(SQL_INTERNAL_DOES_PRIMARY_KEY_EXIST);{\n}
{\t}{\t}{\t}ConnectionManager.set{baseSchemaObject.primaryKey.getUpperType}(preparedStatement, 1, {baseSchemaObject.primaryKey.javaName});{\n}
{\n}
{\t}{\t}{\t}resultSet = preparedStatement.executeQuery();{\n}
{\t}{\t}{\t}if(resultSet.next()) {{{\n}
{\t}{\t}{\t}{\t}answer = resultSet.getBoolean(1);{\n}
{\t}{\t}{\t}}{\n}
{\t}{\t}} catch (SQLException sqlex) {{{\n}
{\t}{\t}{\t}if(LOGGER.isWarnEnabled()) {{{\n}
{\t}{\t}{\t}{\t}LOGGER.warn("SQLException internalDoesPrimaryKeyExist(): " + sqlex.getMessage());{\n}
{\t}{\t}{\t}{\t}if(LOGGER.isDebugEnabled()) {{{\n}
{\t}{\t}{\t}{\t}{\t}sqlex.printStackTrace();{\n}
{\t}{\t}{\t}{\t}}{\n}
{\t}{\t}{\t}}{\n}
{\t}{\t}} finally {{{\n}
{\t}{\t}{\t}ConnectionManager.closeAll(resultSet, preparedStatement, connection);{\n}
{\t}{\t}}{\n}
{\t}{\t}return(answer);{\n}
{\t}}{\n}
{\n}


{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				AND THE SELECT CLAUSE QUESTIONS
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

{loop table.questions as question}
	{set question as baseQueryObject}

	{\t}public static boolean {question.name}(Connection connection
		{import classpath:/snippet/global/java-method-parameters-with-connection.templar}
	) throws SQLException {{{\n}

	{\t}{\t}PreparedStatement preparedStatement = null;{\n}
	{\t}{\t}ResultSet resultSet = null;{\n}
	{\t}{\t}boolean answer = false;{\n}


	{\t}{\t}try {{{\n}

	{import classpath:/snippet/global/java-sql-parameter-setting.templar}

	{\n}
	{\t}{\t}{\t}resultSet = preparedStatement.executeQuery();{\n}
	{\t}{\t}{\t}if(resultSet.next()) {{{\n}
	{\t}{\t}{\t}{\t}answer = resultSet.getBoolean(1);{\n}
	{\t}{\t}{\t}}{\n}
	{\t}{\t}} catch (SQLException sqlex) {{{\n}
	{\t}{\t}{\t}throw sqlex;{\n}
	{\t}{\t}} finally {{{\n}
	{\t}{\t}{\t}ConnectionManager.closeAll(resultSet, preparedStatement);{\n}
	{\t}{\t}}{\n}
	{\t}{\t}return(answer);{\n}
	{\t}}{\n}
{\n}

	{\t}public static boolean {question.name}(
		{import classpath:/snippet/global/java-method-parameters.templar}
	) throws SQLException {{{\n}

	{\t}{\t}Connection connection = null;{\n}
	{\n}

	{\t}{\t}try {{{\n}
	{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
	{\t}{\t}{\t}return({question.name}(connection
		{import classpath:/snippet/global/java-method-parameters-call-with-connection.templar}
		));{\n}
	{\t}{\t}} catch (SQLException sqlex) {{{\n}
	{\t}{\t}{\t}throw sqlex;{\n}
	{\t}{\t}} finally {{{\n}
	{\t}{\t}{\t}ConnectionManager.closeAll(connection);{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}
{\n}

	{\t}public static boolean {question.name}Silent(Connection connection
		{import classpath:/snippet/global/java-method-parameters-with-connection.templar}
	) {{{\n}

	{\t}{\t}try {{{\n}
	{\t}{\t}{\t}return({question.name}(connection
		{import classpath:/snippet/global/java-method-parameters-call-with-connection.templar}
		));{\n}

	{\t}{\t}} catch(SQLException sqlex) {{{\n}
		{import classpath:/snippet/global/exception-sql-log-silent.templar}
	{\t}{\t}{\t}return(false);{\n}
	{\t}{\t}}{\n}

	{\t}}{\n}
{\n}

	{\t}public static boolean {question.name}Silent(
		{import classpath:/snippet/global/java-method-parameters.templar}
	) {{{\n}

	{\t}{\t}try {{{\n}
	{\t}{\t}{\t}return({question.name}(
		{import classpath:/snippet/global/java-method-parameters-call.templar}
		));{\n}

	{\t}{\t}} catch(SQLException sqlex) {{{\n}
		{import classpath:/snippet/global/exception-sql-log-silent.templar}
	{\t}{\t}{\t}return(false);{\n}
	{\t}{\t}}{\n}

	{\t}}{\n}
{\n}

{endloop}
}
