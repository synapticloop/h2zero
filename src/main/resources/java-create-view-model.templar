package {database.package}.view;{\n}{\n}

// - - - - thoughtfully generated by synapticloop h2zero - - - - {\n}
//    with the use of synapticloop templar templating language{\n}{\n}
//              (java-create-view-model.templar){\n}{\n}

import synapticloop.h2zero.base.view.ViewBase;{\n}

{if fn:requiresImport[table, "Date"]}import java.sql.Date;{\n}{endif}
{if fn:requiresImport[table, "Clob"]}import java.sql.Clob;{\n}{endif}
{if fn:requiresImport[table, "Blob"]}import java.sql.Blob;{\n}{endif}
{if fn:requiresImport[table, "Timestamp"]}import java.sql.Timestamp;{\n}{endif}
{if fn:requiresImport[table, "Time"]}import java.sql.Time;{\n}{endif}
import {database.package}.model.util.Constants;{\n}

{\n}{\n}

{--
  if this isn't a lookup on a foreign key and if the foreign key is not a constant
  table, then we need to import the finder
}
{loop table.fields as field}
	{if fn:and[fn:notNull[field.foreignKeyTable], !field.foreignKeyTableLookup.isConstant]}
		import {database.package}.finder.{field.foreignKeyTableLookup.javaClassName}Finder;{\n}
		import {database.package}.model.{field.foreignKeyTableLookup.javaClassName};{\n}
	{endif}
{endloop}

public class {view.javaClassName} extends ViewBase {{{\n}
{\t}// the binder is unused in code, but will generate compile problems if this {\n}
{\t}// class is no longer referenced in the h2zero file. Just a nicety for{\n}
{\t}// removing dead code{\n}
{\t}@SuppressWarnings("unused"){\n}
{\t}private static final String BINDER = Constants.{view.upperName}_BINDER;{\n}{\n}

{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				LIST ALL OF THE JAVA FIELDS
}

{loop table.fields as field}
	{if fn:notNull[field.foreignKeyTable]}
		{if !field.foreignKeyTableLookup.isConstant}
			{\t}private {field.foreignKeyTableLookup.javaClassName} {field.secondaryJavaName} = null;{\n}
		{endif}
	{endif}
	{if fieldStatus.last}
		{\n}
	{endif}
{endloop}

{loop table.fields as field}
	{\t}private {field.javaType} {field.javaName} = null;{\n}
{endloop}
{\n}


{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				CONSTRUCTORS
			what about null-able fields?
}

{\t}public {view.javaClassName}(
	{loop view.fields as field}
		{field.javaType} {field.javaName}
		{if fieldStatus.last}{else}, {endif}
	{endloop}
) {{{\n}
	{loop view.fields as field}
		{\t}{\t}this.{field.javaName} = {field.javaName};{\n}
	{endloop}

{\t}}{\n}
{\n}

	{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					SETTERS AND GETTERS

					The first getter is for any referenced foreign key tables that exist
					which will get the actual object, rather than the primary key that 
					references it.
	}

	{loop table.fields as field}
		{if fn:notNull[field.foreignKeyTable]}
			{\t}public {field.foreignKeyTableLookup.javaClassName} get{field.secondaryJavaName}() {{{\n}
			{if !field.foreignKeyTableLookup.isConstant}
				{\t}{\t}if(null == this.{field.secondaryJavaName}) {{{\n}

				{\t}{\t}{\t}this.{field.secondaryJavaName} = {field.foreignKeyTableLookup.javaClassName}Finder.findByPrimaryKeySilent(this.{field.javaName});{\n}

				{\t}{\t}}{\n}

				{\t}{\t}return(this.{field.secondaryJavaName});{\n}
			{else}

				{--
					At this point the foreign table is constant so it was already looked up
					at construction time
				}

				{\t}{\t}return({field.foreignKeyTableLookup.javaClassName}.ALL_LOOKUP.get(this.{field.javaName}));{\n}
			{endif}

			{\t}}{\n}{\n}
		{endif}
	{endloop}

{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				GETTERS ONLY
}
{\t}/*{\n}
{\t} * Boring ol' getters{\n}
{\t} */{\n}
{\n}

{loop view.fields as field}
	{\t}public {field.javaType} get{field.javaAccessorName}() {{ return(this.{field.javaName}); }{\n}{\n}
{endloop}

	{-- Now we need the toString Method--}
	{\n}
		{\t}@Override{\n}
		{\t}public String toString() {{{\n}
		{\t}{\t}StringBuilder stringBuilder = new StringBuilder();{\n}

		{\t}{\t}stringBuilder.append("Model[{view.javaClassName}]\n");{\n}
		{loop view.fields as field}
			{\t}{\t}stringBuilder.append("  Field[{field.javaName}:" + this.{field.javaName} + "]\n");{\n}
		{endloop}

		{\t}{\t}return(stringBuilder.toString());{\n}
		{\t}}{\n}


	{-- Now we need the toJsonString Method--}
	{\n}
		{\t}public String toJsonString() {{{\n}
		{\t}{\t}StringBuilder stringBuilder = new StringBuilder();{\n}

		{\t}{\t}stringBuilder.append("{{\n");{\n}
		{\t}{\t}stringBuilder.append("  \"model\": {{\n");{\n}
		{\t}{\t}stringBuilder.append("    \"name\": \"{view.javaClassName}\",\n");{\n}
		{\t}{\t}stringBuilder.append("    \"fields\": [\n");{\n}

		{loop view.fields as field}
			{\t}{\t}stringBuilder.append("     {{ \"name\": \"{field.javaName}\", \"value\": {if field.shouldEscape}\"{endif}" + this.{field.javaName} + "{if field.shouldEscape}\"{endif} }{if !fieldStatus.last}, {endif}\n");{\n}
		{endloop}

		{\t}{\t}stringBuilder.append("    ]\n");{\n}
		{\t}{\t}stringBuilder.append("  }\n");{\n}
		{\t}{\t}stringBuilder.append("}\n");{\n}

		{\t}{\t}return(stringBuilder.toString());{\n}
		{\t}}{\n}
		{\n}

	{-- and the getJSONString - for chaining --}
	{\t}public String getJsonString() {{{\n}
	{\t}{\t}return(toJsonString());{\n}
	{\t}}{\n}

}
