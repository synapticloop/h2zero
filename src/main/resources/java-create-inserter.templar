{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
		PACKAGE DECLARATION, IMPORT STATEMENTS AND CLASS DEFINITION

		NOTES:
		  If the table is a constant - then this file will not be generated
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

package {database.package}.inserter;{\n}{\n}
// - - - - thoughtfully generated by synapticloop h2zero - - - - {\n}
//    with the use of synapticloop templar templating language{\n}
//              (java-create-inserter.templar){\n}{\n}

{if table.hasLargeObject}
	import java.io.InputStream;{\n}
{endif}
import java.sql.Connection;{\n}
import java.sql.PreparedStatement;{\n}
import java.sql.SQLException;{\n}
import java.math.BigDecimal;{\n}

{if fn:requiresImport[table, "Date"]}import java.sql.Date;{\n}{endif}
{if fn:requiresImport[table, "Clob"]}import java.sql.Clob;{\n}{endif}
{if fn:requiresImport[table, "Blob"]}import java.sql.Blob;{\n}{endif}
{if fn:requiresImport[table, "Timestamp"]}import java.sql.Timestamp;{\n}{endif}
{if fn:requiresImport[table, "Time"]}import java.sql.Time;{\n}{endif}
{\n}

{import classpath:/snippet/global/java-logger.templar}
import synapticloop.h2zero.base.manager.{options.database}.ConnectionManager;{\n}

import {database.package}.model.util.Constants;{\n}
{\n}

/**{\n}
{if !fn:=[fn:length[table.comments], "0"]}
	{loop table.comments as comment}
		 * {comment}{\n}
	{endloop}
 * {\n}
{endif}
 * This class contains the methods to insert new rows into the: {\n}
 *   <code>{database.schema}.{table.name}</code>{\n}
 * table.  The fields that are available are as follows:{\n}
 * {\n}
 * <ul>{\n}
{loop table.fields as field}
 *  <li><code>{field.name}</code> ({field.type}) {if !field.nullable} <strong>NOT</strong>{endif} nullable {if field.primary} (PRIMARY){endif}</li>{\n}
{endloop}
 * </ul>{\n}
 * {\n}
 * @author synapticloop h2zero{\n}
 */{\n}
{\n}
public class {table.javaClassName}Inserter {{{\n}
{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				THE INSERTER STRINGS FIELDS
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}
{set table as baseSchemaObject}


{import classpath:/snippet/global/java-binder-declaration.templar}
{set "Inserter" as classType}
{set table.javaClassName as loggerClass}
{\t}{import classpath:/snippet/global/java-logger-declaration.templar}
{\n}

{\t}// static fields generated by synapticloop h2zero{\n}
{\t}private static final String SQL_BUILTIN_INSERT_ALL = "insert into {table.name}(

	{loop table.fields as field}
		{field.name}{if !fieldStatus.last}, {endif}
	{endloop}
)";{\n}

{\t}private static final String SQL_BUILTIN_INSERT_VALUES = SQL_BUILTIN_INSERT_ALL + " values (
	{loop table.fields as field}
		?{if !fieldStatus.last}, {endif}
	{endloop}
)";{\n}

{\t}// static inserter SQL generated from the user input{\n}
{loop table.inserters as inserter}
{-- now for the insert clause --}
	{\t}private static final String SQL_{inserter.staticName} = 
	{if inserter.hasInsertClause}
		"{inserter.insertClause} " 
	{else}
		SQL_BUILTIN_INSERT_ALL 
	{endif}

	{if inserter.hasValuesClause}
		+ "{inserter.valuesClause} "
	{else}
		{if inserter.hasSelectClause}
			+ "{inserter.selectClause} "
		{endif}
		{if inserter.hasWhereClause}
			+ "{inserter.whereClause} "
		{endif}
	{endif};{\n}
{endloop}
{\n}

{\t}private {table.javaClassName}Inserter() {{}{\n}{\n}

{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				INSERTER WITH DEFAULT VALUES
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}
{\t}/**{\n}
{\t} * Insert a new {table.javaClassName} into the database utilising the passed in connection.{\n}
{\t} * {\n}
{\t} * @param connection the connection to use for the database, this __MUST__ be {\n}
{\t} *   closed by the calling function.{\n}

	{loop table.fields as field}
		{\t} * @param {field.javaName} {if fn:notNull[field.comment]}{comment}{else} maps to {field.name}{endif}{\n}
	{endloop}

{\t} * {\n}
{\t} * @return the number of rows that were inserted, or -1 if an error occurred{\n}
{\t} * {\n}
{\t} * @throws SQLException if there was an error in the SQL insert statement{\n}
{\t} */{\n}
{\t}public static int insert(Connection connection, {loop table.fields as field}
			{field.javaType} {field.javaName}
			{if fieldStatus.last}{else}, {endif}
		{endloop}) throws SQLException {{{\n}

		{\t}{\t}int numResults = -1;{\n}
		{\t}{\t}PreparedStatement preparedStatement = null;{\n}

		{\t}{\t}try {{{\n}
		{\t}{\t}{\t}preparedStatement = connection.prepareStatement(SQL_BUILTIN_INSERT_VALUES);{\n}

		{loop table.fields as field}
			{\t}{\t}{\t}ConnectionManager.set{field.upperType}(preparedStatement, {fieldStatus.index}, {field.javaName});{\n}
		{endloop}

		{\t}{\t}{\t}numResults = preparedStatement.executeUpdate();{\n}
		{\t}{\t}} catch (SQLException sqlex) {{{\n}
		{\t}{\t}{\t}throw sqlex;{\n}
		{\t}{\t}} finally {{{\n}
		{\t}{\t}{\t}ConnectionManager.closeAll(preparedStatement);{\n}
		{\t}{\t}}{\n}
		{\t}{\t}return(numResults);{\n}
{\t}}{\n}{\n}

{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				INSERTER WITH DEFAULT VALUES FOR ONLY NON-NULLABLE FIELDS
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

{if table.hasNullableFields}
	{\t}/**{\n}
	{\t} * Insert a new {table.javaClassName} into the database utilising the passed in connection {\n}
	{\t} * with only the fields that are allowed to be not null.{\n}
	{\t} * {\n}
	{\t} * @param connection the connection to use for the database, this __MUST__ be {\n}
	{\t} *   closed by the calling function.{\n}

		{loop table.nonNullFields as field}
			{if !field.nullable}
				{\t} * @param {field.javaName} {if fn:notNull[field.comment]}{comment}{else} maps to {field.name}{endif}{\n}
			{endif}
		{endloop}

	{\t} * {\n}
	{\t} * @return the number of rows that were inserted, or -1 if an error occurred{\n}
	{\t} * {\n}
	{\t} * @throws SQLException if there was an error in the SQL insert statement{\n}
	{\t} */{\n}
	{\t}public static int insert(Connection connection, {loop table.nonNullFields as field}
				{field.javaType} {field.javaName}
				{if fieldStatus.last}{else}, {endif}
			{endloop}) throws SQLException {{{\n}

			{\t}{\t}int numResults = -1;{\n}
			{\t}{\t}PreparedStatement preparedStatement = null;{\n}

			{\t}{\t}try {{{\n}
			{\t}{\t}{\t}preparedStatement = connection.prepareStatement(SQL_BUILTIN_INSERT_VALUES);{\n}

			{loop table.fields as field}
				{if field.nullable}
					{if field.isLargeObject}
						{\t}{\t}{\t}{field.javaType} {field.javaName}{field.javaType} = null;{\n}
						{\t}{\t}{\t}ConnectionManager.set{field.upperType}(preparedStatement, {fieldStatus.index}, {field.javaName}{field.javaType});{\n}
					{else}
						{\t}{\t}{\t}ConnectionManager.set{field.upperType}(preparedStatement, {fieldStatus.index}, null);{\n}
					{endif}
				{else}
					{\t}{\t}{\t}ConnectionManager.set{field.upperType}(preparedStatement, {fieldStatus.index}, {field.javaName});{\n}
				{endif}
			{endloop}

			{\t}{\t}{\t}numResults = preparedStatement.executeUpdate();{\n}
			{\t}{\t}} catch (SQLException sqlex) {{{\n}
			{\t}{\t}{\t}throw sqlex;{\n}
			{\t}{\t}} finally {{{\n}
			{\t}{\t}{\t}ConnectionManager.closeAll(preparedStatement);{\n}
			{\t}{\t}}{\n}
			{\t}{\t}return(numResults);{\n}
	{\t}}{\n}{\n}

{endif}


{\t}/**{\n}
{\t} * Insert a new {table.javaClassName} into the database a new connection will be retrieved {\n}
{\t} * from the pool, used and then closed.{\n}
{\t} * {\n}
	{loop table.fields as field}
		{\t} * @param {field.javaName} {if fn:notNull[field.comment]}{comment}{else} maps to {field.name}{endif}{\n}
	{endloop}

{\t} * {\n}
{\t} * @return the number of rows that were inserted, or -1 if an error occurred{\n}
{\t} * {\n}
{\t} * @throws SQLException if there was an error in the SQL insert statement{\n}
{\t} */{\n}
{\t}public static int insert({loop table.fields as field}
			{field.javaType} {field.javaName}
			{if fieldStatus.last}{else}, {endif}
		{endloop}) throws SQLException {{{\n}

		{\t}{\t}int numResults = -1;{\n}

		{\t}{\t}Connection connection = null;{\n}

		{\t}{\t}try {{{\n}
		{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
		{\t}{\t}{\t}numResults = insert(connection, {loop table.fields as field}
			{field.javaName}
			{if fieldStatus.last}{else}, {endif}
		{endloop});{\n}
		{\t}{\t}} catch (SQLException sqlex) {{{\n}
		{\t}{\t}{\t}throw sqlex;{\n}
		{\t}{\t}} finally {{{\n}
		{\t}{\t}{\t}ConnectionManager.closeAll(connection);{\n}
		{\t}{\t}}{\n}
		{\t}{\t}return(numResults);{\n}
		{\t}}{\n}{\n}


{if table.hasNullableFields}
	{\t}/**{\n}
	{\t} * Insert a new {table.javaClassName} into the database a new connection will be retrieved {\n}
	{\t} * from the pool, used and then closed. This is for fields which have a nullable allowed default{\n}
	{\t} * {\n}
		{loop table.nonNullFields as field}
			{\t} * @param {field.javaName} {if fn:notNull[field.comment]}{comment}{else} maps to {field.name}{endif}{\n}
		{endloop}

	{\t} * {\n}
	{\t} * @return the number of rows that were inserted, or -1 if an error occurred{\n}
	{\t} * {\n}
	{\t} * @throws SQLException if there was an error in the SQL insert statement{\n}
	{\t} */{\n}
	{\t}public static int insert({loop table.nonNullFields as field}
			{field.javaType} {field.javaName}
			{if fieldStatus.last}{else}, {endif}
		{endloop}) throws SQLException {{{\n}

		{\t}{\t}int numResults = -1;{\n}

		{\t}{\t}Connection connection = null;{\n}

		{\t}{\t}try {{{\n}
		{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
		{\t}{\t}{\t}numResults = insert(connection, {loop table.nonNullFields as field}
			{field.javaName}
			{if fieldStatus.last}{else}, {endif}
		{endloop});{\n}
		{\t}{\t}} catch (SQLException sqlex) {{{\n}
		{\t}{\t}{\t}throw sqlex;{\n}
		{\t}{\t}} finally {{{\n}
		{\t}{\t}{\t}ConnectionManager.closeAll(connection);{\n}
		{\t}{\t}}{\n}
		{\t}{\t}return(numResults);{\n}
		{\t}}{\n}{\n}
{endif}

	{\t}/**{\n}
	{\t} * Silently (i.e. swallow any exceptions) Insert a new {table.javaClassName} into the {\n}
	{\t} * database utilising the passed in connection. If an exception is thrown by the{\n}
	{\t} * method, the exception message will be logged as an 'error', if 'trace' logging{\n}
	{\t} * is enabled, the stack trace will be printed to the output stream.{\n}
	{\t} * {\n}
	{\t} * @param connection the connection to use for the database, this __MUST__ be {\n}
	{\t} *   closed by the calling function.{\n}

	{loop table.fields as field}
		{\t} * @param {field.javaName} {if fn:notNull[field.comment]}{comment}{else} maps to {field.name}{endif}{\n}
	{endloop}

	{\t} * {\n}
	{\t} * @return the number of rows that were inserted, or -1 if an error occurred{\n}
	{\t} */{\n}
	{\t}public static int insertSilent(Connection connection, {loop table.fields as field}
			{field.javaType} {field.javaName}
			{if fieldStatus.last}{else}, {endif}
		{endloop}) {{{\n}

		{\t}{\t}int numResults = -1;{\n}

		{\t}{\t}try {{{\n}
		{\t}{\t}{\t}numResults = insert(connection, {loop table.fields as field}
			{field.javaName}
			{if fieldStatus.last}{else}, {endif}
		{endloop});{\n}
		{\t}{\t}} catch (SQLException sqlex) {{{\n}
		{\t}{\t}{\t}LOGGER.error("SQLException caught, message was: {{}", sqlex.getMessage());{\n}
		{\t}{\t}{\t}if(LOGGER.isTraceEnabled()){{{\n}
		{\t}{\t}{\t}{\t}sqlex.printStackTrace();{\n}
		{\t}{\t}{\t}}{\n}
		{\t}{\t}}{\n}
		{\t}{\t}return(numResults);{\n}

	{\t}}{\n}{\n}


{if table.hasNullableFields}
	{\t}/**{\n}
	{\t} * Silently (i.e. swallow any exceptions) Insert a new {table.javaClassName} into the {\n}
	{\t} * database utilising the passed in connection. If an exception is thrown by the{\n}
	{\t} * method, the exception message will be logged as an 'error', if 'trace' logging{\n}
	{\t} * is enabled, the stack trace will be printed to the output stream.{\n}
	{\t} * {\n}
	{\t} * This is only for Non-Nullable fields{\n}
	{\t} * {\n}
	{\t} * @param connection the connection to use for the database, this __MUST__ be {\n}
	{\t} *   closed by the calling function.{\n}

	{loop table.nonNullFields as field}
		{\t} * @param {field.javaName} {if fn:notNull[field.comment]}{comment}{else} maps to {field.name}{endif}{\n}
	{endloop}

	{\t} * {\n}
	{\t} * @return the number of rows that were inserted, or -1 if an error occurred{\n}
	{\t} */{\n}
	{\t}public static int insertSilent(Connection connection, {loop table.nonNullFields as field}
			{field.javaType} {field.javaName}
			{if fieldStatus.last}{else}, {endif}
		{endloop}) {{{\n}

		{\t}{\t}int numResults = -1;{\n}

		{\t}{\t}try {{{\n}
		{\t}{\t}{\t}numResults = insert(connection, {loop table.nonNullFields as field}
			{field.javaName}
			{if fieldStatus.last}{else}, {endif}
		{endloop});{\n}
		{\t}{\t}} catch (SQLException sqlex) {{{\n}
		{\t}{\t}{\t}LOGGER.error("SQLException caught, message was: {{}", sqlex.getMessage());{\n}
		{\t}{\t}{\t}if(LOGGER.isTraceEnabled()){{{\n}
		{\t}{\t}{\t}{\t}sqlex.printStackTrace();{\n}
		{\t}{\t}{\t}}{\n}
		{\t}{\t}}{\n}
		{\t}{\t}return(numResults);{\n}

	{\t}}{\n}{\n}
{endif}



	{\t}/**{\n}
	{\t} * Silently (i.e. swallow any exceptions) Insert a new {table.javaClassName} into the {\n}
	{\t} * database, creating and closing a connection in the process. If an exception is thrown {\n}
	{\t} * by the method, the exception message will be logged as an 'error', if 'trace' logging{\n}
	{\t} * is enabled, the stack trace will be printed to the output stream.{\n}
	{\t} * {\n}

	{loop table.fields as field}
		{\t} * @param {field.javaName} {if fn:notNull[field.comment]}{comment}{else} maps to {field.name}{endif}{\n}
	{endloop}

	{\t} * {\n}
	{\t} * @return the number of rows that were inserted, or -1 if an error occurred{\n}
	{\t} */{\n}
	{\t}public static int insertSilent({loop table.fields as field}
			{field.javaType} {field.javaName}
			{if fieldStatus.last}{else}, {endif}
		{endloop}) {{{\n}

		{\t}{\t}int numResults = -1;{\n}

		{\t}{\t}Connection connection = null;{\n}

		{\t}{\t}try {{{\n}
		{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
		{\t}{\t}{\t}numResults = insert(connection, {loop table.fields as field}
			{field.javaName}
			{if fieldStatus.last}{else}, {endif}
		{endloop});{\n}
		{\t}{\t}} catch (SQLException sqlex) {{{\n}
		{\t}{\t}{\t}LOGGER.error("SQLException caught, message was: {{}", sqlex.getMessage());{\n}
		{\t}{\t}{\t}if(LOGGER.isTraceEnabled()){{{\n}
		{\t}{\t}{\t}{\t}sqlex.printStackTrace();{\n}
		{\t}{\t}{\t}}{\n}
		{\t}{\t}} finally {{{\n}
		{\t}{\t}{\t}ConnectionManager.closeAll(connection);{\n}
		{\t}{\t}}{\n}
		{\t}{\t}return(numResults);{\n}

	{\t}}{\n}{\n}



{if table.hasNullableFields}
	{\t}/**{\n}
	{\t} * Silently (i.e. swallow any exceptions) Insert a new {table.javaClassName} into the {\n}
	{\t} * database, creating and closing a connection in the process. If an exception is thrown {\n}
	{\t} * by the method, the exception message will be logged as an 'error', if 'trace' logging{\n}
	{\t} * is enabled, the stack trace will be printed to the output stream.{\n}
	{\t} * {\n}
	{\t} * This is for non-nullabel fields only{\n}
	{\t} * {\n}

	{loop table.nonNullFields as field}
		{\t} * @param {field.javaName} {if fn:notNull[field.comment]}{comment}{else} maps to {field.name}{endif}{\n}
	{endloop}

	{\t} * {\n}
	{\t} * @return the number of rows that were inserted, or -1 if an error occurred{\n}
	{\t} */{\n}
	{\t}public static int insertSilent({loop table.nonNullFields as field}
			{field.javaType} {field.javaName}
			{if fieldStatus.last}{else}, {endif}
		{endloop}) {{{\n}

		{\t}{\t}int numResults = -1;{\n}

		{\t}{\t}Connection connection = null;{\n}

		{\t}{\t}try {{{\n}
		{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
		{\t}{\t}{\t}numResults = insert(connection, {loop table.nonNullFields as field}
			{field.javaName}
			{if fieldStatus.last}{else}, {endif}
		{endloop});{\n}
		{\t}{\t}} catch (SQLException sqlex) {{{\n}
		{\t}{\t}{\t}LOGGER.error("SQLException caught, message was: {{}", sqlex.getMessage());{\n}
		{\t}{\t}{\t}if(LOGGER.isTraceEnabled()){{{\n}
		{\t}{\t}{\t}{\t}sqlex.printStackTrace();{\n}
		{\t}{\t}{\t}}{\n}
		{\t}{\t}} finally {{{\n}
		{\t}{\t}{\t}ConnectionManager.closeAll(connection);{\n}
		{\t}{\t}}{\n}
		{\t}{\t}return(numResults);{\n}

	{\t}}{\n}{\n}
{endif}

{--
  Now for the fields which have clobs or blobs
}
{if table.hasLargeObject}
	{\t}public static int insert(Connection connection, {loop table.fields as field}
				{if field.isLargeObject}
					InputStream {field.javaName}
				{else}
					{field.javaType} {field.javaName}
				{endif}
				{if fieldStatus.last}{else}, {endif}
			{endloop}) throws SQLException {{{\n}

			{\t}{\t}int numResults = -1;{\n}
			{\t}{\t}PreparedStatement preparedStatement = null;{\n}
			{\t}{\t}try {{{\n}
			{\t}{\t}{\t}preparedStatement = connection.prepareStatement(SQL_BUILTIN_INSERT_VALUES);{\n}

			{loop table.fields as field}
				{if field.isLargeObject}
					{\t}{\t}{\t}ConnectionManager.set{field.upperType}InputStream(preparedStatement, {fieldStatus.index}, {field.javaName});{\n}
				{else}
					{\t}{\t}{\t}ConnectionManager.set{field.upperType}(preparedStatement, {fieldStatus.index}, {field.javaName});{\n}
				{endif}
			{endloop}

			{\t}{\t}{\t}numResults = preparedStatement.executeUpdate();{\n}
			{\t}{\t}} catch (SQLException sqlex) {{{\n}
			{\t}{\t}{\t}throw sqlex;{\n}
			{\t}{\t}} finally {{{\n}
			{\t}{\t}{\t}ConnectionManager.closeAll(preparedStatement);{\n}
			{\t}{\t}}{\n}


			{\t}{\t}return(numResults);{\n}

	{\t}}{\n}{\n}

	{\t}public static int insert({loop table.fields as field}
				{if field.isLargeObject}
					InputStream {field.javaName}
				{else}
					{field.javaType} {field.javaName}
				{endif}
				{if fieldStatus.last}{else}, {endif}
			{endloop}) throws SQLException {{{\n}

			{\t}{\t}int numResults = -1;{\n}
			{\t}{\t}Connection connection = null;{\n}

			{\t}{\t}try {{{\n}
			{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
			{\t}{\t}{\t}numResults = insert(connection, {loop table.fields as field}
				{field.javaName}
				{if fieldStatus.last}{else}, {endif}
			{endloop});{\n}
			{\t}{\t}} catch (SQLException sqlex) {{{\n}
			{\t}{\t}{\t}throw sqlex;{\n}
			{\t}{\t}} finally {{{\n}
			{\t}{\t}{\t}ConnectionManager.closeAll(connection);{\n}
			{\t}{\t}}{\n}
			{\t}{\t}return(numResults);{\n}
	{\t}}{\n}{\n}

	{\t}public static int insertSilent(Connection connection, {loop table.fields as field}
				{if field.isLargeObject}
					InputStream {field.javaName}
				{else}
					{field.javaType} {field.javaName}
				{endif}
				{if fieldStatus.last}{else}, {endif}
			{endloop}) {{{\n}

			{\t}{\t}int numResults = -1;{\n}

			{\t}{\t}try {{{\n}
			{\t}{\t}{\t}numResults = insert(connection, {loop table.fields as field}
				{field.javaName}
				{if fieldStatus.last}{else}, {endif}
			{endloop});{\n}
			{\t}{\t}} catch (SQLException sqlex) {{{\n}
			{\t}{\t}{\t}LOGGER.error("SQLException caught, message was: {{}", sqlex.getMessage());{\n}
			{\t}{\t}{\t}if(LOGGER.isTraceEnabled()){{{\n}
			{\t}{\t}{\t}{\t}sqlex.printStackTrace();{\n}
			{\t}{\t}{\t}}{\n}
			{\t}{\t}}{\n}
			{\t}{\t}return(numResults);{\n}

	{\t}}{\n}{\n}

	{\t}public static int insertSilent({loop table.fields as field}
				{if field.isLargeObject}
					InputStream {field.javaName}
				{else}
					{field.javaType} {field.javaName}
				{endif}
				{if fieldStatus.last}{else}, {endif}
			{endloop}) {{{\n}

			{\t}{\t}int numResults = 0;{\n}

			{\t}{\t}Connection connection = null;{\n}

			{\t}{\t}try {{{\n}
			{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
			{\t}{\t}{\t}numResults = insert(connection, {loop table.fields as field}
				{field.javaName}
				{if fieldStatus.last}{else}, {endif}
			{endloop});{\n}
			{\t}{\t}} catch (SQLException sqlex) {{{\n}
			{\t}{\t}{\t}LOGGER.error("SQLException caught, message was: {{}", sqlex.getMessage());{\n}
			{\t}{\t}{\t}if(LOGGER.isTraceEnabled()){{{\n}
			{\t}{\t}{\t}{\t}sqlex.printStackTrace();{\n}
			{\t}{\t}{\t}}{\n}
			{\t}{\t}} finally {{{\n}
			{\t}{\t}{\t}ConnectionManager.closeAll(connection);{\n}
			{\t}{\t}}{\n}
			{\t}{\t}return(numResults);{\n}

	{\t}}{\n}{\n}

{endif}

{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				NOW FOR THE CUSTOM DESIGNED INSERTERS
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

{loop table.inserters as inserter}
	{\t}public static int {inserter.name}(Connection connection
			{loop inserter.allUniqueFields as field}
				, {field.javaType} {field.javaName}
			{endloop}
			) throws SQLException {{{\n}

		{\t}{\t}int numResults = -1;{\n}
		{\t}{\t}PreparedStatement preparedStatement = null;{\n}
		{\t}{\t}try {{{\n}

		{if inserter.hasInsertClause}
			{\t}{\t}{\t}preparedStatement = connection.prepareStatement(SQL_{inserter.staticName});{\n}
		{else}
			{\t}{\t}{\t}preparedStatement = connection.prepareStatement(SQL_BUILTIN_INSERT_ALL);{\n}
		{endif}
		{loop inserter.allFields as field}
			{\t}{\t}{\t}ConnectionManager.set{field.upperType}(preparedStatement, {fieldStatus.index}, {field.javaName});{\n}
		{endloop}

		{\t}{\t}{\t}numResults = preparedStatement.executeUpdate();{\n}
		{\t}{\t}} catch (SQLException sqlex) {{{\n}
		{\t}{\t}{\t}throw sqlex;{\n}
		{\t}{\t}} finally {{{\n}
		{\t}{\t}{\t}ConnectionManager.closeAll(preparedStatement);{\n}
		{\t}{\t}}{\n}

		{\t}{\t}return(numResults);{\n}
	{\t}}{\n}{\n}

	{\t}public static int {inserter.name}Silent(
			{loop inserter.allUniqueFields as field}
				{field.javaType} {field.javaName}
				{if !fieldStatus.last}, {endif}
			{endloop}
			) {{{\n}

		{\t}{\t}int numResults = -1;{\n}
		{\t}{\t}Connection connection = null;{\n}
		{\t}{\t}try {{{\n}
		{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
		{\t}{\t}{\t}numResults = {inserter.name}(connection
			{loop inserter.allUniqueFields as field}
				, {field.javaName}
			{endloop}
		);{\n}
		{\t}{\t}} catch (SQLException sqlex) {{{\n}
		{\t}{\t}{\t}sqlex.printStackTrace();{\n}
		{\t}{\t}}{\n}

		{\t}{\t}{\n}
		{\t}{\t}return(numResults);{\n}
	{\t}}{\n}

	{--
	  Now for the fields which have clobs or blobs
	}
	{if table.hasLargeObject}

		{\t}public static int {inserter.name}(Connection connection
				{loop inserter.allUniqueFields as field}
					{if field.isLargeObject}
						, InputStream {field.javaName}
					{else}
						, {field.javaType} {field.javaName}
					{endif}
				{endloop}
				) throws SQLException {{{\n}

			{\t}{\t}int numResults = 0;{\n}
			{\t}{\t}PreparedStatement preparedStatement = null;{\n}
			{\t}{\t}{\t}try {{{\n}

			{if inserter.hasInsertClause}
				{\t}{\t}{\t}preparedStatement = connection.prepareStatement(SQL_{inserter.staticName});{\n}
			{else}
				{\t}{\t}{\t}preparedStatement = connection.prepareStatement(SQL_BUILTIN_INSERT_ALL);{\n}
			{endif}
			{loop inserter.allFields as field}
				{\t}{\t}{\t}ConnectionManager.set{field.upperType}(preparedStatement, {fieldStatus.index}, {field.javaName});{\n}
			{endloop}
			{\t}{\t}{\t}numResults = preparedStatement.executeUpdate();{\n}
			{\t}{\t}} catch (SQLException sqlex) {{{\n}
			{\t}{\t}{\t}throw sqlex;{\n}
			{\t}{\t}} finally {{{\n}
			{\t}{\t}{\t}ConnectionManager.closeAll(preparedStatement);{\n}
			{\t}{\t}}{\n}
			{\t}{\t}{\n}
			{\t}{\t}return(numResults);{\n}
		{\t}}{\n}{\n}

		{\t}public static int {inserter.name}Silent(
				{loop inserter.allUniqueFields as field}
					{if field.isLargeObject}
						InputStream {field.javaName}
					{else}
						{field.javaType} {field.javaName}
					{endif}
					{if !fieldStatus.last}, {endif}
				{endloop}
				) {{{\n}
			{\t}{\t}int numResults = -1;{\n}
			{\t}{\t}Connection connection = null;{\n}
			{\t}{\t}try {{{\n}
			{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
			{\t}{\t}{\t}numResults = {inserter.name}(connection
				{loop inserter.allUniqueFields as field}
					, {field.javaName}
				{endloop}
			);{\n}
			{\t}{\t}} catch (SQLException sqlex) {{{\n}
			{\t}{\t}{\t}LOGGER.error("SQLException caught, message was: {{}", sqlex.getMessage());{\n}
			{\t}{\t}{\t}if(LOGGER.isTraceEnabled()){{{\n}
			{\t}{\t}{\t}{\t}sqlex.printStackTrace();{\n}
			{\t}{\t}{\t}}{\n}
			{\t}{\t}} finally {{{\n}
			{\t}{\t}{\t}ConnectionManager.closeAll(connection);{\n}
			{\t}{\t}}{\n}

			{\t}{\t}{\n}
			{\t}{\t}return(numResults);{\n}
		{\t}}{\n}
	{endif}
{endloop}

}